[
  {
    "id": 1,
    "question": "What are the Navier-Stokes equations and why are they fundamental to CFD?",
    "answer": "The **Navier-Stokes equations** are a set of nonlinear partial differential equations that describe the motion of viscous fluid substances.\n\n**The equations express:**\n- Conservation of mass (continuity)\n- Conservation of momentum\n- Conservation of energy\n\n**Momentum equation (incompressible):**\n$$\\rho\\left(\\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u} \\cdot \\nabla\\mathbf{u}\\right) = -\\nabla p + \\mu\\nabla^2\\mathbf{u} + \\mathbf{f}$$\n\n**Terms:**\n- ρ(∂u/∂t): Unsteady acceleration\n- ρ(u·∇u): Convective acceleration\n- -∇p: Pressure gradient force\n- μ∇²u: Viscous diffusion\n- f: Body forces (gravity)\n\n**Why fundamental:**\n- Govern all fluid flow phenomena\n- Basis for all CFD solvers\n- No general analytical solution exists (millennium prize problem)\n- Must be solved numerically for complex geometries",
    "example": "// Incompressible Navier-Stokes in 2D (simplified)\n// Continuity: ∂u/∂x + ∂v/∂y = 0\n// X-momentum: ∂u/∂t + u∂u/∂x + v∂u/∂y = -1/ρ ∂p/∂x + ν(∂²u/∂x² + ∂²u/∂y²)\n// Y-momentum: ∂v/∂t + u∂v/∂x + v∂v/∂y = -1/ρ ∂p/∂y + ν(∂²v/∂x² + ∂²v/∂y²)\n\n// Key dimensionless number - Reynolds number\n// Re = ρUL/μ = UL/ν\n// - Low Re (< 1): Viscous dominated, Stokes flow\n// - Moderate Re: Laminar flow\n// - High Re (> 4000): Turbulent flow\n\n// Example: Flow regimes\nfunction flowRegime(Re) {\n  if (Re < 1) return 'Creeping/Stokes flow';\n  if (Re < 2300) return 'Laminar';\n  if (Re < 4000) return 'Transitional';\n  return 'Turbulent';\n}"
  },
  {
    "id": 2,
    "question": "What is the Finite Volume Method (FVM) and why is it popular in CFD?",
    "answer": "**Finite Volume Method (FVM)** divides the domain into discrete control volumes and applies conservation laws to each volume.\n\n**Key concept:**\n- Integrate governing equations over each control volume\n- Convert volume integrals to surface integrals (Gauss theorem)\n- Compute fluxes across cell faces\n\n**Conservation property:**\n$$\\frac{\\partial}{\\partial t}\\int_V \\phi dV + \\oint_S \\mathbf{F} \\cdot d\\mathbf{S} = \\int_V Q dV$$\n\n**Advantages:**\n- Inherently conservative (mass, momentum, energy)\n- Works with unstructured meshes\n- Handles complex geometries well\n- Clear physical interpretation\n- Robust for discontinuities (shocks)\n\n**Popular codes using FVM:**\n- OpenFOAM\n- ANSYS Fluent\n- STAR-CCM+\n\n**vs Other methods:**\n- FDM: Simpler but not conservative on irregular grids\n- FEM: Better for structural, less intuitive for fluids",
    "example": "// FVM discretization concept for 1D convection-diffusion\n// ∂(ρφ)/∂t + ∂(ρuφ)/∂x = ∂/∂x(Γ ∂φ/∂x)\n\n// Integrate over control volume [xW, xE]:\n// d/dt(ρφP·ΔV) + Fe - Fw = De - Dw\n\n// Where:\n// Fe = (ρuφ)e·Ae  -- Convective flux at east face\n// De = Γe·(φE - φP)/(xE - xP)·Ae  -- Diffusive flux\n\n// Cell-centered FVM structure\nclass ControlVolume {\n  constructor(index, volume, faces) {\n    this.index = index;\n    this.volume = volume;    // Cell volume\n    this.faces = faces;      // Array of face objects\n    this.phi = 0;            // Cell-centered value\n  }\n  \n  computeFluxBalance(dt) {\n    let netFlux = 0;\n    for (const face of this.faces) {\n      netFlux += face.computeFlux(); // F·n·A\n    }\n    return netFlux;\n  }\n}"
  },
  {
    "id": 3,
    "question": "What is the difference between structured and unstructured meshes?",
    "answer": "**Structured Mesh:**\n- Regular connectivity pattern (i,j,k indexing)\n- Cells arranged in a logical grid\n- Each interior node has same number of neighbors\n\n**Advantages:**\n- Memory efficient (implicit connectivity)\n- Faster solvers (aligned with flow)\n- Higher accuracy for simple geometries\n- Easy to implement high-order schemes\n\n**Disadvantages:**\n- Difficult for complex geometries\n- May require multi-block approaches\n- Time-consuming mesh generation\n\n**Unstructured Mesh:**\n- Arbitrary connectivity (explicit storage)\n- Triangles/tetrahedra or polygons/polyhedra\n- Flexible cell shapes and sizes\n\n**Advantages:**\n- Handles complex geometries easily\n- Automated mesh generation\n- Local refinement straightforward\n\n**Disadvantages:**\n- Higher memory usage\n- Slower computations\n- More numerical diffusion\n\n**Hybrid meshes** combine both: structured near walls, unstructured elsewhere.",
    "example": "// Structured mesh: implicit connectivity\n// Node (i,j) neighbors: (i±1,j), (i,j±1)\nclass StructuredMesh {\n  constructor(ni, nj) {\n    this.ni = ni;\n    this.nj = nj;\n    this.values = new Array(ni * nj).fill(0);\n  }\n  \n  index(i, j) { return j * this.ni + i; }\n  \n  getValue(i, j) { return this.values[this.index(i, j)]; }\n  \n  getNeighbors(i, j) {\n    // Implicit - no storage needed!\n    return [\n      [i-1, j], [i+1, j],  // West, East\n      [i, j-1], [i, j+1]   // South, North\n    ];\n  }\n}\n\n// Unstructured mesh: explicit connectivity\nclass UnstructuredMesh {\n  constructor() {\n    this.nodes = [];      // [{x, y, z}]\n    this.cells = [];      // [{nodeIds: [], neighborIds: []}]\n    this.faces = [];      // [{nodeIds: [], ownerCell, neighborCell}]\n  }\n  \n  getCellNeighbors(cellId) {\n    // Must be stored explicitly\n    return this.cells[cellId].neighborIds;\n  }\n}"
  },
  {
    "id": 4,
    "question": "What is the CFL condition and why is it important?",
    "answer": "**CFL (Courant-Friedrichs-Lewy) condition** is a stability criterion for explicit time-stepping schemes.\n\n**Definition:**\n$$CFL = \\frac{u \\Delta t}{\\Delta x} \\leq C_{max}$$\n\n**Physical meaning:**\n- Information should not travel more than one cell per time step\n- Domain of dependence of numerical scheme must contain physical domain\n\n**For different equations:**\n- Pure convection: CFL ≤ 1\n- Wave equation: CFL ≤ 1\n- Navier-Stokes: Typically CFL ≤ 1 for explicit schemes\n\n**In multiple dimensions:**\n$$CFL = \\Delta t \\left(\\frac{|u|}{\\Delta x} + \\frac{|v|}{\\Delta y} + \\frac{|w|}{\\Delta z}\\right) \\leq 1$$\n\n**Implications:**\n- Limits time step size for stability\n- Finer meshes → smaller time steps\n- Implicit schemes can exceed CFL = 1\n- High-speed flows require very small Δt\n\n**Practical values:**\n- Explicit: CFL = 0.5-0.9\n- Implicit: CFL = 1-100+",
    "example": "// CFL number calculation and adaptive time stepping\nfunction calculateCFL(u, v, w, dx, dy, dz, dt) {\n  return dt * (\n    Math.abs(u) / dx +\n    Math.abs(v) / dy +\n    Math.abs(w) / dz\n  );\n}\n\n// Adaptive time step based on CFL\nfunction adaptiveTimeStep(mesh, velocity, targetCFL = 0.8) {\n  let maxCFL = 0;\n  \n  for (const cell of mesh.cells) {\n    const localCFL = calculateCFL(\n      velocity[cell.id].u,\n      velocity[cell.id].v,\n      velocity[cell.id].w,\n      cell.dx, cell.dy, cell.dz,\n      1.0  // Unit time step\n    );\n    maxCFL = Math.max(maxCFL, localCFL);\n  }\n  \n  // Scale time step to achieve target CFL\n  return targetCFL / maxCFL;\n}\n\n// Example: Why CFL matters\n// dx = 0.01m, u = 100 m/s\n// For CFL = 1: dt_max = dx/u = 0.01/100 = 0.0001s\n// Very small time step required for high-speed flows!"
  },
  {
    "id": 5,
    "question": "What are the main turbulence modeling approaches in CFD?",
    "answer": "**Turbulence modeling** approximates the effects of turbulent fluctuations that are too expensive to resolve directly.\n\n**Hierarchy (cost vs accuracy):**\n\n**1. RANS (Reynolds-Averaged Navier-Stokes)**\n- Time-averaged equations\n- Models all turbulence\n- Cheapest, least accurate\n- Types: k-ε, k-ω, Spalart-Allmaras\n\n**2. LES (Large Eddy Simulation)**\n- Resolves large eddies, models small ones\n- Spatial filtering approach\n- Requires finer mesh than RANS\n- Subgrid-scale models: Smagorinsky, WALE\n\n**3. DNS (Direct Numerical Simulation)**\n- Resolves all scales\n- No modeling\n- Extremely expensive: N ~ Re^(9/4)\n- Research tool only\n\n**4. Hybrid RANS-LES**\n- DES (Detached Eddy Simulation)\n- RANS near walls, LES in free stream\n- Balance of cost and accuracy\n\n**Choosing a model:**\n- Steady, attached flow: RANS\n- Unsteady, separated flow: LES/DES\n- Fundamental research: DNS",
    "example": "// RANS: Solve for mean quantities + turbulence model\n// Reynolds decomposition: u = U + u' (mean + fluctuation)\n// Reynolds stress: -ρ<u'v'> appears in averaged equations\n\n// k-ε model equations (simplified)\n// Turbulent kinetic energy: k = 0.5*<u'u' + v'v' + w'w'>\n// Dissipation rate: ε\n// Turbulent viscosity: νt = Cμ * k² / ε\n\nclass RANSSolver {\n  constructor() {\n    this.k = [];    // Turbulent kinetic energy\n    this.epsilon = [];  // Dissipation rate\n    this.Cmu = 0.09;\n  }\n  \n  turbulentViscosity(cellId) {\n    return this.Cmu * Math.pow(this.k[cellId], 2) / this.epsilon[cellId];\n  }\n}\n\n// LES: Filter equations, model subgrid scales\n// Smagorinsky model: νsgs = (Cs*Δ)² * |S|\n// Where Δ = filter width, |S| = strain rate magnitude\n\nclass LESSolver {\n  constructor(Cs = 0.1) {\n    this.Cs = Cs;  // Smagorinsky constant\n  }\n  \n  subgridViscosity(filterWidth, strainRate) {\n    return Math.pow(this.Cs * filterWidth, 2) * strainRate;\n  }\n}"
  },
  {
    "id": 6,
    "question": "What is the SIMPLE algorithm for pressure-velocity coupling?",
    "answer": "**SIMPLE (Semi-Implicit Method for Pressure-Linked Equations)** solves the coupled pressure-velocity system in incompressible flows.\n\n**The problem:**\n- Pressure doesn't appear explicitly in continuity\n- Velocity and pressure are coupled\n- Need iterative procedure\n\n**Algorithm steps:**\n1. Guess pressure field p*\n2. Solve momentum equations → u*, v*, w*\n3. Solve pressure correction equation → p'\n4. Correct pressure: p = p* + αp·p'\n5. Correct velocities: u = u* + u'\n6. Check convergence, repeat if needed\n\n**Pressure correction equation:**\n- Derived from continuity constraint\n- Poisson-like equation for p'\n\n**Variants:**\n- SIMPLE: Under-relaxation needed (αp ~ 0.3)\n- SIMPLEC: Consistent, less under-relaxation\n- PISO: Predictor-corrector, unsteady flows\n- PIMPLE: Combines PISO + SIMPLE\n\n**Under-relaxation:**\n- Pressure: αp = 0.3-0.7\n- Velocity: αu = 0.5-0.7\n- Required for stability",
    "example": "// SIMPLE algorithm pseudocode\nclass SIMPLESolver {\n  constructor() {\n    this.alphaP = 0.3;  // Pressure under-relaxation\n    this.alphaU = 0.7;  // Velocity under-relaxation\n    this.tolerance = 1e-6;\n  }\n  \n  solve(mesh, maxIter = 1000) {\n    let p = this.initializePressure(mesh);\n    \n    for (let iter = 0; iter < maxIter; iter++) {\n      // Step 1: Solve momentum with guessed pressure\n      const uStar = this.solveMomentum(mesh, p);\n      \n      // Step 2: Solve pressure correction\n      const pPrime = this.solvePressureCorrection(mesh, uStar);\n      \n      // Step 3: Correct pressure\n      p = this.correctPressure(p, pPrime, this.alphaP);\n      \n      // Step 4: Correct velocity\n      const u = this.correctVelocity(uStar, pPrime);\n      \n      // Step 5: Check convergence\n      const residual = this.computeResidual(mesh, u, p);\n      if (residual < this.tolerance) {\n        console.log(`Converged in ${iter} iterations`);\n        return { u, p };\n      }\n    }\n    throw new Error('SIMPLE did not converge');\n  }\n  \n  correctPressure(p, pPrime, alpha) {\n    return p.map((pi, i) => pi + alpha * pPrime[i]);\n  }\n}"
  },
  {
    "id": 7,
    "question": "What are the different convection schemes and their properties?",
    "answer": "**Convection schemes** approximate the convective term (u·∇φ) at cell faces.\n\n**Key properties:**\n- **Boundedness**: No unphysical overshoots/undershoots\n- **Accuracy**: Order of truncation error\n- **Stability**: Numerical stability\n\n**Common schemes:**\n\n**1. First-Order Upwind (FOU)**\n- Uses upstream value\n- Bounded, stable, very diffusive\n- 1st order accurate\n\n**2. Central Differencing (CD)**\n- Averages neighbors\n- 2nd order accurate\n- Unbounded, can oscillate\n\n**3. Second-Order Upwind (SOU)**\n- Extrapolates from upstream\n- 2nd order, less diffusive than FOU\n- Can be unbounded\n\n**4. QUICK**\n- Quadratic interpolation\n- 3rd order on uniform meshes\n- Slightly unbounded\n\n**5. TVD Schemes (Van Leer, MUSCL)**\n- Total Variation Diminishing\n- High accuracy + boundedness\n- Use flux limiters\n\n**Rule of thumb:**\n- Diffusion-dominated: CD is fine\n- Convection-dominated: Use upwind or TVD",
    "example": "// Convection scheme implementations for face value\n\n// First Order Upwind - most stable, most diffusive\nfunction upwind(phiP, phiN, flux) {\n  return flux >= 0 ? phiP : phiN;\n}\n\n// Central Differencing - 2nd order, may oscillate\nfunction centralDiff(phiP, phiN) {\n  return 0.5 * (phiP + phiN);\n}\n\n// Second Order Upwind with gradient\nfunction secondOrderUpwind(phiP, phiN, gradPhi, dx, flux) {\n  if (flux >= 0) {\n    return phiP + 0.5 * gradPhi * dx;\n  } else {\n    return phiN - 0.5 * gradPhi * dx;\n  }\n}\n\n// TVD scheme with Van Leer limiter\nfunction vanLeerLimiter(r) {\n  // r = ratio of consecutive gradients\n  return (r + Math.abs(r)) / (1 + Math.abs(r));\n}\n\nfunction tvdScheme(phiP, phiN, phiUU, flux) {\n  const r = (phiP - phiUU) / (phiN - phiP + 1e-10);\n  const psi = vanLeerLimiter(r);\n  const phiFace = upwind(phiP, phiN, flux);\n  const phiHighOrder = centralDiff(phiP, phiN);\n  return phiFace + psi * (phiHighOrder - phiFace);\n}"
  },
  {
    "id": 8,
    "question": "What are boundary conditions in CFD and what types exist?",
    "answer": "**Boundary conditions (BCs)** specify the behavior of flow variables at domain boundaries.\n\n**Mathematical types:**\n\n**1. Dirichlet (First kind)**\n- Specifies the value: φ = φ₀\n- Example: Fixed wall temperature\n\n**2. Neumann (Second kind)**\n- Specifies the gradient: ∂φ/∂n = q₀\n- Example: Heat flux, zero-gradient outflow\n\n**3. Robin (Third kind)**\n- Mixed: aφ + b∂φ/∂n = c\n- Example: Convective heat transfer\n\n**Physical boundary types:**\n\n**Walls:**\n- No-slip: u = 0 (viscous)\n- Slip: u·n = 0 (inviscid)\n- Moving wall: u = u_wall\n\n**Inlets:**\n- Velocity inlet: u = u_in\n- Pressure inlet: p = p_in\n- Mass flow inlet: ṁ = ṁ_in\n\n**Outlets:**\n- Pressure outlet: p = p_out\n- Outflow: ∂φ/∂n = 0\n- Convective: ∂φ/∂t + U∂φ/∂n = 0\n\n**Symmetry:**\n- Zero normal velocity: u·n = 0\n- Zero normal gradients: ∂φ/∂n = 0",
    "example": "// Boundary condition implementation\nclass BoundaryCondition {\n  apply(mesh, field, boundaryFaces) {\n    throw new Error('Must implement apply()');\n  }\n}\n\n// Dirichlet BC - Fixed value\nclass FixedValue extends BoundaryCondition {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  apply(mesh, field, boundaryFaces) {\n    for (const face of boundaryFaces) {\n      field[face.ghostCell] = this.value;\n    }\n  }\n}\n\n// Neumann BC - Fixed gradient (zero gradient common)\nclass ZeroGradient extends BoundaryCondition {\n  apply(mesh, field, boundaryFaces) {\n    for (const face of boundaryFaces) {\n      // Ghost cell value = internal cell value\n      field[face.ghostCell] = field[face.ownerCell];\n    }\n  }\n}\n\n// No-slip wall for velocity\nclass NoSlipWall extends BoundaryCondition {\n  apply(mesh, velocity, boundaryFaces) {\n    for (const face of boundaryFaces) {\n      velocity[face.ghostCell] = { u: 0, v: 0, w: 0 };\n    }\n  }\n}\n\n// Inlet velocity\nclass VelocityInlet extends BoundaryCondition {\n  constructor(uIn, vIn, wIn) {\n    super();\n    this.velocity = { u: uIn, v: vIn, w: wIn };\n  }\n  \n  apply(mesh, velocity, boundaryFaces) {\n    for (const face of boundaryFaces) {\n      velocity[face.ghostCell] = { ...this.velocity };\n    }\n  }\n}"
  },
  {
    "id": 9,
    "question": "What is mesh quality and why does it matter?",
    "answer": "**Mesh quality** measures how well cells conform to ideal shapes, directly affecting solution accuracy and convergence.\n\n**Key quality metrics:**\n\n**1. Aspect Ratio**\n- Ratio of longest to shortest edge\n- Ideal: 1 (equilateral)\n- Acceptable: < 5-10 (interior), < 100 (boundary layer)\n\n**2. Skewness**\n- Deviation from ideal shape\n- 0 = perfect, 1 = degenerate\n- Target: < 0.85, ideal < 0.5\n\n**3. Orthogonality**\n- Angle between face normal and cell-center vector\n- 90° = perfect\n- Non-orthogonality > 70° causes issues\n\n**4. Smoothness**\n- Ratio of adjacent cell volumes\n- Should be < 1.2-1.5\n- Gradual transitions important\n\n**Impact of poor quality:**\n- Increased numerical diffusion\n- Slower convergence\n- Solution instability\n- Inaccurate gradients\n- Unbounded solutions\n\n**Best practices:**\n- Refine in high-gradient regions\n- Maintain smooth transitions\n- Align mesh with flow direction\n- Use inflation layers at walls",
    "example": "// Mesh quality calculations\n\n// Aspect ratio for a cell\nfunction aspectRatio(cell) {\n  const edges = cell.getEdgeLengths();\n  return Math.max(...edges) / Math.min(...edges);\n}\n\n// Skewness (equilateral deviation method)\nfunction skewness(cell) {\n  const optimalVolume = cell.getOptimalVolume(); // Equilateral\n  const actualVolume = cell.volume;\n  return (optimalVolume - actualVolume) / optimalVolume;\n}\n\n// Non-orthogonality angle\nfunction nonOrthogonality(face, ownerCell, neighborCell) {\n  // Vector from owner center to neighbor center\n  const d = neighborCell.center.subtract(ownerCell.center);\n  // Face normal\n  const n = face.normal;\n  // Angle between d and n\n  const cosTheta = d.dot(n) / (d.magnitude() * n.magnitude());\n  return Math.acos(cosTheta) * 180 / Math.PI; // degrees\n}\n\n// Check mesh quality\nfunction checkMeshQuality(mesh) {\n  const report = {\n    maxAspectRatio: 0,\n    maxSkewness: 0,\n    maxNonOrtho: 0,\n    badCells: []\n  };\n  \n  for (const cell of mesh.cells) {\n    const ar = aspectRatio(cell);\n    const sk = skewness(cell);\n    \n    report.maxAspectRatio = Math.max(report.maxAspectRatio, ar);\n    report.maxSkewness = Math.max(report.maxSkewness, sk);\n    \n    if (ar > 10 || sk > 0.9) {\n      report.badCells.push(cell.id);\n    }\n  }\n  return report;\n}"
  },
  {
    "id": 10,
    "question": "What is the Reynolds number and what flow regimes does it define?",
    "answer": "**Reynolds number (Re)** is the ratio of inertial forces to viscous forces, the most important dimensionless number in fluid mechanics.\n\n**Definition:**\n$$Re = \\frac{\\rho U L}{\\mu} = \\frac{U L}{\\nu}$$\n\n**Where:**\n- ρ = density\n- U = characteristic velocity\n- L = characteristic length\n- μ = dynamic viscosity\n- ν = kinematic viscosity\n\n**Flow regimes:**\n\n**Pipe flow:**\n- Re < 2300: Laminar\n- 2300 < Re < 4000: Transitional\n- Re > 4000: Turbulent\n\n**External flow (flat plate):**\n- Re_x < 5×10⁵: Laminar\n- Re_x > 5×10⁵: Turbulent\n\n**Physical interpretation:**\n- Low Re: Viscous forces dominate, smooth flow\n- High Re: Inertial forces dominate, turbulent\n\n**CFD implications:**\n- Low Re: Can use laminar solver\n- High Re: Need turbulence model\n- Grid requirements scale with Re\n- DNS cost: N ~ Re^(9/4)",
    "example": "// Reynolds number calculations\nfunction reynoldsNumber(rho, U, L, mu) {\n  return (rho * U * L) / mu;\n}\n\n// Kinematic viscosity version\nfunction reynoldsNumberKinematic(U, L, nu) {\n  return (U * L) / nu;\n}\n\n// Flow regime classifier\nfunction classifyPipeFlow(Re) {\n  if (Re < 2300) return 'Laminar';\n  if (Re < 4000) return 'Transitional';\n  return 'Turbulent';\n}\n\n// Examples for common fluids at 20°C\nconst fluids = {\n  water: { rho: 998, mu: 0.001, nu: 1.0e-6 },\n  air: { rho: 1.2, mu: 1.8e-5, nu: 1.5e-5 },\n  oil: { rho: 900, mu: 0.1, nu: 1.1e-4 }\n};\n\n// Calculate Re for pipe flow\nfunction pipeReynolds(fluid, velocity, diameter) {\n  return reynoldsNumber(\n    fluids[fluid].rho,\n    velocity,\n    diameter,\n    fluids[fluid].mu\n  );\n}\n\n// Example: Water at 1 m/s in 0.1m pipe\n// Re = 998 * 1 * 0.1 / 0.001 = 99,800 → Turbulent\n\n// Example: Oil at 0.1 m/s in 0.01m pipe\n// Re = 900 * 0.1 * 0.01 / 0.1 = 9 → Laminar (Stokes flow)"
  },
  {
    "id": 11,
    "question": "What is the difference between explicit and implicit time integration?",
    "answer": "**Explicit methods** compute the new time level using only known (current) values. **Implicit methods** require solving a system involving unknown (new) values.\n\n**Explicit (Forward Euler):**\n$$\\phi^{n+1} = \\phi^n + \\Delta t \\cdot f(\\phi^n)$$\n\n**Advantages:**\n- Simple implementation\n- No system of equations to solve\n- Easily parallelizable\n\n**Disadvantages:**\n- Conditionally stable (CFL ≤ 1)\n- Small time steps required\n\n**Implicit (Backward Euler):**\n$$\\phi^{n+1} = \\phi^n + \\Delta t \\cdot f(\\phi^{n+1})$$\n\n**Advantages:**\n- Unconditionally stable\n- Large time steps possible\n- Good for stiff problems\n\n**Disadvantages:**\n- Must solve system each step\n- More complex implementation\n- Higher cost per step\n\n**Crank-Nicolson (2nd order implicit):**\n$$\\phi^{n+1} = \\phi^n + \\frac{\\Delta t}{2}[f(\\phi^n) + f(\\phi^{n+1})]$$\n\n**Choice depends on:**\n- Problem stiffness\n- Accuracy requirements\n- Computational resources",
    "example": "// Time integration schemes for dφ/dt = f(φ)\n\n// Explicit Forward Euler - O(Δt), conditionally stable\nfunction forwardEuler(phi, f, dt) {\n  return phi + dt * f(phi);\n}\n\n// Explicit RK4 - O(Δt⁴), conditionally stable\nfunction rungeKutta4(phi, f, dt) {\n  const k1 = f(phi);\n  const k2 = f(phi + 0.5 * dt * k1);\n  const k3 = f(phi + 0.5 * dt * k2);\n  const k4 = f(phi + dt * k3);\n  return phi + (dt / 6) * (k1 + 2*k2 + 2*k3 + k4);\n}\n\n// Implicit Backward Euler - O(Δt), unconditionally stable\n// Requires solving: φ^(n+1) - dt*f(φ^(n+1)) = φ^n\nfunction backwardEuler(phi, f, df, dt, tol = 1e-8) {\n  // Newton iteration to solve implicit equation\n  let phiNew = phi; // Initial guess\n  for (let i = 0; i < 20; i++) {\n    const residual = phiNew - phi - dt * f(phiNew);\n    const jacobian = 1 - dt * df(phiNew);\n    const delta = residual / jacobian;\n    phiNew -= delta;\n    if (Math.abs(delta) < tol) break;\n  }\n  return phiNew;\n}\n\n// Crank-Nicolson - O(Δt²), unconditionally stable\nfunction crankNicolson(phi, f, df, dt, tol = 1e-8) {\n  let phiNew = phi;\n  const fn = f(phi);\n  for (let i = 0; i < 20; i++) {\n    const residual = phiNew - phi - 0.5*dt*(fn + f(phiNew));\n    const jacobian = 1 - 0.5*dt*df(phiNew);\n    phiNew -= residual / jacobian;\n  }\n  return phiNew;\n}"
  },
  {
    "id": 12,
    "question": "What is y+ and why is it important for wall-bounded flows?",
    "answer": "**y+ (y-plus)** is the dimensionless wall distance used to characterize the near-wall mesh resolution.\n\n**Definition:**\n$$y^+ = \\frac{y \\cdot u_\\tau}{\\nu} = \\frac{y \\cdot \\sqrt{\\tau_w/\\rho}}{\\nu}$$\n\n**Where:**\n- y = distance from wall\n- u_τ = friction velocity = √(τ_w/ρ)\n- τ_w = wall shear stress\n- ν = kinematic viscosity\n\n**Near-wall regions:**\n- y+ < 5: Viscous sublayer (linear profile)\n- 5 < y+ < 30: Buffer layer (transition)\n- 30 < y+ < 300: Log-law region\n- y+ > 300: Outer layer\n\n**Mesh requirements:**\n\n**Wall-resolved (low-Re models):**\n- First cell y+ ≈ 1\n- Resolves viscous sublayer\n- More accurate, more expensive\n\n**Wall functions (high-Re models):**\n- First cell y+ = 30-300\n- Uses empirical wall functions\n- Less accurate, cheaper\n\n**Importance:**\n- Wrong y+ = wrong wall shear stress\n- Affects drag, heat transfer predictions\n- Must match turbulence model requirements",
    "example": "// y+ estimation and first cell height calculation\n\n// Estimate friction velocity from Re\nfunction estimateFrictionVelocity(U, Re, L) {\n  // Using flat plate correlation: Cf ≈ 0.074 * Re^(-0.2)\n  const Cf = 0.074 * Math.pow(Re, -0.2);\n  const tauW = 0.5 * Cf * U * U; // Assuming rho = 1\n  return Math.sqrt(tauW);\n}\n\n// Calculate y+ from first cell height\nfunction calculateYPlus(y, uTau, nu) {\n  return (y * uTau) / nu;\n}\n\n// Calculate required first cell height for target y+\nfunction firstCellHeight(targetYPlus, uTau, nu) {\n  return (targetYPlus * nu) / uTau;\n}\n\n// Practical example\nfunction designBoundaryLayer(U, L, nu, targetYPlus = 1) {\n  const Re = (U * L) / nu;\n  const uTau = estimateFrictionVelocity(U, Re, L);\n  const y1 = firstCellHeight(targetYPlus, uTau, nu);\n  \n  console.log(`Re = ${Re.toExponential(2)}`);\n  console.log(`u_tau = ${uTau.toFixed(4)} m/s`);\n  console.log(`First cell height = ${(y1*1e6).toFixed(2)} μm`);\n  \n  return { Re, uTau, y1 };\n}\n\n// Example: Air at 10 m/s over 1m plate\n// designBoundaryLayer(10, 1, 1.5e-5, 1)\n// Re ≈ 6.7×10⁵, u_tau ≈ 0.4 m/s, y1 ≈ 37 μm"
  },
  {
    "id": 13,
    "question": "What is the k-ε turbulence model?",
    "answer": "**k-ε model** is the most widely used RANS turbulence model, solving two additional transport equations.\n\n**Transport equations:**\n\n**Turbulent kinetic energy (k):**\n$$\\frac{\\partial k}{\\partial t} + U_j\\frac{\\partial k}{\\partial x_j} = P_k - \\varepsilon + \\frac{\\partial}{\\partial x_j}\\left[\\left(\\nu + \\frac{\\nu_t}{\\sigma_k}\\right)\\frac{\\partial k}{\\partial x_j}\\right]$$\n\n**Dissipation rate (ε):**\n$$\\frac{\\partial \\varepsilon}{\\partial t} + U_j\\frac{\\partial \\varepsilon}{\\partial x_j} = C_{\\varepsilon 1}\\frac{\\varepsilon}{k}P_k - C_{\\varepsilon 2}\\frac{\\varepsilon^2}{k} + \\frac{\\partial}{\\partial x_j}\\left[\\left(\\nu + \\frac{\\nu_t}{\\sigma_\\varepsilon}\\right)\\frac{\\partial \\varepsilon}{\\partial x_j}\\right]$$\n\n**Turbulent viscosity:**\n$$\\nu_t = C_\\mu \\frac{k^2}{\\varepsilon}$$\n\n**Standard constants:**\nCμ=0.09, Cε1=1.44, Cε2=1.92, σk=1.0, σε=1.3\n\n**Strengths:**\n- Robust, well-validated\n- Good for free-shear flows\n\n**Weaknesses:**\n- Poor for separated flows\n- Requires wall functions or damping\n- Overpredicts spreading rates",
    "example": "// k-ε turbulence model implementation\nclass KepsilonModel {\n  constructor() {\n    // Standard model constants\n    this.Cmu = 0.09;\n    this.Ceps1 = 1.44;\n    this.Ceps2 = 1.92;\n    this.sigmaK = 1.0;\n    this.sigmaEps = 1.3;\n  }\n  \n  // Turbulent viscosity\n  nuT(k, epsilon) {\n    return this.Cmu * k * k / epsilon;\n  }\n  \n  // Production term\n  production(strainRate, nuT) {\n    // Pk = 2 * νt * Sij * Sij\n    return 2 * nuT * strainRate * strainRate;\n  }\n  \n  // k equation source terms\n  kSource(k, epsilon, Pk) {\n    return Pk - epsilon;  // Production - Dissipation\n  }\n  \n  // ε equation source terms\n  epsSource(k, epsilon, Pk) {\n    return (this.Ceps1 * Pk - this.Ceps2 * epsilon) * epsilon / k;\n  }\n  \n  // Solve one iteration\n  solve(mesh, U, k, epsilon, dt) {\n    for (const cell of mesh.cells) {\n      const S = this.strainRate(U, cell);\n      const nut = this.nuT(k[cell.id], epsilon[cell.id]);\n      const Pk = this.production(S, nut);\n      \n      // Update k and epsilon (simplified)\n      k[cell.id] += dt * this.kSource(k[cell.id], epsilon[cell.id], Pk);\n      epsilon[cell.id] += dt * this.epsSource(k[cell.id], epsilon[cell.id], Pk);\n      \n      // Ensure positivity\n      k[cell.id] = Math.max(k[cell.id], 1e-10);\n      epsilon[cell.id] = Math.max(epsilon[cell.id], 1e-10);\n    }\n  }\n}"
  },
  {
    "id": 14,
    "question": "What is numerical diffusion and how can it be minimized?",
    "answer": "**Numerical diffusion** (false diffusion) is artificial viscosity introduced by the discretization scheme, smearing gradients and reducing accuracy.\n\n**Causes:**\n- Low-order convection schemes (upwind)\n- Mesh not aligned with flow\n- Coarse mesh resolution\n- Time step effects\n\n**Mathematical origin:**\nTruncation error of upwind scheme:\n$$\\frac{\\partial \\phi}{\\partial t} + u\\frac{\\partial \\phi}{\\partial x} = \\frac{u\\Delta x}{2}\\frac{\\partial^2 \\phi}{\\partial x^2} + O(\\Delta x^2)$$\n\nThe RHS is artificial diffusion!\n\n**Minimization strategies:**\n\n**1. Higher-order schemes**\n- Use 2nd order or TVD schemes\n- QUICK, Van Leer, etc.\n\n**2. Mesh refinement**\n- Finer mesh in high-gradient regions\n- Adaptive mesh refinement (AMR)\n\n**3. Mesh alignment**\n- Align mesh with flow direction\n- Reduces cross-diffusion\n\n**4. Smaller time steps**\n- Reduces temporal diffusion\n\n**Quantification:**\n- Compare with analytical solutions\n- Grid convergence studies",
    "example": "// Demonstrating numerical diffusion\n\n// 1D convection equation: ∂φ/∂t + u∂φ/∂x = 0\n// Analytical: Step function stays sharp\n// Numerical: Step smears out over time\n\nfunction simulateConvection(nx, nt, scheme = 'upwind') {\n  const dx = 1.0 / nx;\n  const u = 1.0;\n  const dt = 0.5 * dx / u; // CFL = 0.5\n  \n  // Initial step function\n  let phi = new Array(nx).fill(0);\n  for (let i = 0; i < nx/4; i++) phi[i] = 1.0;\n  \n  for (let n = 0; n < nt; n++) {\n    const phiNew = [...phi];\n    \n    for (let i = 1; i < nx - 1; i++) {\n      let flux;\n      if (scheme === 'upwind') {\n        // First-order upwind - most diffusive\n        flux = u * phi[i-1];\n      } else if (scheme === 'central') {\n        // Central - no diffusion but oscillates\n        flux = u * 0.5 * (phi[i-1] + phi[i]);\n      } else if (scheme === 'laxWendroff') {\n        // Lax-Wendroff - 2nd order, less diffusion\n        const cfl = u * dt / dx;\n        flux = u * (phi[i-1] + 0.5*(1-cfl)*(phi[i]-phi[i-1]));\n      }\n      \n      phiNew[i] = phi[i] - (dt/dx) * (u*phi[i] - flux);\n    }\n    phi = phiNew;\n  }\n  \n  return phi;\n}\n\n// Compare results:\n// Upwind: Step smears significantly\n// Lax-Wendroff: Much sharper, but may have small oscillations\n// Finer mesh (higher nx): Less diffusion for all schemes"
  },
  {
    "id": 15,
    "question": "What is the Finite Difference Method (FDM)?",
    "answer": "**Finite Difference Method (FDM)** approximates derivatives using differences between neighboring grid point values.\n\n**Basic approximations:**\n\n**First derivative:**\n- Forward: (φᵢ₊₁ - φᵢ)/Δx + O(Δx)\n- Backward: (φᵢ - φᵢ₋₁)/Δx + O(Δx)\n- Central: (φᵢ₊₁ - φᵢ₋₁)/(2Δx) + O(Δx²)\n\n**Second derivative:**\n- Central: (φᵢ₊₁ - 2φᵢ + φᵢ₋₁)/Δx² + O(Δx²)\n\n**Derivation:**\nTaylor series expansion:\nφᵢ₊₁ = φᵢ + Δx·φ' + (Δx²/2)·φ'' + ...\n\n**Advantages:**\n- Simple to implement\n- Easy to derive higher-order schemes\n- Efficient on structured grids\n\n**Disadvantages:**\n- Limited to structured meshes\n- Not inherently conservative\n- Difficult for complex geometries\n\n**Applications:**\n- Simple geometries\n- DNS/LES (often spectral methods)\n- Weather prediction\n- Academic/teaching",
    "example": "// Finite difference approximations\n\n// First derivatives\nfunction forwardDiff(phi, i, dx) {\n  return (phi[i+1] - phi[i]) / dx;  // O(dx)\n}\n\nfunction backwardDiff(phi, i, dx) {\n  return (phi[i] - phi[i-1]) / dx;  // O(dx)\n}\n\nfunction centralDiff1(phi, i, dx) {\n  return (phi[i+1] - phi[i-1]) / (2*dx);  // O(dx²)\n}\n\n// Second derivative\nfunction centralDiff2(phi, i, dx) {\n  return (phi[i+1] - 2*phi[i] + phi[i-1]) / (dx*dx);  // O(dx²)\n}\n\n// Higher-order first derivative (4th order)\nfunction centralDiff1_4thOrder(phi, i, dx) {\n  return (-phi[i+2] + 8*phi[i+1] - 8*phi[i-1] + phi[i-2]) / (12*dx);\n}\n\n// Solve 1D heat equation: ∂T/∂t = α∂²T/∂x²\nfunction solveHeatEquation(T, alpha, dx, dt, nt) {\n  const nx = T.length;\n  const r = alpha * dt / (dx * dx); // Stability: r ≤ 0.5\n  \n  for (let n = 0; n < nt; n++) {\n    const Tnew = [...T];\n    for (let i = 1; i < nx - 1; i++) {\n      // FTCS (Forward Time, Central Space)\n      Tnew[i] = T[i] + r * (T[i+1] - 2*T[i] + T[i-1]);\n    }\n    T = Tnew;\n  }\n  return T;\n}"
  },
  {
    "id": 16,
    "question": "What is the continuity equation and why must it be satisfied?",
    "answer": "**Continuity equation** expresses conservation of mass - mass cannot be created or destroyed.\n\n**General form:**\n$$\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0$$\n\n**Incompressible flow (ρ = constant):**\n$$\\nabla \\cdot \\mathbf{u} = 0$$\n$$\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} + \\frac{\\partial w}{\\partial z} = 0$$\n\n**Physical meaning:**\n- Fluid entering a region must equal fluid leaving\n- No sources or sinks of mass\n- Divergence-free velocity field\n\n**Why it must be satisfied:**\n- Fundamental conservation law\n- Violating it creates/destroys mass\n- Links pressure and velocity fields\n- Basis for pressure equation derivation\n\n**Numerical enforcement:**\n- SIMPLE and variants\n- Projection methods\n- Pressure Poisson equation\n- Must be satisfied at each time step\n\n**Consequences of violation:**\n- Unphysical pressure oscillations\n- Solution divergence\n- Incorrect flow rates",
    "example": "// Continuity equation verification\n\n// Check divergence of velocity field\nfunction checkContinuity(mesh, u, v, w) {\n  let maxDiv = 0;\n  let totalDiv = 0;\n  \n  for (const cell of mesh.cells) {\n    // Compute divergence using finite volume\n    let divergence = 0;\n    \n    for (const face of cell.faces) {\n      const vel = interpolateToFace(u, v, w, face);\n      const flux = dotProduct(vel, face.normal) * face.area;\n      divergence += flux;\n    }\n    divergence /= cell.volume;\n    \n    maxDiv = Math.max(maxDiv, Math.abs(divergence));\n    totalDiv += Math.abs(divergence) * cell.volume;\n  }\n  \n  return {\n    maxDivergence: maxDiv,\n    totalMassImbalance: totalDiv\n  };\n}\n\n// Projection method to enforce continuity\nfunction projectVelocity(u, v, p, dx, dy, dt, rho) {\n  // Solve pressure Poisson: ∇²p = (ρ/dt)∇·u*\n  // Then correct: u = u* - (dt/ρ)∇p\n  \n  // After projection, ∇·u should be ~0\n  const uCorrected = u.map((ui, i) => \n    ui - (dt/rho) * (p[i+1] - p[i-1]) / (2*dx)\n  );\n  \n  return uCorrected;\n}\n\n// Mass conservation check at boundaries\nfunction checkMassBalance(mesh, boundaryConditions) {\n  let massIn = 0, massOut = 0;\n  \n  for (const bc of boundaryConditions) {\n    const flux = bc.computeMassFlux();\n    if (flux > 0) massIn += flux;\n    else massOut += Math.abs(flux);\n  }\n  \n  const imbalance = Math.abs(massIn - massOut) / massIn;\n  console.log(`Mass balance error: ${(imbalance*100).toFixed(4)}%`);\n  return imbalance;\n}"
  },
  {
    "id": 17,
    "question": "What is the Mach number and how does it affect CFD simulations?",
    "answer": "**Mach number (Ma)** is the ratio of flow velocity to the speed of sound.\n\n$$Ma = \\frac{U}{a} = \\frac{U}{\\sqrt{\\gamma R T}}$$\n\n**Flow regimes:**\n- Ma < 0.3: Incompressible\n- 0.3 < Ma < 0.8: Subsonic compressible\n- 0.8 < Ma < 1.2: Transonic\n- 1.2 < Ma < 5: Supersonic\n- Ma > 5: Hypersonic\n\n**CFD implications:**\n\n**Incompressible (Ma < 0.3):**\n- Density constant, ρ = const\n- Pressure-velocity coupling (SIMPLE)\n- Simpler equations\n\n**Compressible (Ma > 0.3):**\n- Density varies with pressure\n- Energy equation coupled\n- Density-based or pressure-based solvers\n- Shock waves possible (Ma > 1)\n\n**Numerical challenges:**\n- Transonic: Mixed subsonic/supersonic\n- Shocks: Discontinuities need special treatment\n- Hypersonic: Real gas effects, chemistry\n\n**Density change:**\n$$\\frac{\\Delta \\rho}{\\rho} \\approx Ma^2$$\nAt Ma = 0.3: ~9% density variation",
    "example": "// Mach number calculations\n\nfunction machNumber(velocity, temperature, gamma = 1.4, R = 287) {\n  const speedOfSound = Math.sqrt(gamma * R * temperature);\n  return velocity / speedOfSound;\n}\n\nfunction speedOfSound(temperature, gamma = 1.4, R = 287) {\n  return Math.sqrt(gamma * R * temperature);\n}\n\n// Flow regime classification\nfunction flowRegime(Ma) {\n  if (Ma < 0.3) return 'Incompressible';\n  if (Ma < 0.8) return 'Subsonic';\n  if (Ma < 1.2) return 'Transonic';\n  if (Ma < 5.0) return 'Supersonic';\n  return 'Hypersonic';\n}\n\n// Isentropic relations\nfunction isentropicRelations(Ma, gamma = 1.4) {\n  const g = gamma;\n  const M2 = Ma * Ma;\n  \n  return {\n    // Temperature ratio T/T0\n    tempRatio: 1 / (1 + (g-1)/2 * M2),\n    // Pressure ratio p/p0\n    pressRatio: Math.pow(1 + (g-1)/2 * M2, -g/(g-1)),\n    // Density ratio ρ/ρ0\n    densRatio: Math.pow(1 + (g-1)/2 * M2, -1/(g-1))\n  };\n}\n\n// Normal shock relations\nfunction normalShockRelations(Ma1, gamma = 1.4) {\n  const g = gamma;\n  const M1sq = Ma1 * Ma1;\n  \n  // Downstream Mach number\n  const M2sq = (M1sq + 2/(g-1)) / (2*g/(g-1)*M1sq - 1);\n  \n  return {\n    Ma2: Math.sqrt(M2sq),\n    pressRatio: 1 + 2*g/(g+1) * (M1sq - 1),\n    densRatio: ((g+1)*M1sq) / ((g-1)*M1sq + 2),\n    tempRatio: (1 + 2*g/(g+1)*(M1sq-1)) * (2+(g-1)*M1sq) / ((g+1)*M1sq)\n  };\n}"
  },
  {
    "id": 18,
    "question": "What is grid convergence and how do you perform a grid independence study?",
    "answer": "**Grid convergence** demonstrates that the numerical solution becomes independent of mesh resolution as the mesh is refined.\n\n**Why it matters:**\n- Proves solution is not mesh-dependent\n- Estimates discretization error\n- Validates numerical accuracy\n- Required for credible CFD results\n\n**Grid independence study:**\n\n**1. Create multiple meshes**\n- Minimum 3 meshes (coarse, medium, fine)\n- Uniform refinement ratio r (typically 1.3-2.0)\n- r = h_coarse / h_fine\n\n**2. Run simulations**\n- Same boundary conditions\n- Same models and schemes\n- Converged solutions\n\n**3. Analyze results**\n- Plot key quantities vs mesh size\n- Look for asymptotic behavior\n- Quantify differences between meshes\n\n**Richardson extrapolation:**\n$$\\phi_{exact} \\approx \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r^p - 1}$$\n\n**Grid Convergence Index (GCI):**\n$$GCI = \\frac{F_s |\\epsilon|}{r^p - 1}$$\nFs = safety factor (1.25-3.0)\nε = relative error between grids",
    "example": "// Grid convergence study implementation\n\nclass GridConvergenceStudy {\n  constructor(results) {\n    // results = [{meshSize, value}, ...] ordered coarse to fine\n    this.results = results.sort((a, b) => b.meshSize - a.meshSize);\n  }\n  \n  // Compute refinement ratio\n  refinementRatio(i) {\n    return this.results[i].meshSize / this.results[i+1].meshSize;\n  }\n  \n  // Estimate order of convergence\n  estimateOrder() {\n    const phi1 = this.results[2].value; // finest\n    const phi2 = this.results[1].value;\n    const phi3 = this.results[0].value; // coarsest\n    const r21 = this.refinementRatio(1);\n    const r32 = this.refinementRatio(0);\n    \n    // Iteratively solve for p\n    let p = 2.0;\n    for (let i = 0; i < 20; i++) {\n      const eps32 = phi3 - phi2;\n      const eps21 = phi2 - phi1;\n      p = Math.log(eps32/eps21) / Math.log(r32);\n    }\n    return p;\n  }\n  \n  // Richardson extrapolation\n  extrapolate() {\n    const phi1 = this.results[2].value;\n    const phi2 = this.results[1].value;\n    const r = this.refinementRatio(1);\n    const p = this.estimateOrder();\n    \n    return phi1 + (phi1 - phi2) / (Math.pow(r, p) - 1);\n  }\n  \n  // Grid Convergence Index\n  computeGCI(safetyFactor = 1.25) {\n    const phi1 = this.results[2].value;\n    const phi2 = this.results[1].value;\n    const r = this.refinementRatio(1);\n    const p = this.estimateOrder();\n    \n    const epsilon = Math.abs((phi1 - phi2) / phi1);\n    return safetyFactor * epsilon / (Math.pow(r, p) - 1);\n  }\n  \n  report() {\n    console.log('Grid Convergence Study Results:');\n    console.log(`Order of convergence: ${this.estimateOrder().toFixed(2)}`);\n    console.log(`Extrapolated value: ${this.extrapolate().toFixed(6)}`);\n    console.log(`GCI (fine): ${(this.computeGCI()*100).toFixed(2)}%`);\n  }\n}"
  },
  {
    "id": 19,
    "question": "What is the k-ω SST turbulence model?",
    "answer": "**k-ω SST (Shear Stress Transport)** is a hybrid turbulence model combining k-ω near walls and k-ε in the free stream.\n\n**Developed by Menter (1994)** to address weaknesses of both models.\n\n**Key features:**\n\n**1. Blending function F1**\n- F1 = 1 near wall → k-ω behavior\n- F1 = 0 far from wall → k-ε behavior\n\n**2. Shear stress limiter**\n- Limits turbulent viscosity in adverse pressure gradients\n- Improves separation prediction\n$$\\nu_t = \\frac{a_1 k}{\\max(a_1\\omega, SF_2)}$$\n\n**Advantages over standard models:**\n- Better separation prediction than k-ε\n- Less freestream sensitivity than k-ω\n- Accurate boundary layer behavior\n- Good for aerodynamic flows\n\n**Recommended for:**\n- External aerodynamics\n- Turbomachinery\n- Separated flows\n- Adverse pressure gradients\n\n**Mesh requirements:**\n- Can use wall functions OR\n- Low-Re: y+ ≈ 1",
    "example": "// k-ω SST model implementation\nclass KOmegaSST {\n  constructor() {\n    // Model constants\n    this.a1 = 0.31;\n    this.betaStar = 0.09;\n    \n    // k-ω constants (set 1)\n    this.sigma_k1 = 0.85;\n    this.sigma_w1 = 0.5;\n    this.beta1 = 0.075;\n    this.gamma1 = 5/9;\n    \n    // k-ε constants (set 2)\n    this.sigma_k2 = 1.0;\n    this.sigma_w2 = 0.856;\n    this.beta2 = 0.0828;\n    this.gamma2 = 0.44;\n  }\n  \n  // Blending function F1\n  F1(k, omega, y, nu) {\n    const CDkw = Math.max(2*this.sigma_w2/omega * this.gradK_gradW, 1e-10);\n    \n    const arg1 = Math.min(\n      Math.max(\n        Math.sqrt(k) / (this.betaStar * omega * y),\n        500 * nu / (y*y * omega)\n      ),\n      4 * this.sigma_w2 * k / (CDkw * y*y)\n    );\n    \n    return Math.tanh(Math.pow(arg1, 4));\n  }\n  \n  // Blending function F2 (for eddy viscosity limiter)\n  F2(k, omega, y, nu) {\n    const arg2 = Math.max(\n      2 * Math.sqrt(k) / (this.betaStar * omega * y),\n      500 * nu / (y*y * omega)\n    );\n    return Math.tanh(arg2 * arg2);\n  }\n  \n  // Blended constants\n  blend(phi1, phi2, F1) {\n    return F1 * phi1 + (1 - F1) * phi2;\n  }\n  \n  // Turbulent viscosity with limiter\n  nuT(k, omega, S, F2) {\n    return this.a1 * k / Math.max(this.a1 * omega, S * F2);\n  }\n}"
  },
  {
    "id": 20,
    "question": "What are linear solvers and which ones are used in CFD?",
    "answer": "**Linear solvers** solve systems of equations Ax = b that arise from discretization.\n\n**Direct methods:**\n- Gaussian elimination, LU decomposition\n- Exact solution (to machine precision)\n- O(n³) complexity\n- Impractical for large CFD problems\n\n**Iterative methods:**\n\n**1. Jacobi**\n- Simple, highly parallelizable\n- Slow convergence\n\n**2. Gauss-Seidel**\n- Uses updated values immediately\n- Faster than Jacobi\n\n**3. SOR (Successive Over-Relaxation)**\n- Accelerated Gauss-Seidel\n- ω parameter controls relaxation\n\n**4. Conjugate Gradient (CG)**\n- For symmetric positive definite\n- Krylov subspace method\n\n**5. GMRES**\n- General matrices\n- Robust but memory intensive\n\n**6. BiCGSTAB**\n- Non-symmetric systems\n- Less memory than GMRES\n\n**Preconditioning:**\n- Transforms system for faster convergence\n- ILU, Jacobi, multigrid\n- Critical for performance",
    "example": "// Iterative linear solvers\n\n// Jacobi iteration\nfunction jacobi(A, b, x0, tol = 1e-6, maxIter = 1000) {\n  const n = b.length;\n  let x = [...x0];\n  \n  for (let iter = 0; iter < maxIter; iter++) {\n    const xNew = new Array(n);\n    \n    for (let i = 0; i < n; i++) {\n      let sum = b[i];\n      for (let j = 0; j < n; j++) {\n        if (j !== i) sum -= A[i][j] * x[j];\n      }\n      xNew[i] = sum / A[i][i];\n    }\n    \n    // Check convergence\n    const residual = norm(subtract(xNew, x));\n    if (residual < tol) return { x: xNew, iterations: iter };\n    x = xNew;\n  }\n  throw new Error('Jacobi did not converge');\n}\n\n// Gauss-Seidel iteration\nfunction gaussSeidel(A, b, x0, tol = 1e-6, maxIter = 1000) {\n  const n = b.length;\n  let x = [...x0];\n  \n  for (let iter = 0; iter < maxIter; iter++) {\n    const xOld = [...x];\n    \n    for (let i = 0; i < n; i++) {\n      let sum = b[i];\n      for (let j = 0; j < i; j++) sum -= A[i][j] * x[j];      // Updated values\n      for (let j = i+1; j < n; j++) sum -= A[i][j] * x[j];    // Old values\n      x[i] = sum / A[i][i];\n    }\n    \n    if (norm(subtract(x, xOld)) < tol) return { x, iterations: iter };\n  }\n  throw new Error('Gauss-Seidel did not converge');\n}\n\n// Conjugate Gradient (for symmetric positive definite)\nfunction conjugateGradient(A, b, x0, tol = 1e-6, maxIter = 1000) {\n  let x = [...x0];\n  let r = subtract(b, matVec(A, x));  // Residual\n  let p = [...r];                      // Search direction\n  let rsOld = dot(r, r);\n  \n  for (let iter = 0; iter < maxIter; iter++) {\n    const Ap = matVec(A, p);\n    const alpha = rsOld / dot(p, Ap);\n    \n    x = x.map((xi, i) => xi + alpha * p[i]);\n    r = r.map((ri, i) => ri - alpha * Ap[i]);\n    \n    const rsNew = dot(r, r);\n    if (Math.sqrt(rsNew) < tol) return { x, iterations: iter };\n    \n    p = r.map((ri, i) => ri + (rsNew/rsOld) * p[i]);\n    rsOld = rsNew;\n  }\n}"
  },
  {
    "id": 21,
    "question": "What is the Finite Element Method (FEM) in CFD?",
    "answer": "**Finite Element Method (FEM)** approximates solutions using piecewise polynomial basis functions over elements.\n\n**Key concepts:**\n\n**1. Weak formulation**\n- Multiply PDE by test function\n- Integrate by parts\n- Reduces derivative order\n\n**2. Discretization**\n- Divide domain into elements\n- Approximate solution: φ ≈ Σ φᵢNᵢ(x)\n- Nᵢ = shape/basis functions\n\n**3. Galerkin method**\n- Test functions = basis functions\n- Results in symmetric matrices\n\n**Element types:**\n- Triangles/tetrahedra (linear, quadratic)\n- Quadrilaterals/hexahedra\n- Higher-order (spectral elements)\n\n**Advantages:**\n- Handles complex geometries\n- Natural treatment of BCs\n- Mathematical framework (error bounds)\n- Higher-order accuracy possible\n\n**Challenges in CFD:**\n- Not inherently conservative\n- Convection-dominated problems oscillate\n- Stabilization needed (SUPG, GLS)\n\n**Applications:**\n- Structural mechanics (primary)\n- Multiphysics (FSI)\n- Low-Re flows",
    "example": "// Finite Element Method for 1D diffusion\n// -d/dx(k dT/dx) = f\n\nclass FEMSolver1D {\n  constructor(nodes, elements) {\n    this.nodes = nodes;       // x coordinates\n    this.elements = elements; // [[node1, node2], ...]\n    this.n = nodes.length;\n  }\n  \n  // Linear shape functions for 1D element\n  shapeFunctions(xi) {\n    // xi in [-1, 1] (reference element)\n    return {\n      N: [(1-xi)/2, (1+xi)/2],\n      dN: [-0.5, 0.5]  // derivatives\n    };\n  }\n  \n  // Element stiffness matrix\n  elementStiffness(e, k) {\n    const [n1, n2] = this.elements[e];\n    const h = this.nodes[n2] - this.nodes[n1]; // element length\n    const J = h / 2; // Jacobian\n    \n    // Ke = ∫ k * dN/dx * dN/dx dx\n    // For linear elements: Ke = k/h * [[1, -1], [-1, 1]]\n    return [\n      [k/h, -k/h],\n      [-k/h, k/h]\n    ];\n  }\n  \n  // Assemble global stiffness matrix\n  assembleGlobal(k) {\n    const K = Array(this.n).fill(null).map(() => Array(this.n).fill(0));\n    \n    for (let e = 0; e < this.elements.length; e++) {\n      const Ke = this.elementStiffness(e, k);\n      const [n1, n2] = this.elements[e];\n      \n      // Add element contribution to global matrix\n      K[n1][n1] += Ke[0][0];\n      K[n1][n2] += Ke[0][1];\n      K[n2][n1] += Ke[1][0];\n      K[n2][n2] += Ke[1][1];\n    }\n    return K;\n  }\n  \n  // Apply Dirichlet BC\n  applyBC(K, F, nodeId, value) {\n    // Zero row and column, set diagonal to 1\n    for (let j = 0; j < this.n; j++) {\n      K[nodeId][j] = 0;\n      K[j][nodeId] = 0;\n    }\n    K[nodeId][nodeId] = 1;\n    F[nodeId] = value;\n  }\n}"
  },
  {
    "id": 22,
    "question": "What is under-relaxation and why is it needed?",
    "answer": "**Under-relaxation** limits the change in variables between iterations to improve stability and convergence.\n\n**Formula:**\n$$\\phi^{new} = \\phi^{old} + \\alpha(\\phi^{computed} - \\phi^{old})$$\n\n**Where:**\n- α = under-relaxation factor (0 < α ≤ 1)\n- α = 1: No relaxation (full update)\n- α < 1: Under-relaxation (partial update)\n\n**Why needed:**\n- Nonlinear coupling between equations\n- Prevents divergence during iteration\n- Damps oscillations\n- Compensates for linearization errors\n\n**Typical values:**\n- Pressure: 0.3 (most sensitive)\n- Momentum: 0.7\n- Energy: 0.8-1.0\n- Turbulence (k, ε, ω): 0.5-0.8\n\n**Effects:**\n- Too low: Very slow convergence\n- Too high: Divergence, oscillations\n- Optimal: Problem-dependent\n\n**When to adjust:**\n- Divergence → decrease α\n- Slow convergence → increase α carefully\n- Start conservative, increase as solution develops",
    "example": "// Under-relaxation implementation\n\nclass RelaxedSolver {\n  constructor() {\n    // Relaxation factors\n    this.alphaP = 0.3;   // Pressure\n    this.alphaU = 0.7;   // Velocity\n    this.alphaK = 0.5;   // Turbulent KE\n    this.alphaE = 0.5;   // Dissipation\n  }\n  \n  // Apply under-relaxation\n  relax(oldValue, computedValue, alpha) {\n    return oldValue + alpha * (computedValue - oldValue);\n  }\n  \n  // Relax entire field\n  relaxField(oldField, computedField, alpha) {\n    return oldField.map((old, i) => \n      this.relax(old, computedField[i], alpha)\n    );\n  }\n  \n  // SIMPLE iteration with relaxation\n  simpleIteration(mesh, pOld, uOld, vOld) {\n    // Solve momentum (implicitly under-relaxed)\n    const uStar = this.solveMomentumRelaxed(mesh, pOld, uOld, this.alphaU);\n    const vStar = this.solveMomentumRelaxed(mesh, pOld, vOld, this.alphaU);\n    \n    // Solve pressure correction\n    const pPrime = this.solvePressureCorrection(mesh, uStar, vStar);\n    \n    // Correct and relax pressure\n    const pComputed = pOld.map((p, i) => p + pPrime[i]);\n    const pNew = this.relaxField(pOld, pComputed, this.alphaP);\n    \n    // Correct velocities (no additional relaxation needed)\n    const uNew = this.correctVelocity(uStar, pPrime, 'x');\n    const vNew = this.correctVelocity(vStar, pPrime, 'y');\n    \n    return { p: pNew, u: uNew, v: vNew };\n  }\n  \n  // Adaptive relaxation based on residuals\n  adaptRelaxation(residualHistory) {\n    const n = residualHistory.length;\n    if (n < 3) return;\n    \n    const ratio = residualHistory[n-1] / residualHistory[n-2];\n    \n    if (ratio > 1.1) {\n      // Diverging - decrease relaxation\n      this.alphaP *= 0.9;\n      this.alphaU *= 0.95;\n    } else if (ratio < 0.8 && this.alphaP < 0.7) {\n      // Converging well - can increase\n      this.alphaP = Math.min(0.7, this.alphaP * 1.05);\n    }\n  }\n}"
  },
  {
    "id": 23,
    "question": "What is the Boussinesq approximation for buoyancy-driven flows?",
    "answer": "**Boussinesq approximation** simplifies buoyancy effects by treating density as constant except in the gravity term.\n\n**Assumptions:**\n1. Density variations are small: Δρ/ρ << 1\n2. Density only varies with temperature\n3. Other fluid properties constant\n\n**Momentum equation:**\n$$\\rho_0\\frac{D\\mathbf{u}}{Dt} = -\\nabla p + \\mu\\nabla^2\\mathbf{u} + \\rho_0\\beta(T-T_0)\\mathbf{g}$$\n\n**Where:**\n- ρ₀ = reference density\n- β = thermal expansion coefficient\n- β = -1/ρ (∂ρ/∂T)_p\n- T₀ = reference temperature\n\n**Buoyancy term:**\n$$\\mathbf{F}_b = \\rho_0\\beta(T-T_0)\\mathbf{g}$$\n\n**Validity:**\n- βΔT << 1 (typically ΔT < 30°C for air)\n- Low Mach number\n- No phase change\n\n**Applications:**\n- Natural convection\n- HVAC simulations\n- Room ventilation\n- Atmospheric boundary layer",
    "example": "// Boussinesq buoyancy implementation\n\nclass BoussinesqSolver {\n  constructor(config) {\n    this.rho0 = config.rho0 || 1.225;  // Reference density (kg/m³)\n    this.T0 = config.T0 || 293;        // Reference temperature (K)\n    this.beta = config.beta || 3.4e-3; // Thermal expansion (1/K)\n    this.g = config.g || [0, -9.81, 0]; // Gravity vector\n  }\n  \n  // Compute buoyancy force per unit volume\n  buoyancyForce(T) {\n    const factor = this.rho0 * this.beta * (T - this.T0);\n    return this.g.map(gi => factor * gi);\n  }\n  \n  // Add buoyancy to momentum equation\n  addBuoyancySource(mesh, temperature, momentumRHS) {\n    for (const cell of mesh.cells) {\n      const Fb = this.buoyancyForce(temperature[cell.id]);\n      \n      // Add to momentum source term\n      momentumRHS.u[cell.id] += Fb[0] * cell.volume;\n      momentumRHS.v[cell.id] += Fb[1] * cell.volume;\n      momentumRHS.w[cell.id] += Fb[2] * cell.volume;\n    }\n  }\n  \n  // Check Boussinesq validity\n  checkValidity(Tmin, Tmax) {\n    const deltaT = Tmax - Tmin;\n    const betaDeltaT = this.beta * deltaT;\n    \n    if (betaDeltaT > 0.1) {\n      console.warn(`βΔT = ${betaDeltaT.toFixed(3)} > 0.1`);\n      console.warn('Boussinesq approximation may not be valid');\n      console.warn('Consider using variable density formulation');\n    }\n    return betaDeltaT < 0.1;\n  }\n}\n\n// Rayleigh number for natural convection\nfunction rayleighNumber(g, beta, deltaT, L, nu, alpha) {\n  // Ra = g*β*ΔT*L³ / (ν*α)\n  return (g * beta * deltaT * Math.pow(L, 3)) / (nu * alpha);\n}\n\n// Convection regime\n// Ra < 10⁸: Laminar natural convection\n// Ra > 10⁹: Turbulent natural convection"
  },
  {
    "id": 24,
    "question": "What is the pressure Poisson equation and how is it derived?",
    "answer": "**Pressure Poisson equation** is derived from continuity and momentum to solve for pressure in incompressible flows.\n\n**Derivation:**\n\n**1. Start with momentum:**\n$$\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\frac{1}{\\rho}\\nabla p + \\nu\\nabla^2\\mathbf{u}$$\n\n**2. Take divergence:**\n$$\\nabla \\cdot \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla^2 p + ...$$\n\n**3. Apply continuity (∇·u = 0):**\n$$\\nabla^2 p = \\rho \\nabla \\cdot [(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}]$$\n\n**In projection methods:**\n$$\\nabla^2 p = \\frac{\\rho}{\\Delta t}\\nabla \\cdot \\mathbf{u}^*$$\n\nwhere u* is the intermediate velocity.\n\n**Properties:**\n- Elliptic equation\n- Requires BCs on entire boundary\n- Computationally expensive part of incompressible solver\n- Ensures divergence-free velocity\n\n**Boundary conditions:**\n- Walls: ∂p/∂n derived from momentum\n- Inlet/Outlet: Specified or zero gradient",
    "example": "// Pressure Poisson equation solver\n\nclass PressurePoissonSolver {\n  constructor(mesh, rho, dt) {\n    this.mesh = mesh;\n    this.rho = rho;\n    this.dt = dt;\n  }\n  \n  // Compute RHS: (ρ/Δt) * ∇·u*\n  computeRHS(uStar, vStar, wStar) {\n    const rhs = [];\n    \n    for (const cell of this.mesh.cells) {\n      let divergence = 0;\n      \n      // Compute divergence using face fluxes\n      for (const face of cell.faces) {\n        const uFace = this.interpolateToFace(uStar, face);\n        const vFace = this.interpolateToFace(vStar, face);\n        const wFace = this.interpolateToFace(wStar, face);\n        \n        const flux = uFace * face.normal.x + \n                     vFace * face.normal.y + \n                     wFace * face.normal.z;\n        divergence += flux * face.area;\n      }\n      \n      rhs[cell.id] = (this.rho / this.dt) * divergence / cell.volume;\n    }\n    return rhs;\n  }\n  \n  // Solve ∇²p = rhs using finite volume\n  solve(rhs, tolerance = 1e-6) {\n    // Build coefficient matrix (Laplacian)\n    const { A, b } = this.assemblePoissonSystem(rhs);\n    \n    // Solve using iterative method (CG or multigrid)\n    const p = this.conjugateGradient(A, b, tolerance);\n    \n    return p;\n  }\n  \n  // Correct velocity to be divergence-free\n  correctVelocity(uStar, vStar, wStar, p) {\n    const u = [], v = [], w = [];\n    \n    for (const cell of this.mesh.cells) {\n      const gradP = this.computeGradient(p, cell);\n      \n      u[cell.id] = uStar[cell.id] - (this.dt / this.rho) * gradP.x;\n      v[cell.id] = vStar[cell.id] - (this.dt / this.rho) * gradP.y;\n      w[cell.id] = wStar[cell.id] - (this.dt / this.rho) * gradP.z;\n    }\n    \n    return { u, v, w };\n  }\n}"
  },
  {
    "id": 25,
    "question": "What is wall treatment in turbulence modeling?",
    "answer": "**Wall treatment** handles the transition from turbulent bulk flow to the viscous-dominated near-wall region.\n\n**Near-wall behavior:**\n- Viscous sublayer (y+ < 5): u+ = y+\n- Buffer layer (5 < y+ < 30): Transition\n- Log-law region (y+ > 30): u+ = (1/κ)ln(y+) + B\n\n**Two approaches:**\n\n**1. Wall Functions (High-Re)**\n- First cell in log-law region (y+ = 30-300)\n- Bridge viscous sublayer with empirical formulas\n- Faster, less accurate\n- τw from log-law\n\n**2. Low-Re / Wall-Resolved**\n- First cell y+ ≈ 1\n- Resolve viscous sublayer directly\n- More accurate, more expensive\n- Requires modified turbulence models\n\n**Enhanced Wall Treatment:**\n- Blends wall functions and low-Re\n- Works for any y+\n- Default in many modern codes\n\n**Choosing approach:**\n- Attached boundary layers: Wall functions OK\n- Separation, heat transfer: Wall-resolved better\n- Complex geometry: Enhanced/automatic",
    "example": "// Wall treatment implementations\n\nclass WallTreatment {\n  constructor() {\n    this.kappa = 0.41;  // von Karman constant\n    this.E = 9.8;       // Wall function constant\n    this.B = 5.5;       // Log-law constant\n  }\n  \n  // Standard wall function (log-law)\n  wallFunction(yP, UP, nu, kP) {\n    // Iteratively solve for uTau\n    let uTau = Math.sqrt(kP) * Math.pow(0.09, 0.25); // Initial guess\n    \n    for (let i = 0; i < 20; i++) {\n      const yPlus = yP * uTau / nu;\n      const uPlus = UP / uTau;\n      \n      // Log-law: u+ = (1/κ)ln(E*y+)\n      const uPlusCalc = Math.log(this.E * yPlus) / this.kappa;\n      \n      // Update uTau\n      uTau = UP / uPlusCalc;\n    }\n    \n    const yPlus = yP * uTau / nu;\n    const tauWall = uTau * uTau; // τw/ρ\n    \n    return { uTau, yPlus, tauWall };\n  }\n  \n  // Spalding's law (all y+ wall treatment)\n  spaldingLaw(yPlus) {\n    // u+ = y+ + (1/E)[exp(κu+) - 1 - κu+ - (κu+)²/2 - (κu+)³/6]\n    // Implicit, need to solve iteratively\n    let uPlus = yPlus; // Initial guess for low y+\n    \n    for (let i = 0; i < 20; i++) {\n      const kU = this.kappa * uPlus;\n      const expTerm = Math.exp(kU) - 1 - kU - kU*kU/2 - kU*kU*kU/6;\n      const f = uPlus + expTerm/this.E - yPlus;\n      const df = 1 + (Math.exp(kU) - 1 - kU - kU*kU/2) * this.kappa / this.E;\n      uPlus -= f / df;\n    }\n    return uPlus;\n  }\n  \n  // Blended wall treatment\n  enhancedWallTreatment(yPlus, nu, nuT) {\n    // Blend between viscous and log-law based on y+\n    const uPlusVis = yPlus;  // Viscous sublayer\n    const uPlusLog = Math.log(this.E * yPlus) / this.kappa;  // Log-law\n    \n    // Blending function\n    const Gamma = 0.01 * Math.pow(yPlus, 4) / (1 + 5 * yPlus);\n    const uPlus = Math.exp(-Gamma) * uPlusVis + \n                  Math.exp(-1/Gamma) * uPlusLog;\n    \n    return uPlus;\n  }\n}"
  },
  {
    "id": 26,
    "question": "What is the energy equation in CFD?",
    "answer": "**Energy equation** describes conservation of energy, essential for heat transfer and compressible flow.\n\n**Total energy form:**\n$$\\frac{\\partial (\\rho E)}{\\partial t} + \\nabla \\cdot [(\\rho E + p)\\mathbf{u}] = \\nabla \\cdot (k\\nabla T) + \\Phi$$\n\nwhere E = e + |u|²/2 (internal + kinetic)\n\n**Temperature form (incompressible):**\n$$\\rho c_p \\left(\\frac{\\partial T}{\\partial t} + \\mathbf{u}\\cdot\\nabla T\\right) = \\nabla \\cdot (k\\nabla T) + \\dot{q}$$\n\n**Terms:**\n- Transient: ∂(ρcpT)/∂t\n- Convection: ρcp(u·∇T)\n- Diffusion: ∇·(k∇T)\n- Source: Heat generation, radiation\n- Viscous dissipation: Φ (usually negligible)\n\n**Coupling:**\n- Temperature affects density (compressible)\n- Temperature affects viscosity\n- Buoyancy coupling (Boussinesq)\n\n**Boundary conditions:**\n- Fixed temperature: T = T_wall\n- Heat flux: -k∂T/∂n = q\n- Convection: -k∂T/∂n = h(T - T_∞)",
    "example": "// Energy equation solver\n\nclass EnergySolver {\n  constructor(mesh, props) {\n    this.mesh = mesh;\n    this.rho = props.rho;    // Density\n    this.cp = props.cp;      // Specific heat\n    this.k = props.k;        // Thermal conductivity\n    this.alpha = props.k / (props.rho * props.cp); // Thermal diffusivity\n  }\n  \n  // Solve temperature equation\n  solve(T, u, v, w, dt, source = null) {\n    const Tnew = [...T];\n    \n    for (const cell of this.mesh.cells) {\n      let convection = 0;\n      let diffusion = 0;\n      \n      for (const face of cell.faces) {\n        // Face values\n        const Tf = this.interpolate(T, face);\n        const uf = this.interpolate(u, face);\n        const vf = this.interpolate(v, face);\n        const wf = this.interpolate(w, face);\n        \n        // Mass flux through face\n        const mdot = this.rho * (\n          uf * face.normal.x + \n          vf * face.normal.y + \n          wf * face.normal.z\n        ) * face.area;\n        \n        // Convective flux\n        convection += mdot * Tf;\n        \n        // Diffusive flux: -k * ∇T · n * A\n        const gradT = this.gradientAtFace(T, face);\n        diffusion += this.k * gradT * face.area;\n      }\n      \n      // Update temperature\n      const rhoCpV = this.rho * this.cp * cell.volume;\n      let dTdt = (-convection + diffusion) / rhoCpV;\n      \n      if (source) dTdt += source[cell.id] / (this.rho * this.cp);\n      \n      Tnew[cell.id] = T[cell.id] + dt * dTdt;\n    }\n    \n    return Tnew;\n  }\n  \n  // Prandtl number\n  prandtlNumber() {\n    return this.cp * (this.rho * 1.5e-5) / this.k; // Using typical air viscosity\n  }\n  \n  // Peclet number for a cell\n  pecletNumber(u, dx) {\n    return Math.abs(u) * dx / this.alpha;\n  }\n}"
  },
  {
    "id": 27,
    "question": "What is multigrid and why is it effective for CFD?",
    "answer": "**Multigrid** accelerates convergence by solving on multiple grid levels, exploiting the fact that iterative methods efficiently damp high-frequency errors but struggle with low-frequency ones.\n\n**Key insight:**\n- Fine grid: Damps high-frequency errors quickly\n- Coarse grid: Low frequencies appear as high frequencies\n- Solve on coarse, interpolate correction to fine\n\n**V-cycle algorithm:**\n1. Pre-smooth on fine grid (few iterations)\n2. Restrict residual to coarse grid\n3. Solve/smooth on coarse grid\n4. Prolongate correction to fine grid\n5. Post-smooth on fine grid\n6. Repeat until converged\n\n**Operations:**\n- **Restriction**: Fine → Coarse (average/inject)\n- **Prolongation**: Coarse → Fine (interpolate)\n- **Smoothing**: Gauss-Seidel, Jacobi\n\n**Why effective:**\n- Optimal complexity: O(n) vs O(n²) for single grid\n- Handles all error frequencies\n- Grid-independent convergence rate\n\n**Types:**\n- Geometric multigrid: Uses actual coarse meshes\n- Algebraic multigrid (AMG): Coarsens matrix algebraically",
    "example": "// Multigrid V-cycle implementation\n\nclass Multigrid {\n  constructor(levels) {\n    this.levels = levels; // Array of grids, finest first\n    this.numLevels = levels.length;\n  }\n  \n  // Restriction: fine to coarse (full weighting)\n  restrict(fineGrid, fine, coarse) {\n    for (let i = 0; i < coarse.length; i++) {\n      // Average fine grid neighbors\n      const fineIdx = 2 * i;\n      coarse[i] = 0.25 * (fine[fineIdx-1] + 2*fine[fineIdx] + fine[fineIdx+1]);\n    }\n    return coarse;\n  }\n  \n  // Prolongation: coarse to fine (linear interpolation)\n  prolongate(coarseGrid, coarse, fine) {\n    for (let i = 0; i < coarse.length; i++) {\n      fine[2*i] = coarse[i];\n      if (2*i + 1 < fine.length) {\n        fine[2*i + 1] = 0.5 * (coarse[i] + coarse[i+1]);\n      }\n    }\n    return fine;\n  }\n  \n  // V-cycle\n  vCycle(level, phi, rhs, nu1 = 2, nu2 = 2) {\n    if (level === this.numLevels - 1) {\n      // Coarsest level: solve directly or smooth many times\n      return this.directSolve(this.levels[level], rhs);\n    }\n    \n    const grid = this.levels[level];\n    const coarseGrid = this.levels[level + 1];\n    \n    // Pre-smoothing\n    for (let i = 0; i < nu1; i++) {\n      phi = this.smooth(grid, phi, rhs);\n    }\n    \n    // Compute residual: r = rhs - A*phi\n    const residual = this.computeResidual(grid, phi, rhs);\n    \n    // Restrict residual to coarse grid\n    const coarseRHS = this.restrict(grid, residual, \n      new Array(coarseGrid.n).fill(0));\n    \n    // Recursive call on coarse grid\n    let coarseCorrection = new Array(coarseGrid.n).fill(0);\n    coarseCorrection = this.vCycle(level + 1, coarseCorrection, coarseRHS);\n    \n    // Prolongate correction and add to phi\n    const correction = this.prolongate(coarseGrid, coarseCorrection,\n      new Array(grid.n).fill(0));\n    phi = phi.map((p, i) => p + correction[i]);\n    \n    // Post-smoothing\n    for (let i = 0; i < nu2; i++) {\n      phi = this.smooth(grid, phi, rhs);\n    }\n    \n    return phi;\n  }\n}"
  },
  {
    "id": 28,
    "question": "What is shock capturing in compressible CFD?",
    "answer": "**Shock capturing** methods handle discontinuities (shocks) that arise in supersonic flows without explicitly tracking them.\n\n**The challenge:**\n- Shocks are discontinuities in flow properties\n- Standard schemes oscillate near discontinuities\n- Need numerical dissipation without smearing\n\n**Approaches:**\n\n**1. Artificial viscosity**\n- Add dissipation near shocks\n- Simple but problem-dependent tuning\n\n**2. TVD schemes**\n- Total Variation Diminishing\n- Flux limiters prevent oscillations\n- Van Leer, Superbee, Minmod\n\n**3. ENO/WENO**\n- Essentially Non-Oscillatory\n- Adaptive stencil selection\n- High-order accuracy in smooth regions\n\n**4. Flux splitting**\n- Roe, AUSM, HLLC schemes\n- Upwind based on wave speeds\n\n**Properties needed:**\n- Conservation (correct shock speed)\n- No spurious oscillations\n- Sharp shock resolution\n- High accuracy in smooth regions",
    "example": "// Shock capturing schemes for 1D Euler equations\n\nclass ShockCapturing {\n  constructor(gamma = 1.4) {\n    this.gamma = gamma;\n  }\n  \n  // Minmod limiter\n  minmod(a, b) {\n    if (a * b <= 0) return 0;\n    return Math.sign(a) * Math.min(Math.abs(a), Math.abs(b));\n  }\n  \n  // Van Leer limiter\n  vanLeer(r) {\n    return (r + Math.abs(r)) / (1 + Math.abs(r));\n  }\n  \n  // Superbee limiter (sharper but may overshoot)\n  superbee(r) {\n    return Math.max(0, Math.min(2*r, 1), Math.min(r, 2));\n  }\n  \n  // TVD scheme with limiter\n  tvdFlux(uL, uR, uLL, uRR, a) {\n    // Compute ratio of slopes\n    const r = (uL - uLL) / (uR - uL + 1e-10);\n    const phi = this.vanLeer(r);\n    \n    // Upwind flux with limited correction\n    const fLow = a > 0 ? uL : uR;  // First-order upwind\n    const fHigh = 0.5 * (uL + uR);  // Central\n    \n    return fLow + phi * (fHigh - fLow);\n  }\n  \n  // Roe flux for Euler equations\n  roeFlux(UL, UR) {\n    // Roe-averaged quantities\n    const rhoL = UL[0], rhoR = UR[0];\n    const sqrtRhoL = Math.sqrt(rhoL);\n    const sqrtRhoR = Math.sqrt(rhoR);\n    \n    const uL = UL[1] / rhoL, uR = UR[1] / rhoR;\n    const u_roe = (sqrtRhoL * uL + sqrtRhoR * uR) / \n                  (sqrtRhoL + sqrtRhoR);\n    \n    // Compute wave speeds and flux\n    // F = 0.5 * (FL + FR) - 0.5 * Σ |λi| * ΔWi * Ri\n    const FL = this.eulerFlux(UL);\n    const FR = this.eulerFlux(UR);\n    \n    // Simplified: add numerical dissipation\n    const dissipation = this.computeDissipation(UL, UR, u_roe);\n    \n    return FL.map((f, i) => 0.5 * (f + FR[i]) - 0.5 * dissipation[i]);\n  }\n  \n  // Euler flux function\n  eulerFlux(U) {\n    const rho = U[0];\n    const u = U[1] / rho;\n    const E = U[2];\n    const p = (this.gamma - 1) * (E - 0.5 * rho * u * u);\n    \n    return [\n      rho * u,\n      rho * u * u + p,\n      (E + p) * u\n    ];\n  }\n}"
  },
  {
    "id": 29,
    "question": "What is the Peclet number and how does it affect discretization?",
    "answer": "**Peclet number (Pe)** is the ratio of convective to diffusive transport.\n\n**Definition:**\n$$Pe = \\frac{UL}{\\Gamma/\\rho} = \\frac{\\text{Convection}}{\\text{Diffusion}}$$\n\n**Cell Peclet number:**\n$$Pe_{cell} = \\frac{\\rho U \\Delta x}{\\Gamma}$$\n\n**Physical meaning:**\n- Pe << 1: Diffusion dominated\n- Pe >> 1: Convection dominated\n- Pe ≈ 1: Both important\n\n**Effect on discretization:**\n\n**Central differencing:**\n- Oscillates when |Pe_cell| > 2\n- OK for diffusion-dominated flows\n\n**Upwind:**\n- Stable for any Pe\n- Adds numerical diffusion\n\n**Hybrid schemes:**\n- Switch based on local Pe\n- Central for Pe < 2, Upwind for Pe > 2\n\n**Mesh design:**\n- Refine until Pe_cell ≈ 2 if using central\n- Or use TVD schemes for high Pe\n\n**Related numbers:**\n- Thermal: Pe = Re × Pr\n- Mass transfer: Pe = Re × Sc",
    "example": "// Peclet number analysis and scheme selection\n\nclass PecletAnalysis {\n  constructor(rho, Gamma) {\n    this.rho = rho;     // Density\n    this.Gamma = Gamma; // Diffusivity (k, μ, D)\n  }\n  \n  // Cell Peclet number\n  cellPeclet(U, dx) {\n    return (this.rho * Math.abs(U) * dx) / this.Gamma;\n  }\n  \n  // Recommend scheme based on Peclet\n  recommendScheme(Pe) {\n    if (Pe < 2) {\n      return 'Central differencing';\n    } else if (Pe < 10) {\n      return 'Hybrid or Power-law';\n    } else {\n      return 'Upwind or TVD';\n    }\n  }\n  \n  // Hybrid scheme coefficient\n  hybridCoeff(Pe) {\n    // A(Pe) function for hybrid scheme\n    return Math.max(0, 1 - 0.5 * Math.abs(Pe));\n  }\n  \n  // Power-law scheme coefficient\n  powerLawCoeff(Pe) {\n    return Math.max(0, Math.pow(1 - 0.1 * Math.abs(Pe), 5));\n  }\n  \n  // Exponential (exact) scheme coefficient\n  exponentialCoeff(Pe) {\n    if (Math.abs(Pe) < 1e-6) return 1 - 0.5 * Math.abs(Pe);\n    return Pe / (Math.exp(Pe) - 1);\n  }\n  \n  // Analyze mesh for convection-diffusion problem\n  analyzeMesh(mesh, velocity) {\n    const analysis = { maxPe: 0, avgPe: 0, cellsHighPe: 0 };\n    \n    for (const cell of mesh.cells) {\n      const U = Math.sqrt(\n        velocity[cell.id].u ** 2 +\n        velocity[cell.id].v ** 2\n      );\n      const dx = Math.cbrt(cell.volume); // Characteristic length\n      const Pe = this.cellPeclet(U, dx);\n      \n      analysis.maxPe = Math.max(analysis.maxPe, Pe);\n      analysis.avgPe += Pe / mesh.cells.length;\n      if (Pe > 2) analysis.cellsHighPe++;\n    }\n    \n    console.log(`Max Peclet: ${analysis.maxPe.toFixed(2)}`);\n    console.log(`Avg Peclet: ${analysis.avgPe.toFixed(2)}`);\n    console.log(`Cells with Pe > 2: ${analysis.cellsHighPe}`);\n    console.log(`Recommended: ${this.recommendScheme(analysis.maxPe)}`);\n    \n    return analysis;\n  }\n}"
  },
  {
    "id": 30,
    "question": "What is the Lattice Boltzmann Method (LBM)?",
    "answer": "**Lattice Boltzmann Method (LBM)** simulates fluid flow by tracking particle distribution functions on a discrete lattice, rather than solving Navier-Stokes directly.\n\n**Key concept:**\n- Particles stream along lattice links\n- Particles collide at nodes\n- Macroscopic quantities emerge statistically\n\n**Boltzmann equation:**\n$$f_i(\\mathbf{x}+\\mathbf{c}_i\\Delta t, t+\\Delta t) - f_i(\\mathbf{x},t) = \\Omega_i$$\n\n**BGK collision operator:**\n$$\\Omega_i = -\\frac{1}{\\tau}(f_i - f_i^{eq})$$\n\n**Common lattices:**\n- D2Q9: 2D, 9 velocities\n- D3Q19: 3D, 19 velocities\n- D3Q27: 3D, 27 velocities\n\n**Advantages:**\n- Easy parallelization (local operations)\n- Complex boundaries straightforward\n- Multiphase flows natural\n- Good for porous media\n\n**Limitations:**\n- High Mach flows difficult\n- Compressibility effects limited\n- Memory intensive\n- Thermals require extensions",
    "example": "// Lattice Boltzmann D2Q9 implementation\n\nclass LatticeBoltzmann2D {\n  constructor(nx, ny, tau) {\n    this.nx = nx;\n    this.ny = ny;\n    this.tau = tau; // Relaxation time\n    this.omega = 1 / tau; // Collision frequency\n    \n    // D2Q9 velocities\n    this.cx = [0, 1, 0, -1, 0, 1, -1, -1, 1];\n    this.cy = [0, 0, 1, 0, -1, 1, 1, -1, -1];\n    \n    // Weights\n    this.w = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];\n    \n    // Distribution functions\n    this.f = this.initDistributions();\n    this.fNew = this.initDistributions();\n  }\n  \n  // Equilibrium distribution\n  equilibrium(rho, ux, uy, i) {\n    const cu = this.cx[i] * ux + this.cy[i] * uy;\n    const u2 = ux * ux + uy * uy;\n    return this.w[i] * rho * (1 + 3*cu + 4.5*cu*cu - 1.5*u2);\n  }\n  \n  // Compute macroscopic quantities\n  macroscopic(x, y) {\n    let rho = 0, ux = 0, uy = 0;\n    \n    for (let i = 0; i < 9; i++) {\n      const fi = this.f[x][y][i];\n      rho += fi;\n      ux += this.cx[i] * fi;\n      uy += this.cy[i] * fi;\n    }\n    ux /= rho;\n    uy /= rho;\n    \n    return { rho, ux, uy };\n  }\n  \n  // Collision step (BGK)\n  collide() {\n    for (let x = 0; x < this.nx; x++) {\n      for (let y = 0; y < this.ny; y++) {\n        const { rho, ux, uy } = this.macroscopic(x, y);\n        \n        for (let i = 0; i < 9; i++) {\n          const feq = this.equilibrium(rho, ux, uy, i);\n          this.f[x][y][i] += this.omega * (feq - this.f[x][y][i]);\n        }\n      }\n    }\n  }\n  \n  // Streaming step\n  stream() {\n    for (let x = 0; x < this.nx; x++) {\n      for (let y = 0; y < this.ny; y++) {\n        for (let i = 0; i < 9; i++) {\n          const xNew = (x + this.cx[i] + this.nx) % this.nx;\n          const yNew = (y + this.cy[i] + this.ny) % this.ny;\n          this.fNew[xNew][yNew][i] = this.f[x][y][i];\n        }\n      }\n    }\n    [this.f, this.fNew] = [this.fNew, this.f]; // Swap\n  }\n  \n  // One time step\n  step() {\n    this.collide();\n    this.stream();\n  }\n}"
  },
  {
    "id": 31,
    "question": "What is Adaptive Mesh Refinement (AMR)?",
    "answer": "**Adaptive Mesh Refinement (AMR)** dynamically adjusts mesh resolution during simulation to concentrate cells where needed.\n\n**Motivation:**\n- Uniform fine mesh is expensive\n- High resolution only needed locally\n- Flow features move in time\n\n**Refinement criteria:**\n- Gradient-based: |∇φ| > threshold\n- Error estimators: Truncation error\n- Feature detection: Vorticity, shocks\n- Solution curvature\n\n**Types:**\n\n**1. h-refinement**\n- Subdivide cells (quad/octree)\n- Most common\n\n**2. p-refinement**\n- Increase polynomial order\n- Spectral element methods\n\n**3. r-refinement**\n- Move existing nodes\n- Mesh smoothing\n\n**Challenges:**\n- Hanging nodes at refinement boundaries\n- Load balancing for parallel\n- Conservation at interfaces\n- Interpolation errors\n\n**Applications:**\n- Shock tracking\n- Combustion fronts\n- Vortex dynamics\n- Multiphase interfaces",
    "example": "// Adaptive Mesh Refinement framework\n\nclass AMRManager {\n  constructor(baseMesh, maxLevels = 4) {\n    this.baseMesh = baseMesh;\n    this.maxLevels = maxLevels;\n    this.refinementThreshold = 0.1;\n    this.coarseningThreshold = 0.01;\n  }\n  \n  // Refinement criterion based on gradient\n  computeRefinementIndicator(cell, phi) {\n    const gradient = this.computeGradient(phi, cell);\n    return Math.sqrt(\n      gradient.x ** 2 + gradient.y ** 2 + gradient.z ** 2\n    ) * Math.cbrt(cell.volume);\n  }\n  \n  // Mark cells for refinement/coarsening\n  markCells(mesh, phi) {\n    const marked = { refine: [], coarsen: [] };\n    \n    for (const cell of mesh.cells) {\n      const indicator = this.computeRefinementIndicator(cell, phi);\n      \n      if (indicator > this.refinementThreshold && \n          cell.level < this.maxLevels) {\n        marked.refine.push(cell.id);\n      } else if (indicator < this.coarseningThreshold && \n                 cell.level > 0) {\n        marked.coarsen.push(cell.id);\n      }\n    }\n    \n    return marked;\n  }\n  \n  // Refine a cell (2D quadtree example)\n  refineCell(cell) {\n    const children = [];\n    const halfSize = cell.size / 2;\n    \n    // Create 4 children (2D) or 8 children (3D)\n    for (let i = 0; i < 4; i++) {\n      const offsetX = (i % 2) * halfSize;\n      const offsetY = Math.floor(i / 2) * halfSize;\n      \n      children.push({\n        id: `${cell.id}_${i}`,\n        x: cell.x + offsetX,\n        y: cell.y + offsetY,\n        size: halfSize,\n        level: cell.level + 1,\n        parent: cell.id\n      });\n    }\n    \n    return children;\n  }\n  \n  // Interpolate solution to refined cells\n  interpolateToChildren(parentValue, children) {\n    // Simple injection for cell-centered\n    // Can use higher-order interpolation\n    return children.map(() => parentValue);\n  }\n  \n  // Coarsen cells (aggregate children to parent)\n  coarsenCells(parent, children, phi) {\n    // Volume-weighted average\n    let sum = 0, totalVol = 0;\n    for (const child of children) {\n      sum += phi[child.id] * child.volume;\n      totalVol += child.volume;\n    }\n    return sum / totalVol;\n  }\n  \n  // Ensure 2:1 balance (no more than one level difference)\n  enforceBalance(mesh, marked) {\n    // Add cells to refinement list to maintain balance\n    let changed = true;\n    while (changed) {\n      changed = false;\n      for (const cell of mesh.cells) {\n        for (const neighbor of cell.neighbors) {\n          if (neighbor.level < cell.level - 1 && \n              !marked.refine.includes(neighbor.id)) {\n            marked.refine.push(neighbor.id);\n            changed = true;\n          }\n        }\n      }\n    }\n    return marked;\n  }\n}"
  },
  {
    "id": 32,
    "question": "What is the Von Neumann stability analysis?",
    "answer": "**Von Neumann stability analysis** determines whether a numerical scheme is stable by examining how Fourier modes grow or decay.\n\n**Method:**\n1. Assume solution: φⁿⱼ = Gⁿ·e^(ikjΔx)\n2. G = amplification factor\n3. Substitute into scheme\n4. Solve for G(k)\n5. Stable if |G| ≤ 1 for all k\n\n**Example - FTCS for heat equation:**\n∂T/∂t = α∂²T/∂x²\n\nScheme: Tⁿ⁺¹ⱼ = Tⁿⱼ + r(Tⁿⱼ₊₁ - 2Tⁿⱼ + Tⁿⱼ₋₁)\nwhere r = αΔt/Δx²\n\nAmplification factor:\nG = 1 + r(e^(ikΔx) + e^(-ikΔx) - 2)\nG = 1 - 4r·sin²(kΔx/2)\n\nStability: |G| ≤ 1 requires r ≤ 1/2\n\n**Limitations:**\n- Linear equations only\n- Constant coefficients\n- Periodic boundaries assumed\n- Necessary, not always sufficient\n\n**Applications:**\n- Derive CFL conditions\n- Compare scheme stability\n- Guide time step selection",
    "example": "// Von Neumann stability analysis tools\n\nclass StabilityAnalysis {\n  // FTCS scheme for diffusion\n  ftcsAmplificationFactor(r, kDx) {\n    // r = α*dt/dx², kDx = k*Δx (wavenumber * grid spacing)\n    return 1 - 4 * r * Math.pow(Math.sin(kDx / 2), 2);\n  }\n  \n  // Check stability across all wavenumbers\n  checkFTCSStability(r, nModes = 100) {\n    let maxG = 0;\n    \n    for (let i = 0; i <= nModes; i++) {\n      const kDx = Math.PI * i / nModes; // k*Δx from 0 to π\n      const G = this.ftcsAmplificationFactor(r, kDx);\n      maxG = Math.max(maxG, Math.abs(G));\n    }\n    \n    return {\n      stable: maxG <= 1,\n      maxAmplification: maxG,\n      criticalR: 0.5 // Theoretical stability limit\n    };\n  }\n  \n  // Upwind scheme for convection\n  upwindAmplificationFactor(cfl, kDx) {\n    // CFL = u*dt/dx\n    const real = 1 - cfl * (1 - Math.cos(kDx));\n    const imag = -cfl * Math.sin(kDx);\n    return Math.sqrt(real*real + imag*imag);\n  }\n  \n  // Lax-Wendroff scheme\n  laxWendroffAmplification(cfl, kDx) {\n    const real = 1 - 2*cfl*cfl * Math.pow(Math.sin(kDx/2), 2);\n    const imag = -cfl * Math.sin(kDx);\n    return Math.sqrt(real*real + imag*imag);\n  }\n  \n  // Plot stability region\n  plotStabilityRegion(scheme, rRange, nModes = 50) {\n    const results = [];\n    \n    for (let r = rRange[0]; r <= rRange[1]; r += 0.01) {\n      let maxG = 0;\n      for (let i = 0; i <= nModes; i++) {\n        const kDx = Math.PI * i / nModes;\n        const G = scheme(r, kDx);\n        maxG = Math.max(maxG, Math.abs(G));\n      }\n      results.push({ r, maxG, stable: maxG <= 1 });\n    }\n    \n    return results;\n  }\n  \n  // Find critical stability parameter\n  findCriticalParameter(scheme, tolerance = 1e-4) {\n    let rLow = 0, rHigh = 2;\n    \n    while (rHigh - rLow > tolerance) {\n      const rMid = (rLow + rHigh) / 2;\n      const { stable } = this.checkFTCSStability(rMid);\n      \n      if (stable) rLow = rMid;\n      else rHigh = rMid;\n    }\n    \n    return (rLow + rHigh) / 2;\n  }\n}"
  },
  {
    "id": 33,
    "question": "What are Verification and Validation (V&V) in CFD?",
    "answer": "**Verification** and **Validation** are processes to assess CFD simulation credibility.\n\n**Verification: \"Solving the equations right\"**\n- Are the equations solved correctly?\n- Code verification: No bugs in implementation\n- Solution verification: Discretization errors quantified\n\n**Methods:**\n- Method of Manufactured Solutions (MMS)\n- Grid convergence studies (GCI)\n- Comparison with analytical solutions\n- Order of accuracy tests\n\n**Validation: \"Solving the right equations\"**\n- Does the model represent reality?\n- Compare with experimental data\n- Assess model assumptions\n\n**Methods:**\n- Experimental comparisons\n- Benchmark cases\n- Uncertainty quantification\n- Sensitivity analysis\n\n**Error sources:**\n- Modeling errors: Turbulence, boundary conditions\n- Discretization errors: Grid, time step\n- Iteration errors: Convergence\n- Round-off errors: Machine precision\n\n**Standards:**\n- AIAA G-077-1998\n- ASME V&V 20",
    "example": "// Verification and Validation framework\n\nclass CFDValidation {\n  // Method of Manufactured Solutions (MMS)\n  manufacturedSolution() {\n    // Define exact solution that satisfies BCs\n    const phiExact = (x, y) => Math.sin(Math.PI * x) * Math.sin(Math.PI * y);\n    \n    // Compute source term by substituting into PDE\n    // For Poisson equation: ∇²φ = f\n    const source = (x, y) => 2 * Math.PI * Math.PI * phiExact(x, y);\n    \n    return { phiExact, source };\n  }\n  \n  // Compute error norms\n  computeErrorNorms(numerical, exact, mesh) {\n    let L1 = 0, L2 = 0, Linf = 0;\n    let totalVol = 0;\n    \n    for (const cell of mesh.cells) {\n      const error = Math.abs(numerical[cell.id] - exact(cell.x, cell.y));\n      L1 += error * cell.volume;\n      L2 += error * error * cell.volume;\n      Linf = Math.max(Linf, error);\n      totalVol += cell.volume;\n    }\n    \n    return {\n      L1: L1 / totalVol,\n      L2: Math.sqrt(L2 / totalVol),\n      Linf: Linf\n    };\n  }\n  \n  // Verify order of accuracy\n  verifyOrder(meshes, solutions, exact) {\n    const errors = meshes.map((mesh, i) => {\n      const norms = this.computeErrorNorms(solutions[i], exact, mesh);\n      return { h: mesh.characteristicSize, L2: norms.L2 };\n    });\n    \n    // Compute observed order\n    const orders = [];\n    for (let i = 1; i < errors.length; i++) {\n      const order = Math.log(errors[i-1].L2 / errors[i].L2) / \n                   Math.log(errors[i-1].h / errors[i].h);\n      orders.push(order);\n    }\n    \n    return { errors, observedOrder: orders };\n  }\n  \n  // Validation metrics\n  computeValidationMetrics(simulation, experiment) {\n    let sumSqDiff = 0, sumSqExp = 0;\n    let n = experiment.length;\n    \n    for (let i = 0; i < n; i++) {\n      const diff = simulation[i] - experiment[i];\n      sumSqDiff += diff * diff;\n      sumSqExp += experiment[i] * experiment[i];\n    }\n    \n    return {\n      RMSE: Math.sqrt(sumSqDiff / n),\n      relativeError: Math.sqrt(sumSqDiff / sumSqExp) * 100,\n      correlation: this.pearsonCorrelation(simulation, experiment)\n    };\n  }\n  \n  // Uncertainty quantification\n  uncertaintyBounds(simulation, gridUncertainty, modelUncertainty) {\n    // Combined uncertainty (root sum square)\n    const totalUncertainty = Math.sqrt(\n      gridUncertainty ** 2 + modelUncertainty ** 2\n    );\n    \n    return {\n      value: simulation,\n      lower: simulation - 2 * totalUncertainty,\n      upper: simulation + 2 * totalUncertainty,\n      confidence: '95%'\n    };\n  }\n}"
  },
  {
    "id": 34,
    "question": "What is the Volume of Fluid (VOF) method for multiphase flows?",
    "answer": "**Volume of Fluid (VOF)** tracks immiscible fluids by advecting a volume fraction field.\n\n**Volume fraction α:**\n- α = 1: Cell full of fluid 1\n- α = 0: Cell full of fluid 2\n- 0 < α < 1: Interface present\n\n**Transport equation:**\n$$\\frac{\\partial \\alpha}{\\partial t} + \\nabla \\cdot (\\alpha \\mathbf{u}) = 0$$\n\n**Key challenges:**\n\n**1. Interface smearing**\n- Numerical diffusion spreads interface\n- Need interface compression\n\n**2. Interface reconstruction**\n- PLIC (Piecewise Linear Interface Calculation)\n- SLIC (Simple Line Interface Calculation)\n\n**3. Surface tension**\n- Continuum Surface Force (CSF)\n- F = σκn δ_s (curvature-based)\n\n**Mixture properties:**\n$$\\rho = \\alpha\\rho_1 + (1-\\alpha)\\rho_2$$\n$$\\mu = \\alpha\\mu_1 + (1-\\alpha)\\mu_2$$\n\n**Applications:**\n- Free surface flows\n- Bubble/droplet dynamics\n- Sloshing\n- Breaking waves",
    "example": "// Volume of Fluid implementation\n\nclass VOFSolver {\n  constructor(rho1, rho2, mu1, mu2, sigma) {\n    this.rho1 = rho1;  // Fluid 1 density\n    this.rho2 = rho2;  // Fluid 2 density\n    this.mu1 = mu1;    // Fluid 1 viscosity\n    this.mu2 = mu2;    // Fluid 2 viscosity\n    this.sigma = sigma; // Surface tension\n  }\n  \n  // Mixture density\n  density(alpha) {\n    return alpha * this.rho1 + (1 - alpha) * this.rho2;\n  }\n  \n  // Mixture viscosity\n  viscosity(alpha) {\n    return alpha * this.mu1 + (1 - alpha) * this.mu2;\n  }\n  \n  // Advect volume fraction\n  advect(alpha, u, v, w, dt, mesh) {\n    const alphaNew = [...alpha];\n    \n    for (const cell of mesh.cells) {\n      let flux = 0;\n      \n      for (const face of cell.faces) {\n        // Face velocity\n        const uFace = this.interpolate(u, face);\n        const vFace = this.interpolate(v, face);\n        const wFace = this.interpolate(w, face);\n        \n        const vn = uFace * face.normal.x + \n                   vFace * face.normal.y + \n                   wFace * face.normal.z;\n        \n        // Upwind alpha at face\n        const alphaFace = vn > 0 ? \n          alpha[face.owner] : alpha[face.neighbor];\n        \n        flux += vn * alphaFace * face.area;\n      }\n      \n      alphaNew[cell.id] = alpha[cell.id] - dt * flux / cell.volume;\n      \n      // Bound alpha between 0 and 1\n      alphaNew[cell.id] = Math.max(0, Math.min(1, alphaNew[cell.id]));\n    }\n    \n    return alphaNew;\n  }\n  \n  // Interface compression (sharpen interface)\n  compress(alpha, mesh, cAlpha = 1) {\n    // Add artificial compression velocity at interface\n    const alphaCompressed = [...alpha];\n    \n    for (const cell of mesh.cells) {\n      if (alpha[cell.id] > 0.01 && alpha[cell.id] < 0.99) {\n        // Interface cell - apply compression\n        const gradAlpha = this.gradient(alpha, cell);\n        // Compression pushes alpha towards 0 or 1\n      }\n    }\n    \n    return alphaCompressed;\n  }\n  \n  // Curvature for surface tension (CSF method)\n  computeCurvature(alpha, cell, mesh) {\n    const gradAlpha = this.gradient(alpha, cell);\n    const magGrad = Math.sqrt(\n      gradAlpha.x**2 + gradAlpha.y**2 + gradAlpha.z**2\n    ) + 1e-10;\n    \n    // Normal vector\n    const n = {\n      x: gradAlpha.x / magGrad,\n      y: gradAlpha.y / magGrad,\n      z: gradAlpha.z / magGrad\n    };\n    \n    // Curvature = -∇·n\n    return -this.divergence(n, cell);\n  }\n  \n  // Surface tension force (CSF)\n  surfaceTensionForce(alpha, curvature, cell) {\n    const gradAlpha = this.gradient(alpha, cell);\n    return {\n      x: this.sigma * curvature * gradAlpha.x,\n      y: this.sigma * curvature * gradAlpha.y,\n      z: this.sigma * curvature * gradAlpha.z\n    };\n  }\n}"
  },
  {
    "id": 35,
    "question": "What is the Gauss-Seidel iteration method?",
    "answer": "**Gauss-Seidel** is an iterative method for solving linear systems Ax = b, improving on Jacobi by using updated values immediately.\n\n**Algorithm:**\nFor each equation i:\n$$x_i^{(k+1)} = \\frac{1}{a_{ii}}\\left(b_i - \\sum_{j<i}a_{ij}x_j^{(k+1)} - \\sum_{j>i}a_{ij}x_j^{(k)}\\right)$$\n\n**Key difference from Jacobi:**\n- Jacobi: Uses only old iteration values\n- Gauss-Seidel: Uses new values as soon as available\n\n**Convergence:**\n- Converges if A is strictly diagonally dominant\n- Converges if A is symmetric positive definite\n- Generally faster than Jacobi\n- Convergence rate depends on spectral radius\n\n**Advantages:**\n- Simple implementation\n- Uses less memory than Jacobi (in-place updates)\n- Faster convergence than Jacobi\n\n**Disadvantages:**\n- Sequential (harder to parallelize)\n- May not converge for all matrices\n- Can be slow for large systems\n\n**CFD use:**\n- Smoother in multigrid\n- Simple pressure solver\n- Often combined with SOR",
    "example": "// Gauss-Seidel implementation\n\nclass GaussSeidelSolver {\n  constructor(tolerance = 1e-6, maxIterations = 10000) {\n    this.tolerance = tolerance;\n    this.maxIterations = maxIterations;\n  }\n  \n  // Solve Ax = b\n  solve(A, b) {\n    const n = b.length;\n    const x = new Array(n).fill(0); // Initial guess\n    \n    for (let iter = 0; iter < this.maxIterations; iter++) {\n      let maxChange = 0;\n      \n      for (let i = 0; i < n; i++) {\n        let sum = b[i];\n        \n        // Use updated values for j < i (already computed this iteration)\n        for (let j = 0; j < i; j++) {\n          sum -= A[i][j] * x[j];\n        }\n        \n        // Use old values for j > i (not yet computed this iteration)\n        for (let j = i + 1; j < n; j++) {\n          sum -= A[i][j] * x[j];\n        }\n        \n        const xNew = sum / A[i][i];\n        maxChange = Math.max(maxChange, Math.abs(xNew - x[i]));\n        x[i] = xNew; // Update immediately!\n      }\n      \n      if (maxChange < this.tolerance) {\n        return { solution: x, iterations: iter + 1, converged: true };\n      }\n    }\n    \n    return { solution: x, iterations: this.maxIterations, converged: false };\n  }\n  \n  // Red-Black Gauss-Seidel (parallelizable variant)\n  solveRedBlack(A, b) {\n    const n = b.length;\n    const x = new Array(n).fill(0);\n    \n    for (let iter = 0; iter < this.maxIterations; iter++) {\n      // Update \"red\" points (can be done in parallel)\n      for (let i = 0; i < n; i += 2) {\n        x[i] = this.updatePoint(A, b, x, i);\n      }\n      \n      // Update \"black\" points (can be done in parallel)\n      for (let i = 1; i < n; i += 2) {\n        x[i] = this.updatePoint(A, b, x, i);\n      }\n      \n      if (this.checkConvergence(A, b, x)) {\n        return { solution: x, iterations: iter + 1 };\n      }\n    }\n    \n    return { solution: x, iterations: this.maxIterations };\n  }\n  \n  updatePoint(A, b, x, i) {\n    let sum = b[i];\n    for (let j = 0; j < x.length; j++) {\n      if (j !== i) sum -= A[i][j] * x[j];\n    }\n    return sum / A[i][i];\n  }\n}"
  },
  {
    "id": 36,
    "question": "What is the PISO algorithm?",
    "answer": "**PISO (Pressure Implicit with Splitting of Operators)** is a pressure-velocity coupling algorithm for transient incompressible flows.\n\n**Developed by Issa (1986)** as an extension of SIMPLE for unsteady flows.\n\n**Key features:**\n- Multiple pressure corrections per time step\n- No under-relaxation needed\n- More accurate for transient flows\n- Higher cost per time step than SIMPLE\n\n**Algorithm:**\n1. **Predictor**: Solve momentum → u*\n2. **1st Corrector**: Solve p' equation, correct u\n3. **2nd Corrector**: Solve p'' equation, correct u again\n4. (Optional) Additional correctors\n5. Advance to next time step\n\n**Pressure corrections:**\n- p' corrects for continuity errors\n- p'' corrects for non-orthogonality and nonlinearity\n\n**When to use:**\n- Transient simulations\n- Large time steps desired\n- When SIMPLE convergence is slow\n\n**PIMPLE:**\n- Combines PISO (inner) + SIMPLE (outer)\n- Allows larger time steps\n- OpenFOAM standard for transient",
    "example": "// PISO algorithm implementation\n\nclass PISOSolver {\n  constructor(mesh, rho, mu, dt) {\n    this.mesh = mesh;\n    this.rho = rho;\n    this.mu = mu;\n    this.dt = dt;\n    this.nCorrectors = 2; // Number of pressure corrections\n  }\n  \n  // Main PISO loop\n  solve(u, v, p) {\n    // Store old values for time derivative\n    const uOld = [...u];\n    const vOld = [...v];\n    \n    // Step 1: Momentum predictor\n    const { uStar, vStar, aP } = this.momentumPredictor(u, v, p, uOld, vOld);\n    \n    // Steps 2-3: Pressure corrector loop\n    let uCorr = [...uStar];\n    let vCorr = [...vStar];\n    let pCorr = [...p];\n    \n    for (let corr = 0; corr < this.nCorrectors; corr++) {\n      // Solve pressure correction equation\n      const pPrime = this.solvePressureCorrection(uCorr, vCorr, aP);\n      \n      // Correct pressure\n      pCorr = pCorr.map((pi, i) => pi + pPrime[i]);\n      \n      // Correct velocities\n      const correction = this.correctVelocities(uCorr, vCorr, pPrime, aP);\n      uCorr = correction.u;\n      vCorr = correction.v;\n    }\n    \n    return { u: uCorr, v: vCorr, p: pCorr };\n  }\n  \n  // Momentum predictor (no under-relaxation in PISO)\n  momentumPredictor(u, v, p, uOld, vOld) {\n    const uStar = [];\n    const vStar = [];\n    const aP = []; // Diagonal coefficient for pressure correction\n    \n    for (const cell of this.mesh.cells) {\n      // Discretize momentum equation\n      // aP*u = H(u) - ∂p/∂x + ρ*V/dt*u_old\n      \n      const { ap, H } = this.discretizeMomentum(u, v, cell);\n      const gradP = this.pressureGradient(p, cell);\n      \n      // Time derivative contribution\n      const timeCoeff = this.rho * cell.volume / this.dt;\n      \n      uStar[cell.id] = (H.x - gradP.x * cell.volume + timeCoeff * uOld[cell.id]) / \n                       (ap + timeCoeff);\n      vStar[cell.id] = (H.y - gradP.y * cell.volume + timeCoeff * vOld[cell.id]) / \n                       (ap + timeCoeff);\n      aP[cell.id] = ap + timeCoeff;\n    }\n    \n    return { uStar, vStar, aP };\n  }\n  \n  // Pressure correction equation\n  solvePressureCorrection(u, v, aP) {\n    // Build and solve: ∇·(1/aP ∇p') = ∇·u\n    const rhs = [];\n    \n    for (const cell of this.mesh.cells) {\n      // RHS = divergence of velocity\n      rhs[cell.id] = this.divergence(u, v, cell);\n    }\n    \n    // Solve Poisson equation for p'\n    return this.solvePoissonEquation(aP, rhs);\n  }\n  \n  // Velocity correction\n  correctVelocities(u, v, pPrime, aP) {\n    const uNew = [...u];\n    const vNew = [...v];\n    \n    for (const cell of this.mesh.cells) {\n      const gradPPrime = this.pressureGradient(pPrime, cell);\n      \n      // u = u* - V/aP * ∇p'\n      uNew[cell.id] -= cell.volume / aP[cell.id] * gradPPrime.x;\n      vNew[cell.id] -= cell.volume / aP[cell.id] * gradPPrime.y;\n    }\n    \n    return { u: uNew, v: vNew };\n  }\n}"
  },
  {
    "id": 37,
    "question": "What is the Spalart-Allmaras turbulence model?",
    "answer": "**Spalart-Allmaras (SA)** is a one-equation RANS turbulence model solving for modified turbulent viscosity.\n\n**Developed for aerospace applications** (1992), particularly boundary layers with adverse pressure gradients.\n\n**Transport equation:**\n$$\\frac{D\\tilde{\\nu}}{Dt} = c_{b1}\\tilde{S}\\tilde{\\nu} + \\frac{1}{\\sigma}[\\nabla\\cdot((\\nu+\\tilde{\\nu})\\nabla\\tilde{\\nu}) + c_{b2}(\\nabla\\tilde{\\nu})^2] - c_{w1}f_w\\left(\\frac{\\tilde{\\nu}}{d}\\right)^2$$\n\n**Key features:**\n- Single transport equation (simpler than k-ε)\n- Designed for aerodynamic flows\n- Good for attached boundary layers\n- Less sensitive to y+ than k-ε\n- Wall distance d required\n\n**Advantages:**\n- Robust and stable\n- Lower computational cost\n- Good for external aerodynamics\n- Works with coarser grids\n\n**Limitations:**\n- Poor for free shear flows\n- Not suitable for jet flows\n- Limited separation prediction\n\n**Variants:**\n- SA-neg: Handles negative ν̃\n- SA-RC: Rotation/curvature correction",
    "example": "// Spalart-Allmaras turbulence model\n\nclass SpalartAllmaras {\n  constructor() {\n    // Model constants\n    this.cb1 = 0.1355;\n    this.cb2 = 0.622;\n    this.sigma = 2/3;\n    this.kappa = 0.41;\n    this.cw1 = this.cb1 / (this.kappa * this.kappa) + \n               (1 + this.cb2) / this.sigma;\n    this.cw2 = 0.3;\n    this.cw3 = 2.0;\n    this.cv1 = 7.1;\n  }\n  \n  // Compute chi = nuTilde / nu\n  chi(nuTilde, nu) {\n    return nuTilde / nu;\n  }\n  \n  // fv1 function\n  fv1(chi) {\n    const chi3 = chi * chi * chi;\n    const cv1_3 = this.cv1 * this.cv1 * this.cv1;\n    return chi3 / (chi3 + cv1_3);\n  }\n  \n  // fv2 function\n  fv2(chi) {\n    return 1 - chi / (1 + chi * this.fv1(chi));\n  }\n  \n  // Turbulent viscosity\n  nuT(nuTilde, nu) {\n    const chi_val = this.chi(nuTilde, nu);\n    return nuTilde * this.fv1(chi_val);\n  }\n  \n  // Modified vorticity\n  STilde(S, nuTilde, nu, d) {\n    const chi_val = this.chi(nuTilde, nu);\n    const fv2_val = this.fv2(chi_val);\n    const Sbar = nuTilde / (this.kappa * this.kappa * d * d) * fv2_val;\n    \n    // Limit to prevent negative values\n    if (Sbar >= -0.7 * S) {\n      return S + Sbar;\n    } else {\n      return S + S * (0.7 * 0.7 * S + 0.9 * Sbar) / \n             ((0.9 - 2 * 0.7) * S - Sbar);\n    }\n  }\n  \n  // Production term\n  production(nuTilde, STilde) {\n    return this.cb1 * STilde * nuTilde;\n  }\n  \n  // Destruction term\n  destruction(nuTilde, nu, d) {\n    const chi_val = this.chi(nuTilde, nu);\n    const r = Math.min(nuTilde / (STilde * this.kappa * this.kappa * d * d), 10);\n    const g = r + this.cw2 * (Math.pow(r, 6) - r);\n    const fw = g * Math.pow((1 + Math.pow(this.cw3, 6)) / \n               (Math.pow(g, 6) + Math.pow(this.cw3, 6)), 1/6);\n    \n    return this.cw1 * fw * Math.pow(nuTilde / d, 2);\n  }\n  \n  // Wall distance calculation (simplified)\n  wallDistance(cell, walls) {\n    let minDist = Infinity;\n    for (const wall of walls) {\n      const dist = this.distanceToWall(cell.center, wall);\n      minDist = Math.min(minDist, dist);\n    }\n    return minDist;\n  }\n}"
  },
  {
    "id": 38,
    "question": "What is the staggered grid arrangement?",
    "answer": "**Staggered grid** stores different variables at different locations to avoid pressure-velocity decoupling.\n\n**The problem with collocated grids:**\n- Pressure gradient uses alternating nodes\n- Can't \"see\" checkerboard pressure patterns\n- Leads to wiggles and non-physical solutions\n\n**Staggered arrangement:**\n- Pressure, scalars: Cell centers\n- u-velocity: East/West face centers\n- v-velocity: North/South face centers\n- w-velocity: Top/Bottom face centers\n\n**Advantages:**\n- Natural pressure-velocity coupling\n- No checkerboard oscillations\n- Simple gradient/divergence calculation\n- Robust for incompressible flows\n\n**Disadvantages:**\n- Complex for unstructured meshes\n- Different control volumes for each variable\n- Boundary conditions more complex\n- Interpolation needed for output\n\n**Modern alternative:**\n- Collocated + Rhie-Chow interpolation\n- Used in most commercial codes\n- Easier for complex geometries",
    "example": "// Staggered grid implementation (2D)\n\nclass StaggeredGrid {\n  constructor(nx, ny, dx, dy) {\n    this.nx = nx;  // Pressure cells in x\n    this.ny = ny;  // Pressure cells in y\n    this.dx = dx;\n    this.dy = dy;\n    \n    // Pressure at cell centers: (nx, ny)\n    this.p = Array(nx).fill(null).map(() => Array(ny).fill(0));\n    \n    // u-velocity at vertical faces: (nx+1, ny)\n    this.u = Array(nx+1).fill(null).map(() => Array(ny).fill(0));\n    \n    // v-velocity at horizontal faces: (nx, ny+1)\n    this.v = Array(nx).fill(null).map(() => Array(ny+1).fill(0));\n  }\n  \n  // Pressure gradient at u-location (natural!)\n  dpdx(i, j) {\n    // u[i,j] sits between p[i-1,j] and p[i,j]\n    return (this.p[i][j] - this.p[i-1][j]) / this.dx;\n  }\n  \n  // Pressure gradient at v-location\n  dpdy(i, j) {\n    // v[i,j] sits between p[i,j-1] and p[i,j]\n    return (this.p[i][j] - this.p[i][j-1]) / this.dy;\n  }\n  \n  // Divergence at cell center (natural!)\n  divergence(i, j) {\n    // Uses adjacent u and v directly\n    return (this.u[i+1][j] - this.u[i][j]) / this.dx +\n           (this.v[i][j+1] - this.v[i][j]) / this.dy;\n  }\n  \n  // Momentum equation for u (simplified)\n  solveUMomentum() {\n    for (let i = 1; i < this.nx; i++) {\n      for (let j = 0; j < this.ny; j++) {\n        // Pressure gradient is computed naturally\n        const gradP = this.dpdx(i, j);\n        \n        // Convection terms need interpolation\n        const uHere = this.u[i][j];\n        const vAtU = 0.25 * (this.v[i-1][j] + this.v[i][j] + \n                            this.v[i-1][j+1] + this.v[i][j+1]);\n        \n        // Update u...\n      }\n    }\n  }\n  \n  // Rhie-Chow interpolation for collocated grids\n  rhieChowFaceVelocity(uL, uR, pL, pC, pR, aL, aR, dx) {\n    // Linear interpolation of velocity\n    const uFace = 0.5 * (uL + uR);\n    \n    // Pressure gradient correction\n    const gradPL = (pC - pL) / dx;\n    const gradPR = (pR - pC) / dx;\n    const gradPFace = (pR - pL) / (2 * dx);\n    const gradPAvg = 0.5 * (gradPL + gradPR);\n    \n    // Correction to remove checkerboard\n    const correction = 0.5 * (1/aL + 1/aR) * (gradPAvg - gradPFace);\n    \n    return uFace + correction;\n  }\n}"
  },
  {
    "id": 39,
    "question": "What are the Euler equations for inviscid flow?",
    "answer": "**Euler equations** describe inviscid (frictionless) fluid flow, obtained from Navier-Stokes by setting viscosity to zero.\n\n**Conservation form:**\n$$\\frac{\\partial \\mathbf{U}}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0$$\n\n**1D Euler equations:**\n\n**Conserved variables:**\n$$\\mathbf{U} = \\begin{bmatrix} \\rho \\\\ \\rho u \\\\ \\rho E \\end{bmatrix}$$\n\n**Flux:**\n$$\\mathbf{F} = \\begin{bmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ (\\rho E + p)u \\end{bmatrix}$$\n\n**Equation of state:**\n$$p = (\\gamma - 1)\\rho\\left(E - \\frac{u^2}{2}\\right)$$\n\n**Characteristics:**\n- Hyperbolic system\n- Three wave speeds: u-a, u, u+a\n- Admits discontinuous solutions (shocks)\n- Contact discontinuities, expansion fans\n\n**Applications:**\n- High-speed aerodynamics\n- Shock tubes\n- Detonation waves\n- Astrophysics",
    "example": "// 1D Euler equations solver\n\nclass EulerSolver1D {\n  constructor(nx, dx, gamma = 1.4) {\n    this.nx = nx;\n    this.dx = dx;\n    this.gamma = gamma;\n    \n    // Conserved variables: [rho, rho*u, rho*E]\n    this.U = Array(nx).fill(null).map(() => [1, 0, 2.5]);\n  }\n  \n  // Primitive variables from conserved\n  conservedToPrimitive(U) {\n    const rho = U[0];\n    const u = U[1] / rho;\n    const E = U[2] / rho;\n    const p = (this.gamma - 1) * rho * (E - 0.5 * u * u);\n    return { rho, u, p, E };\n  }\n  \n  // Conserved from primitive\n  primitiveToConserved(rho, u, p) {\n    const E = p / ((this.gamma - 1) * rho) + 0.5 * u * u;\n    return [rho, rho * u, rho * E];\n  }\n  \n  // Flux function\n  flux(U) {\n    const { rho, u, p, E } = this.conservedToPrimitive(U);\n    return [\n      rho * u,\n      rho * u * u + p,\n      (rho * E + p) * u\n    ];\n  }\n  \n  // Sound speed\n  soundSpeed(rho, p) {\n    return Math.sqrt(this.gamma * p / rho);\n  }\n  \n  // Maximum wave speed (for CFL)\n  maxWaveSpeed(U) {\n    const { rho, u, p } = this.conservedToPrimitive(U);\n    const a = this.soundSpeed(rho, p);\n    return Math.abs(u) + a;\n  }\n  \n  // Local Lax-Friedrichs flux\n  laxFriedrichsFlux(UL, UR) {\n    const FL = this.flux(UL);\n    const FR = this.flux(UR);\n    const alpha = Math.max(this.maxWaveSpeed(UL), this.maxWaveSpeed(UR));\n    \n    return FL.map((fl, i) => \n      0.5 * (fl + FR[i]) - 0.5 * alpha * (UR[i] - UL[i])\n    );\n  }\n  \n  // Time step (explicit)\n  step(dt) {\n    const Unew = this.U.map(u => [...u]);\n    \n    for (let i = 1; i < this.nx - 1; i++) {\n      // Compute fluxes at faces\n      const Fl = this.laxFriedrichsFlux(this.U[i-1], this.U[i]);\n      const Fr = this.laxFriedrichsFlux(this.U[i], this.U[i+1]);\n      \n      // Update conserved variables\n      for (let k = 0; k < 3; k++) {\n        Unew[i][k] = this.U[i][k] - (dt / this.dx) * (Fr[k] - Fl[k]);\n      }\n    }\n    \n    this.U = Unew;\n  }\n  \n  // Sod shock tube initial conditions\n  initSodShockTube() {\n    const midpoint = Math.floor(this.nx / 2);\n    \n    for (let i = 0; i < this.nx; i++) {\n      if (i < midpoint) {\n        // Left state: high pressure\n        this.U[i] = this.primitiveToConserved(1.0, 0, 1.0);\n      } else {\n        // Right state: low pressure\n        this.U[i] = this.primitiveToConserved(0.125, 0, 0.1);\n      }\n    }\n  }\n}"
  },
  {
    "id": 40,
    "question": "What is the gradient calculation in FVM and why does it matter?",
    "answer": "**Gradient calculation** estimates ∇φ at cell centers, essential for diffusion terms, second-order accuracy, and limiters.\n\n**Methods:**\n\n**1. Green-Gauss Cell-Based**\n$$\\nabla\\phi = \\frac{1}{V}\\sum_f \\phi_f \\mathbf{S}_f$$\n- Uses face values (averaged from neighbors)\n- Most common method\n- Sensitive to mesh quality\n\n**2. Green-Gauss Node-Based**\n- Interpolate to nodes first\n- Then use Gauss theorem\n- Better for skewed meshes\n\n**3. Least Squares**\n$$\\nabla\\phi = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{b}$$\n- Minimize error across neighbors\n- Most accurate for irregular meshes\n- Higher computational cost\n\n**Importance:**\n- Diffusion term: ∇·(Γ∇φ)\n- Second-order upwind: φf = φP + ∇φ·r\n- Limiters: Gradient ratio for TVD\n- Non-orthogonal correction\n\n**Quality impact:**\n- Skewed cells → gradient errors\n- Non-orthogonality → correction needed",
    "example": "// Gradient calculation methods for FVM\n\nclass GradientCalculator {\n  // Green-Gauss cell-based gradient\n  greenGaussCellBased(phi, cell, mesh) {\n    const grad = { x: 0, y: 0, z: 0 };\n    \n    for (const face of cell.faces) {\n      // Face value: average of owner and neighbor\n      const phiFace = face.neighbor ? \n        0.5 * (phi[face.owner] + phi[face.neighbor]) :\n        phi[face.owner]; // Boundary\n      \n      // Add face contribution: φf * Sf\n      grad.x += phiFace * face.area * face.normal.x;\n      grad.y += phiFace * face.area * face.normal.y;\n      grad.z += phiFace * face.area * face.normal.z;\n    }\n    \n    // Divide by cell volume\n    grad.x /= cell.volume;\n    grad.y /= cell.volume;\n    grad.z /= cell.volume;\n    \n    return grad;\n  }\n  \n  // Least squares gradient\n  leastSquares(phi, cell, mesh) {\n    const neighbors = mesh.getCellNeighbors(cell.id);\n    const n = neighbors.length;\n    \n    // Build system: minimize |dr · ∇φ - Δφ|²\n    // A = [dx1 dy1 dz1; dx2 dy2 dz2; ...]\n    // b = [Δφ1; Δφ2; ...]\n    \n    let ATA = [[0,0,0], [0,0,0], [0,0,0]]; // 3x3\n    let ATb = [0, 0, 0]; // 3x1\n    \n    for (const neighbor of neighbors) {\n      const dx = neighbor.center.x - cell.center.x;\n      const dy = neighbor.center.y - cell.center.y;\n      const dz = neighbor.center.z - cell.center.z;\n      const dPhi = phi[neighbor.id] - phi[cell.id];\n      \n      // Weight by distance (optional)\n      const w = 1 / Math.sqrt(dx*dx + dy*dy + dz*dz);\n      \n      // Accumulate A^T * A\n      ATA[0][0] += w * dx * dx;\n      ATA[0][1] += w * dx * dy;\n      ATA[0][2] += w * dx * dz;\n      ATA[1][1] += w * dy * dy;\n      ATA[1][2] += w * dy * dz;\n      ATA[2][2] += w * dz * dz;\n      \n      // Accumulate A^T * b\n      ATb[0] += w * dx * dPhi;\n      ATb[1] += w * dy * dPhi;\n      ATb[2] += w * dz * dPhi;\n    }\n    \n    // Symmetry\n    ATA[1][0] = ATA[0][1];\n    ATA[2][0] = ATA[0][2];\n    ATA[2][1] = ATA[1][2];\n    \n    // Solve 3x3 system\n    const grad = this.solve3x3(ATA, ATb);\n    \n    return { x: grad[0], y: grad[1], z: grad[2] };\n  }\n  \n  // Non-orthogonal correction for face gradient\n  faceGradientWithCorrection(phi, face, gradP, gradN) {\n    const { owner, neighbor } = face;\n    \n    // Basic gradient (orthogonal part)\n    const dCF = neighbor.center.subtract(owner.center);\n    const orthoPart = (phi[neighbor.id] - phi[owner.id]) / dCF.magnitude();\n    \n    // Non-orthogonal correction\n    const avgGrad = {\n      x: 0.5 * (gradP.x + gradN.x),\n      y: 0.5 * (gradP.y + gradN.y),\n      z: 0.5 * (gradP.z + gradN.z)\n    };\n    \n    const correction = avgGrad.x * face.delta.x + \n                       avgGrad.y * face.delta.y +\n                       avgGrad.z * face.delta.z;\n    \n    return orthoPart + correction;\n  }\n}"
  },
  {
    "id": 41,
    "question": "What is the Prandtl number and its significance?",
    "answer": "**Prandtl number (Pr)** is the ratio of momentum diffusivity to thermal diffusivity.\n\n**Definition:**\n$$Pr = \\frac{\\nu}{\\alpha} = \\frac{\\mu c_p}{k} = \\frac{\\text{momentum diffusivity}}{\\text{thermal diffusivity}}$$\n\n**Physical meaning:**\n- Pr < 1: Heat diffuses faster than momentum\n- Pr = 1: Equal diffusion rates\n- Pr > 1: Momentum diffuses faster than heat\n\n**Typical values:**\n- Liquid metals: 0.01-0.03\n- Air (gases): ~0.7\n- Water: ~7\n- Oils: 100-40,000\n\n**Significance in CFD:**\n\n**Boundary layer thickness:**\n$$\\frac{\\delta_T}{\\delta} \\approx Pr^{-1/3}$$\n- Pr < 1: Thermal BL thicker\n- Pr > 1: Thermal BL thinner\n\n**Heat transfer correlations:**\n$$Nu = f(Re, Pr)$$\n\n**Turbulent Prandtl number:**\n$$Pr_t = \\frac{\\nu_t}{\\alpha_t} \\approx 0.85-0.9$$\nUsed in turbulence modeling for heat transfer.\n\n**Mesh implications:**\n- Low Pr: Thermal BL needs more resolution\n- High Pr: Velocity BL needs more resolution",
    "example": "// Prandtl number calculations and implications\n\nclass PrandtlAnalysis {\n  constructor(mu, cp, k) {\n    this.mu = mu;   // Dynamic viscosity\n    this.cp = cp;   // Specific heat\n    this.k = k;     // Thermal conductivity\n  }\n  \n  // Prandtl number\n  prandtlNumber() {\n    return (this.mu * this.cp) / this.k;\n  }\n  \n  // Thermal diffusivity\n  thermalDiffusivity(rho) {\n    return this.k / (rho * this.cp);\n  }\n  \n  // Estimate thermal boundary layer thickness\n  thermalBLThickness(velocityBLThickness) {\n    const Pr = this.prandtlNumber();\n    return velocityBLThickness * Math.pow(Pr, -1/3);\n  }\n  \n  // Nusselt number correlations\n  \n  // Flat plate, laminar\n  nusseltFlatPlateLaminar(Re, Pr) {\n    return 0.332 * Math.pow(Re, 0.5) * Math.pow(Pr, 1/3);\n  }\n  \n  // Flat plate, turbulent\n  nusseltFlatPlateTurbulent(Re, Pr) {\n    return 0.0296 * Math.pow(Re, 0.8) * Math.pow(Pr, 1/3);\n  }\n  \n  // Pipe flow, Dittus-Boelter (turbulent)\n  nusseltDittusBoelter(Re, Pr, heating = true) {\n    const n = heating ? 0.4 : 0.3;\n    return 0.023 * Math.pow(Re, 0.8) * Math.pow(Pr, n);\n  }\n  \n  // Mesh resolution guidance\n  recommendMeshResolution(Re, L) {\n    const Pr = this.prandtlNumber();\n    \n    // Velocity boundary layer\n    const deltaV = L / Math.sqrt(Re);\n    \n    // Thermal boundary layer\n    const deltaT = deltaV * Math.pow(Pr, -1/3);\n    \n    return {\n      velocityBLThickness: deltaV,\n      thermalBLThickness: deltaT,\n      criticalBL: Pr > 1 ? 'thermal' : 'velocity',\n      recommendedFirstCell: Math.min(deltaV, deltaT) / 20,\n      note: Pr > 1 ? \n        'Thermal BL thinner - needs finer mesh near wall' :\n        'Velocity BL thinner - resolve momentum first'\n    };\n  }\n}\n\n// Common fluids\nconst fluids = {\n  air_20C: new PrandtlAnalysis(1.81e-5, 1005, 0.026),      // Pr ≈ 0.7\n  water_20C: new PrandtlAnalysis(1.0e-3, 4182, 0.6),       // Pr ≈ 7\n  oil_SAE30: new PrandtlAnalysis(0.29, 1900, 0.145),       // Pr ≈ 3800\n  mercury_20C: new PrandtlAnalysis(1.55e-3, 139, 8.3)      // Pr ≈ 0.026\n};"
  },
  {
    "id": 42,
    "question": "What are residuals and how do you monitor convergence?",
    "answer": "**Residuals** measure how well the discretized equations are satisfied, serving as the primary convergence indicator.\n\n**Definition:**\nFor equation aP·φP = Σ(aN·φN) + b:\n$$R = b + \\sum a_N\\phi_N - a_P\\phi_P$$\n\n**Normalization:**\n- Initial residual (R₀)\n- Inlet flux\n- Field range\n\nNormalized: R/R₀ or R/reference\n\n**Types:**\n- **Scaled residual**: R/ΣaP|φP|\n- **Normalized residual**: R/R₀\n- **RMS residual**: √(ΣR²/N)\n\n**Convergence criteria:**\n- Residuals < tolerance (10⁻⁴ to 10⁻⁶)\n- Residuals plateau (stalled convergence)\n- Monitored quantities stable\n\n**Best practices:**\n1. Monitor all equations\n2. Track integrated quantities (forces, fluxes)\n3. Plot residual history\n4. Check mass/energy balance\n5. Watch for oscillations\n\n**Common issues:**\n- Residuals plateau: Poor mesh, inappropriate model\n- Residuals diverge: CFL too high, mesh quality\n- Oscillating: Under-relaxation needed",
    "example": "// Residual monitoring and convergence checking\n\nclass ConvergenceMonitor {\n  constructor(tolerance = 1e-5, windowSize = 100) {\n    this.tolerance = tolerance;\n    this.windowSize = windowSize;\n    this.history = {\n      continuity: [],\n      momentum_x: [],\n      momentum_y: [],\n      momentum_z: [],\n      energy: [],\n      turbulence: []\n    };\n    this.initialResiduals = {};\n  }\n  \n  // Compute scaled residual for a field\n  computeResidual(A, phi, b) {\n    let sumResidual = 0;\n    let sumNorm = 0;\n    \n    for (let i = 0; i < phi.length; i++) {\n      // R = b - A*phi\n      let Aphi = 0;\n      for (let j = 0; j < phi.length; j++) {\n        Aphi += A[i][j] * phi[j];\n      }\n      const residual = Math.abs(b[i] - Aphi);\n      sumResidual += residual;\n      sumNorm += Math.abs(A[i][i] * phi[i]);\n    }\n    \n    return sumNorm > 0 ? sumResidual / sumNorm : sumResidual;\n  }\n  \n  // Record residual\n  record(equation, residual, iteration) {\n    if (iteration === 0) {\n      this.initialResiduals[equation] = residual;\n    }\n    \n    const normalized = residual / (this.initialResiduals[equation] || 1);\n    this.history[equation].push(normalized);\n  }\n  \n  // Check convergence\n  isConverged() {\n    for (const [eq, hist] of Object.entries(this.history)) {\n      if (hist.length === 0) continue;\n      const current = hist[hist.length - 1];\n      if (current > this.tolerance) {\n        return { converged: false, limiting: eq, residual: current };\n      }\n    }\n    return { converged: true };\n  }\n  \n  // Check if residuals are stalled\n  isStalled() {\n    for (const [eq, hist] of Object.entries(this.history)) {\n      if (hist.length < this.windowSize) continue;\n      \n      const recent = hist.slice(-this.windowSize);\n      const avg = recent.reduce((a, b) => a + b) / recent.length;\n      const std = Math.sqrt(\n        recent.reduce((sum, r) => sum + (r - avg) ** 2, 0) / recent.length\n      );\n      \n      // Stalled if variation < 1% of mean\n      if (std / avg < 0.01 && avg > this.tolerance) {\n        return { stalled: true, equation: eq, level: avg };\n      }\n    }\n    return { stalled: false };\n  }\n  \n  // Print convergence report\n  report(iteration) {\n    console.log(`\\nIteration ${iteration}:`);\n    for (const [eq, hist] of Object.entries(this.history)) {\n      if (hist.length > 0) {\n        const current = hist[hist.length - 1];\n        const status = current < this.tolerance ? '✓' : ' ';\n        console.log(`  ${eq}: ${current.toExponential(3)} ${status}`);\n      }\n    }\n    \n    const conv = this.isConverged();\n    if (conv.converged) {\n      console.log('\\n*** CONVERGED ***');\n    }\n    \n    const stall = this.isStalled();\n    if (stall.stalled) {\n      console.log(`\\n⚠ WARNING: ${stall.equation} appears stalled at ${stall.level.toExponential(2)}`);\n    }\n  }\n}"
  },
  {
    "id": 43,
    "question": "What is the difference between RANS and LES turbulence modeling?",
    "answer": "**RANS (Reynolds-Averaged Navier-Stokes)** and **LES (Large Eddy Simulation)** are fundamentally different approaches to turbulence.\n\n**RANS:**\n- Time-averages all turbulent fluctuations\n- Solves for mean flow quantities\n- Models ALL turbulent scales\n- Steady-state or unsteady (URANS)\n\n**LES:**\n- Spatially filters equations\n- Resolves large energy-containing eddies\n- Models only small subgrid scales\n- Inherently unsteady\n\n| Aspect | RANS | LES |\n|--------|------|-----|\n| Cost | Low | High (10-100x) |\n| Mesh | ~10⁶ cells | ~10⁷-10⁹ cells |\n| Time | Steady possible | Always unsteady |\n| Accuracy | Engineering | Research-grade |\n| Separation | Poor | Good |\n| Universality | Model-dependent | More universal |\n\n**When to use RANS:**\n- Design iterations\n- Attached flows\n- Limited compute resources\n- Steady-state sufficient\n\n**When to use LES:**\n- Massively separated flows\n- Aeroacoustics\n- Combustion, mixing\n- Flow physics research",
    "example": "// RANS vs LES comparison\n\n// RANS: Reynolds decomposition\n// u = U + u' (mean + fluctuation)\n// Solve for U, model <u'v'> (Reynolds stress)\n\nclass RANSSimulation {\n  constructor(mesh, turbModel = 'kEpsilon') {\n    this.mesh = mesh;\n    this.turbModel = turbModel;\n    this.isTransient = false; // Can be steady\n    \n    // Solve for mean quantities\n    this.U = [];  // Mean velocity\n    this.P = [];  // Mean pressure\n    this.k = [];  // Turbulent kinetic energy\n    this.epsilon = []; // Dissipation\n  }\n  \n  // Turbulent viscosity from model\n  turbulentViscosity(cellId) {\n    // k-ε: νt = Cμ * k² / ε\n    return 0.09 * this.k[cellId]**2 / this.epsilon[cellId];\n  }\n  \n  // Reynolds stress (Boussinesq approximation)\n  reynoldsStress(i, j, cellId) {\n    const nuT = this.turbulentViscosity(cellId);\n    const Sij = this.strainRate(i, j, cellId);\n    // -<u'ᵢu'ⱼ> = 2νt*Sij - (2/3)k*δij\n    return 2 * nuT * Sij - (i === j ? 2/3 * this.k[cellId] : 0);\n  }\n}\n\n// LES: Spatial filtering\n// ũ = filtered velocity (resolved)\n// u' = subgrid fluctuation (modeled)\n\nclass LESSimulation {\n  constructor(mesh, sgsModel = 'Smagorinsky') {\n    this.mesh = mesh;\n    this.sgsModel = sgsModel;\n    this.isTransient = true; // Always unsteady!\n    \n    // Solve for filtered (resolved) quantities\n    this.u = [];  // Filtered velocity (time-varying)\n    this.p = [];  // Filtered pressure\n  }\n  \n  // Filter width (typically grid size)\n  filterWidth(cellId) {\n    return Math.pow(this.mesh.cells[cellId].volume, 1/3);\n  }\n  \n  // Subgrid-scale viscosity (Smagorinsky)\n  sgsViscosity(cellId) {\n    const Cs = 0.1; // Smagorinsky constant\n    const delta = this.filterWidth(cellId);\n    const S = this.strainRateMagnitude(cellId);\n    // νsgs = (Cs*Δ)² * |S|\n    return (Cs * delta)**2 * S;\n  }\n  \n  // Check mesh resolution (Pope criterion)\n  checkResolution() {\n    // LES should resolve 80% of turbulent kinetic energy\n    let wellResolved = 0;\n    \n    for (const cell of this.mesh.cells) {\n      const kResolved = this.computeResolvedTKE(cell.id);\n      const kSGS = this.computeSGS_TKE(cell.id);\n      const ratio = kResolved / (kResolved + kSGS);\n      \n      if (ratio > 0.8) wellResolved++;\n    }\n    \n    const percentage = 100 * wellResolved / this.mesh.cells.length;\n    console.log(`${percentage.toFixed(1)}% of cells meet Pope criterion`);\n    return percentage > 80;\n  }\n}\n\n// Cost comparison\nfunction estimateCost(Re, method) {\n  if (method === 'RANS') {\n    // Mesh independent of Re (with wall functions)\n    return { cells: 1e6, timeSteps: 1000, relative: 1 };\n  } else if (method === 'LES') {\n    // Mesh scales with Re\n    const cells = 1e6 * Math.pow(Re / 1e4, 1.8);\n    const timeSteps = 1e4; // Must be unsteady\n    return { cells, timeSteps, relative: cells * timeSteps / 1e9 };\n  }\n}"
  },
  {
    "id": 44,
    "question": "What are initial conditions and how do they affect CFD simulations?",
    "answer": "**Initial conditions (ICs)** specify the state of all variables at the start of a simulation (t = 0).\n\n**Required for:**\n- All transported variables (u, v, w, p, T, k, ε, etc.)\n- Every cell in the domain\n- Transient simulations (essential)\n- Steady simulations (affects convergence)\n\n**Common initialization strategies:**\n\n**1. Uniform field**\n- Set constant values everywhere\n- Simple but may slow convergence\n\n**2. Potential flow**\n- Solve ∇²φ = 0 first\n- Good for external aerodynamics\n\n**3. Previous solution**\n- Restart from coarser mesh or similar case\n- Faster convergence\n\n**4. Mapped field**\n- Interpolate from different geometry\n- Useful for optimization studies\n\n**Turbulence initialization:**\n- k = 1.5(UI)² where I = intensity (1-10%)\n- ε = Cμ^0.75 × k^1.5 / l where l = length scale\n- ω = k^0.5 / (Cμ^0.25 × l)\n\n**Impact:**\n- Wrong ICs → longer convergence\n- Physical ICs → faster, more stable\n- Transient: ICs affect early solution\n- Steady: ICs affect iteration count only",
    "example": "// Initial condition strategies\n\nclass InitialConditions {\n  constructor(mesh) {\n    this.mesh = mesh;\n  }\n  \n  // Uniform initialization\n  uniform(value) {\n    return this.mesh.cells.map(() => value);\n  }\n  \n  // Initialize velocity field\n  initializeVelocity(Uinf = [1, 0, 0]) {\n    return {\n      u: this.uniform(Uinf[0]),\n      v: this.uniform(Uinf[1]),\n      w: this.uniform(Uinf[2])\n    };\n  }\n  \n  // Initialize pressure (usually zero gauge)\n  initializePressure(pRef = 0) {\n    return this.uniform(pRef);\n  }\n  \n  // Initialize turbulence quantities\n  initializeTurbulence(Uref, intensity = 0.05, lengthScale = 0.1) {\n    // Turbulent kinetic energy\n    // k = 1.5 * (U * I)²\n    const Umag = Math.sqrt(Uref[0]**2 + Uref[1]**2 + Uref[2]**2);\n    const k = 1.5 * Math.pow(Umag * intensity, 2);\n    \n    // Dissipation rate (k-ε)\n    // ε = Cμ^0.75 * k^1.5 / l\n    const Cmu = 0.09;\n    const epsilon = Math.pow(Cmu, 0.75) * Math.pow(k, 1.5) / lengthScale;\n    \n    // Specific dissipation (k-ω)\n    // ω = k^0.5 / (Cμ^0.25 * l)\n    const omega = Math.sqrt(k) / (Math.pow(Cmu, 0.25) * lengthScale);\n    \n    // Turbulent viscosity ratio\n    const nuTRatio = k / epsilon / 1.5e-5; // Assuming air\n    \n    console.log('Turbulence initialization:');\n    console.log(`  Intensity: ${(intensity*100).toFixed(1)}%`);\n    console.log(`  k = ${k.toExponential(3)} m²/s²`);\n    console.log(`  ε = ${epsilon.toExponential(3)} m²/s³`);\n    console.log(`  ω = ${omega.toExponential(3)} 1/s`);\n    console.log(`  νt/ν ≈ ${nuTRatio.toFixed(0)}`);\n    \n    return {\n      k: this.uniform(k),\n      epsilon: this.uniform(epsilon),\n      omega: this.uniform(omega)\n    };\n  }\n  \n  // Potential flow initialization\n  initializeFromPotential(boundaries) {\n    // Solve Laplace equation: ∇²φ = 0\n    // Then u = ∇φ\n    const phi = this.solveLaplace(boundaries);\n    return this.gradientField(phi);\n  }\n  \n  // Initialize from previous solution (restart)\n  initializeFromRestart(restartFile) {\n    const data = this.readRestartFile(restartFile);\n    \n    // Interpolate if mesh is different\n    if (data.meshSize !== this.mesh.cells.length) {\n      console.log('Interpolating from different mesh...');\n      return this.interpolateFields(data);\n    }\n    \n    return data.fields;\n  }\n  \n  // Check initial condition quality\n  validateIC(fields) {\n    const issues = [];\n    \n    // Check for NaN/Inf\n    for (const [name, field] of Object.entries(fields)) {\n      if (field.some(v => !isFinite(v))) {\n        issues.push(`${name} contains NaN or Inf`);\n      }\n    }\n    \n    // Check turbulence realizability\n    if (fields.k && fields.k.some(k => k < 0)) {\n      issues.push('Negative turbulent kinetic energy');\n    }\n    \n    // Check velocity divergence\n    const maxDiv = this.checkDivergence(fields.u, fields.v, fields.w);\n    if (maxDiv > 1e-6) {\n      issues.push(`High initial divergence: ${maxDiv.toExponential(2)}`);\n    }\n    \n    return { valid: issues.length === 0, issues };\n  }\n}"
  }
]
