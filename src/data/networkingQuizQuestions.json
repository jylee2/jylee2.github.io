[
  {
    "id": 1,
    "question": "What is the OSI model and what are its seven layers?",
    "answer": "The **OSI (Open Systems Interconnection) model** is a conceptual framework that standardizes network communication into seven layers.\n\n**Layers (bottom to top):**\n\n1. **Physical** - Bits, cables, signals, hardware\n2. **Data Link** - Frames, MAC addresses, switches, error detection\n3. **Network** - Packets, IP addresses, routing\n4. **Transport** - Segments, TCP/UDP, ports, flow control\n5. **Session** - Connection management, authentication\n6. **Presentation** - Data formatting, encryption, compression\n7. **Application** - HTTP, FTP, SMTP, user-facing protocols\n\n**Mnemonic**: \"Please Do Not Throw Sausage Pizza Away\"\n\n**TCP/IP model** simplifies to 4 layers: Network Access, Internet, Transport, Application",
    "example": "Data flow through OSI layers:\n\nSending \"Hello\" via HTTP:\n\n7. Application:  HTTP request created\n                 GET /page HTTP/1.1\n\n6. Presentation: Data encoded (UTF-8), possibly compressed\n\n5. Session:      Session established/maintained\n\n4. Transport:    TCP segment created\n                 [Src Port: 54321 | Dst Port: 80 | Seq# | Data]\n\n3. Network:      IP packet created\n                 [Src IP: 192.168.1.5 | Dst IP: 93.184.216.34 | TCP Segment]\n\n2. Data Link:    Ethernet frame created\n                 [Src MAC | Dst MAC | IP Packet | CRC]\n\n1. Physical:     Converted to electrical signals/light pulses\n                 Transmitted over wire/fiber/wireless\n\nReceiver reverses the process (decapsulation)"
  },
  {
    "id": 2,
    "question": "What is the difference between TCP and UDP?",
    "answer": "**TCP (Transmission Control Protocol):**\n- Connection-oriented (3-way handshake)\n- Reliable delivery (acknowledgments, retransmission)\n- Ordered delivery (sequence numbers)\n- Flow control and congestion control\n- Higher overhead, slower\n- Use cases: HTTP, FTP, SMTP, SSH\n\n**UDP (User Datagram Protocol):**\n- Connectionless (no handshake)\n- Unreliable (no acknowledgments)\n- No ordering guarantee\n- No flow control\n- Low overhead, faster\n- Use cases: DNS, DHCP, VoIP, video streaming, gaming\n\n**Key tradeoff**: TCP = reliability, UDP = speed\n\n**Header size**: TCP = 20-60 bytes, UDP = 8 bytes",
    "example": "TCP 3-Way Handshake:\n\nClient                          Server\n   |                               |\n   |-------- SYN (seq=100) ------->|\n   |                               |\n   |<-- SYN-ACK (seq=300,ack=101) -|\n   |                               |\n   |-------- ACK (ack=301) ------->|\n   |                               |\n   |===== Connection Established ===|\n\nTCP Header (20 bytes minimum):\n+------------------+------------------+\n|   Source Port    |    Dest Port     |\n+------------------+------------------+\n|            Sequence Number          |\n+-----------------+-------------------+\n|         Acknowledgment Number       |\n+------+------+------+----------------+\n|Offset|Reserv|Flags |    Window      |\n+------+------+------+----------------+\n|    Checksum      |  Urgent Pointer  |\n+------------------+------------------+\n\nUDP Header (8 bytes):\n+------------------+------------------+\n|   Source Port    |    Dest Port     |\n+------------------+------------------+\n|     Length       |    Checksum      |\n+------------------+------------------+"
  },
  {
    "id": 3,
    "question": "How does DNS work?",
    "answer": "**DNS (Domain Name System)** translates human-readable domain names to IP addresses.\n\n**Resolution process:**\n1. Browser checks local cache\n2. OS checks hosts file and local DNS cache\n3. Query sent to recursive resolver (ISP's DNS)\n4. Resolver checks its cache\n5. If not cached, iterative queries to:\n   - Root nameserver → returns TLD server\n   - TLD nameserver (.com) → returns authoritative server\n   - Authoritative nameserver → returns IP address\n6. Response cached at each level (TTL-based)\n\n**Record types:**\n- **A**: Domain → IPv4 address\n- **AAAA**: Domain → IPv6 address\n- **CNAME**: Alias → canonical name\n- **MX**: Mail exchange servers\n- **NS**: Nameservers for domain\n- **TXT**: Text records (SPF, DKIM, verification)",
    "example": "DNS Query for www.example.com:\n\nUser                Recursive         Root    .com TLD   Authoritative\n  |                  Resolver          NS        NS          NS\n  |                     |              |         |           |\n  |-- Query: A? ------->|              |         |           |\n  |   www.example.com   |              |         |           |\n  |                     |-- Where is   |         |           |\n  |                     |   .com? ---->|         |           |\n  |                     |<- .com NS ---|         |           |\n  |                     |              |         |           |\n  |                     |-- Where is example.com? ->|        |\n  |                     |<- example.com NS ---------|        |\n  |                     |              |         |           |\n  |                     |-- A record for www.example.com? -->|\n  |                     |<- 93.184.216.34 -------------------|\n  |                     |              |         |           |\n  |<- 93.184.216.34 ----|              |         |           |\n\nCommon DNS commands:\n$ nslookup example.com\n$ dig example.com A\n$ dig example.com MX\n$ host example.com"
  },
  {
    "id": 4,
    "question": "What is an IP address and what's the difference between IPv4 and IPv6?",
    "answer": "An **IP address** is a unique identifier for a device on a network.\n\n**IPv4:**\n- 32-bit address (4 octets)\n- Format: 192.168.1.1\n- ~4.3 billion addresses (2³²)\n- Running out of addresses\n- Uses NAT for address conservation\n- Header: 20-60 bytes\n\n**IPv6:**\n- 128-bit address (8 groups of 4 hex digits)\n- Format: 2001:0db8:85a3:0000:0000:8a2e:0370:7334\n- 340 undecillion addresses (2¹²⁸)\n- Built-in security (IPsec)\n- Simplified header: 40 bytes fixed\n- No NAT needed, no broadcast\n\n**Special addresses:**\n- 127.0.0.1 / ::1 - Loopback\n- 10.x.x.x, 172.16-31.x.x, 192.168.x.x - Private (IPv4)\n- fe80:: - Link-local (IPv6)",
    "example": "IPv4 Address Classes (historical):\n\nClass A: 1.0.0.0   - 126.255.255.255  (/8, 16M hosts)\nClass B: 128.0.0.0 - 191.255.255.255  (/16, 65K hosts)\nClass C: 192.0.0.0 - 223.255.255.255  (/24, 254 hosts)\nClass D: 224.0.0.0 - 239.255.255.255  (Multicast)\nClass E: 240.0.0.0 - 255.255.255.255  (Reserved)\n\nCIDR Notation (modern):\n192.168.1.0/24 = 192.168.1.0 - 192.168.1.255 (256 addresses)\n10.0.0.0/8     = 10.0.0.0 - 10.255.255.255 (16M addresses)\n\nSubnet Mask calculation:\n/24 = 255.255.255.0   = 11111111.11111111.11111111.00000000\n/16 = 255.255.0.0     = 11111111.11111111.00000000.00000000\n/28 = 255.255.255.240 = 11111111.11111111.11111111.11110000\n\nIPv6 shortening:\n2001:0db8:0000:0000:0000:0000:0000:0001\n→ 2001:db8::1  (remove leading zeros, :: for consecutive zeros)"
  },
  {
    "id": 5,
    "question": "What is HTTP and how does it work?",
    "answer": "**HTTP (Hypertext Transfer Protocol)** is an application-layer protocol for transmitting hypermedia documents.\n\n**Characteristics:**\n- Stateless (each request independent)\n- Text-based protocol\n- Request-response model\n- Default port: 80 (HTTP), 443 (HTTPS)\n\n**HTTP Methods:**\n- **GET**: Retrieve resource\n- **POST**: Submit data, create resource\n- **PUT**: Update/replace resource\n- **PATCH**: Partial update\n- **DELETE**: Remove resource\n- **HEAD**: GET without body\n- **OPTIONS**: Supported methods\n\n**Status codes:**\n- 1xx: Informational\n- 2xx: Success (200 OK, 201 Created)\n- 3xx: Redirection (301, 302, 304)\n- 4xx: Client error (400, 401, 403, 404)\n- 5xx: Server error (500, 502, 503)",
    "example": "HTTP Request:\n\nGET /api/users/123 HTTP/1.1\nHost: api.example.com\nUser-Agent: Mozilla/5.0\nAccept: application/json\nAuthorization: Bearer eyJhbGc...\nConnection: keep-alive\n\nHTTP Response:\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 82\nCache-Control: max-age=3600\nDate: Mon, 15 Jan 2024 10:30:00 GMT\n\n{\n  \"id\": 123,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n\nHTTP Versions:\n- HTTP/1.0: New connection per request\n- HTTP/1.1: Keep-alive, pipelining, chunked transfer\n- HTTP/2: Binary, multiplexing, server push, header compression\n- HTTP/3: QUIC (UDP-based), faster handshake"
  },
  {
    "id": 6,
    "question": "What is HTTPS and how does TLS work?",
    "answer": "**HTTPS** is HTTP over TLS (Transport Layer Security), providing encrypted communication.\n\n**TLS provides:**\n- **Confidentiality**: Encryption prevents eavesdropping\n- **Integrity**: MAC ensures data isn't tampered\n- **Authentication**: Certificates verify server identity\n\n**TLS Handshake (TLS 1.3 simplified):**\n1. Client Hello: Supported ciphers, random, key share\n2. Server Hello: Chosen cipher, certificate, key share\n3. Both compute shared secret (ECDHE)\n4. Finished messages verify handshake\n5. Application data encrypted\n\n**Certificate chain:**\n- Root CA (trusted, in browser/OS)\n- Intermediate CA\n- Server certificate\n\n**Key exchange**: ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)\n**Encryption**: AES-GCM, ChaCha20-Poly1305",
    "example": "TLS 1.3 Handshake (1-RTT):\n\nClient                                    Server\n   |                                         |\n   |------ Client Hello -------------------->|\n   |       + key_share                       |\n   |       + supported_versions              |\n   |       + signature_algorithms            |\n   |                                         |\n   |<----- Server Hello ---------------------|\n   |       + key_share                       |\n   |<----- EncryptedExtensions --------------|\n   |<----- Certificate ----------------------|\n   |<----- CertificateVerify ----------------|\n   |<----- Finished -------------------------|\n   |                                         |\n   |------ Finished ------------------------>|\n   |                                         |\n   |========= Application Data =============|\n\nCertificate verification:\n1. Check certificate not expired\n2. Check domain matches certificate\n3. Verify signature chain to trusted root\n4. Check certificate not revoked (OCSP/CRL)\n\n# View certificate\n$ openssl s_client -connect example.com:443\n$ curl -v https://example.com 2>&1 | grep -A6 'Server certificate'"
  },
  {
    "id": 7,
    "question": "What is NAT and why is it used?",
    "answer": "**NAT (Network Address Translation)** maps private IP addresses to public IP addresses, allowing multiple devices to share a single public IP.\n\n**Types of NAT:**\n\n**Static NAT**: One-to-one mapping\n- Private IP always maps to same public IP\n- Used for servers needing consistent external address\n\n**Dynamic NAT**: Many-to-many mapping\n- Pool of public IPs assigned as needed\n- Connection-based allocation\n\n**PAT/NAPT (Port Address Translation)**: Many-to-one\n- Most common (home routers)\n- Uses port numbers to distinguish connections\n- Single public IP serves many devices\n\n**Benefits:**\n- Conserves IPv4 addresses\n- Provides basic security (hides internal structure)\n- Allows private addressing flexibility\n\n**Drawbacks:**\n- Breaks end-to-end connectivity\n- Complicates P2P, VoIP, gaming\n- Requires port forwarding for inbound connections",
    "example": "PAT Example (Home Router):\n\nInternal Network          Router (NAT)           Internet\n                         Public: 203.0.113.5\n\nPC1: 192.168.1.10:54321 ──┐\n                          ├── 203.0.113.5:10001 ──> Server A\nPC2: 192.168.1.11:54321 ──┤\n                          ├── 203.0.113.5:10002 ──> Server A\nPC3: 192.168.1.12:80    ──┘\n                          └── 203.0.113.5:10003 ──> Server B\n\nNAT Translation Table:\n+----------------+------------+----------------+------------+\n| Internal IP    | Int Port   | External IP    | Ext Port   |\n+----------------+------------+----------------+------------+\n| 192.168.1.10   | 54321      | 203.0.113.5    | 10001      |\n| 192.168.1.11   | 54321      | 203.0.113.5    | 10002      |\n| 192.168.1.12   | 80         | 203.0.113.5    | 10003      |\n+----------------+------------+----------------+------------+\n\nPort Forwarding (for hosting a server):\nExternal 203.0.113.5:8080 → Internal 192.168.1.100:80"
  },
  {
    "id": 8,
    "question": "What is a subnet and how does subnetting work?",
    "answer": "**Subnetting** divides a network into smaller, manageable sub-networks (subnets).\n\n**Subnet mask**: Defines which bits are network vs host\n- 1 bits = network portion\n- 0 bits = host portion\n\n**CIDR notation**: /prefix indicates network bits\n- /24 = 24 network bits, 8 host bits = 256 addresses\n- /25 = 25 network bits, 7 host bits = 128 addresses\n\n**Benefits:**\n- Reduces broadcast domain size\n- Improves security (isolation)\n- Better IP address management\n- Enables routing efficiency\n\n**Calculations:**\n- Hosts per subnet: 2^(host bits) - 2\n- Subtract 2 for network address and broadcast address\n- Number of subnets: 2^(borrowed bits)",
    "example": "Subnetting 192.168.1.0/24 into 4 subnets:\n\nOriginal: 192.168.1.0/24 (256 addresses)\nNeed 4 subnets → borrow 2 bits → /26\n\nSubnet 1: 192.168.1.0/26\n  Network:   192.168.1.0\n  Usable:    192.168.1.1 - 192.168.1.62\n  Broadcast: 192.168.1.63\n  Hosts: 62\n\nSubnet 2: 192.168.1.64/26\n  Network:   192.168.1.64\n  Usable:    192.168.1.65 - 192.168.1.126\n  Broadcast: 192.168.1.127\n  Hosts: 62\n\nSubnet 3: 192.168.1.128/26\n  Network:   192.168.1.128\n  Usable:    192.168.1.129 - 192.168.1.190\n  Broadcast: 192.168.1.191\n  Hosts: 62\n\nSubnet 4: 192.168.1.192/26\n  Network:   192.168.1.192\n  Usable:    192.168.1.193 - 192.168.1.254\n  Broadcast: 192.168.1.255\n  Hosts: 62\n\nBinary breakdown for /26:\n11111111.11111111.11111111.11000000 = 255.255.255.192"
  },
  {
    "id": 9,
    "question": "What is ARP and how does it work?",
    "answer": "**ARP (Address Resolution Protocol)** maps IP addresses to MAC addresses on a local network.\n\n**Why needed:**\n- IP addresses used for routing between networks\n- MAC addresses used for delivery within a network\n- Need to find MAC address for IP on same subnet\n\n**Process:**\n1. Device checks ARP cache for IP→MAC mapping\n2. If not found, broadcasts ARP request: \"Who has IP X?\"\n3. Device with that IP responds with its MAC address\n4. Sender caches the mapping (ARP table)\n5. Frame sent to that MAC address\n\n**ARP types:**\n- **ARP Request**: Broadcast to find MAC\n- **ARP Reply**: Unicast response with MAC\n- **Gratuitous ARP**: Announce own IP (detect conflicts)\n- **Proxy ARP**: Router answers for another network\n\n**Security concern**: ARP spoofing (no authentication)",
    "example": "ARP Process:\n\nPC A (192.168.1.10) wants to send to PC B (192.168.1.20)\n\n1. PC A checks ARP cache:\n   $ arp -a\n   (empty or no entry for 192.168.1.20)\n\n2. PC A broadcasts ARP Request:\n   +--------------------------------------------------+\n   | Ethernet Header                                  |\n   | Src MAC: AA:AA:AA:AA:AA:AA                       |\n   | Dst MAC: FF:FF:FF:FF:FF:FF (broadcast)           |\n   +--------------------------------------------------+\n   | ARP Payload                                      |\n   | Sender MAC: AA:AA:AA:AA:AA:AA                    |\n   | Sender IP:  192.168.1.10                         |\n   | Target MAC: 00:00:00:00:00:00 (unknown)          |\n   | Target IP:  192.168.1.20                         |\n   +--------------------------------------------------+\n\n3. PC B responds (unicast):\n   Sender MAC: BB:BB:BB:BB:BB:BB\n   Sender IP:  192.168.1.20\n\n4. PC A updates ARP cache:\n   $ arp -a\n   192.168.1.20  BB:BB:BB:BB:BB:BB\n\n5. PC A sends frame to BB:BB:BB:BB:BB:BB"
  },
  {
    "id": 10,
    "question": "What is DHCP and how does it work?",
    "answer": "**DHCP (Dynamic Host Configuration Protocol)** automatically assigns IP addresses and network configuration to devices.\n\n**Information provided:**\n- IP address\n- Subnet mask\n- Default gateway\n- DNS servers\n- Lease duration\n\n**DORA Process:**\n1. **Discover**: Client broadcasts \"I need an IP\"\n2. **Offer**: Server offers available IP address\n3. **Request**: Client requests offered IP\n4. **Acknowledge**: Server confirms assignment\n\n**Lease:**\n- IP assigned for limited time\n- Client must renew before expiry\n- Renewal at 50% and 87.5% of lease time\n\n**Ports**: Server 67, Client 68 (UDP)\n\n**DHCP Relay**: Forwards requests across subnets to central DHCP server",
    "example": "DHCP DORA Process:\n\nClient                                  DHCP Server\n   |                                         |\n   |---- DHCPDISCOVER (broadcast) ---------->|\n   |     Src: 0.0.0.0                        |\n   |     Dst: 255.255.255.255                |\n   |     \"I need an IP address\"              |\n   |                                         |\n   |<--- DHCPOFFER (broadcast/unicast) ------|\n   |     \"You can have 192.168.1.100\"        |\n   |     Subnet: 255.255.255.0               |\n   |     Gateway: 192.168.1.1                |\n   |     DNS: 8.8.8.8                        |\n   |     Lease: 24 hours                     |\n   |                                         |\n   |---- DHCPREQUEST (broadcast) ----------->|\n   |     \"I want 192.168.1.100\"              |\n   |                                         |\n   |<--- DHCPACK (unicast) ------------------|\n   |     \"Confirmed, it's yours\"             |\n   |                                         |\n\nLease Renewal Timeline (24-hour lease):\n- T1 (50%): Attempt renewal at 12 hours\n- T2 (87.5%): Broadcast renewal at 21 hours\n- Expiry: Must release IP at 24 hours"
  },
  {
    "id": 11,
    "question": "What is a firewall and how does it work?",
    "answer": "A **firewall** monitors and controls network traffic based on security rules, acting as a barrier between trusted and untrusted networks.\n\n**Types:**\n\n**Packet Filtering:**\n- Examines packet headers (IP, port, protocol)\n- Stateless, fast, simple rules\n- Layer 3-4\n\n**Stateful Inspection:**\n- Tracks connection state\n- Allows return traffic for established connections\n- More secure than packet filtering\n\n**Application Layer (WAF):**\n- Inspects application data (HTTP)\n- Detects XSS, SQL injection\n- Layer 7\n\n**Next-Gen (NGFW):**\n- Deep packet inspection\n- Intrusion prevention\n- Application awareness\n- User identity integration\n\n**Common rules:**\n- Allow/deny by IP, port, protocol\n- Default deny (whitelist) vs default allow (blacklist)",
    "example": "Firewall Rule Examples (iptables):\n\n# Default policies - deny all incoming\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow established connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH from specific IP\niptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT\n\n# Allow HTTP/HTTPS from anywhere\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Allow ping (ICMP)\niptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT\n\n# Block specific IP\niptables -A INPUT -s 10.0.0.5 -j DROP\n\n# Log dropped packets\niptables -A INPUT -j LOG --log-prefix \"DROPPED: \"\n\n# Stateful rule logic:\n# Outbound: PC → Server (NEW) → ALLOWED\n# Inbound:  Server → PC (ESTABLISHED) → ALLOWED\n# Inbound:  Attacker → PC (NEW) → BLOCKED"
  },
  {
    "id": 12,
    "question": "What is the difference between a switch and a router?",
    "answer": "**Switch (Layer 2):**\n- Connects devices within same network (LAN)\n- Uses MAC addresses to forward frames\n- Maintains MAC address table\n- Creates separate collision domains\n- Operates at Data Link layer\n- Fast, hardware-based forwarding\n- Cannot route between subnets\n\n**Router (Layer 3):**\n- Connects different networks\n- Uses IP addresses to route packets\n- Maintains routing table\n- Creates separate broadcast domains\n- Operates at Network layer\n- Makes forwarding decisions based on routes\n- Performs NAT, firewall, QoS\n\n**Layer 3 Switch:**\n- Combines switch and router functionality\n- Wire-speed routing between VLANs\n- Hardware-based routing\n\n**Key difference**: Switches forward within a network; routers forward between networks",
    "example": "Network topology:\n\n       Internet\n           |\n      [Router]  ← Routes between networks, NAT\n           |      IP: 192.168.1.1 (internal)\n           |          203.0.113.5 (external)\n           |\n      [Switch]  ← Forwards frames within LAN\n      /   |   \\\n    PC1  PC2  PC3\n    .10  .11  .12\n\nSwitch MAC Address Table:\n+------------------+------+\n| MAC Address      | Port |\n+------------------+------+\n| AA:AA:AA:AA:AA:01| 1    |\n| AA:AA:AA:AA:AA:02| 2    |\n| AA:AA:AA:AA:AA:03| 3    |\n+------------------+------+\n\nRouter Routing Table:\n+----------------+----------------+-------------+\n| Destination    | Next Hop       | Interface   |\n+----------------+----------------+-------------+\n| 192.168.1.0/24 | Connected      | eth0        |\n| 0.0.0.0/0      | 203.0.113.1    | eth1 (WAN)  |\n+----------------+----------------+-------------+\n\nPacket flow: PC1 → Google\n1. PC1 → Switch (MAC lookup) → Router\n2. Router: dest not local → route to default gateway\n3. Router performs NAT → sends to ISP"
  },
  {
    "id": 13,
    "question": "What is a VLAN and why is it used?",
    "answer": "**VLAN (Virtual LAN)** logically segments a physical network into separate broadcast domains.\n\n**Benefits:**\n- **Security**: Isolate sensitive traffic\n- **Performance**: Reduce broadcast traffic\n- **Flexibility**: Group by function, not location\n- **Cost**: Single switch serves multiple networks\n\n**How it works:**\n- Switch ports assigned to VLANs\n- Traffic tagged with VLAN ID (802.1Q)\n- Frames only forwarded within same VLAN\n- Inter-VLAN routing requires Layer 3 device\n\n**Types of ports:**\n- **Access port**: Connects to end device, single VLAN\n- **Trunk port**: Carries multiple VLANs between switches\n\n**802.1Q tag**: 4 bytes added to Ethernet frame\n- TPID (2 bytes): 0x8100\n- TCI (2 bytes): Priority + VLAN ID (12 bits = 4094 VLANs)",
    "example": "VLAN Example:\n\n          [Router]\n              |\n         Trunk port (carries all VLANs)\n              |\n          [Switch]\n         /   |   \\\n       P1   P2   P3   P4   P5   P6\n       |    |    |    |    |    |\n      PC1  PC2  PC3  PC4  PC5  PC6\n\nVLAN Assignment:\n- VLAN 10 (Sales):      Ports 1, 2\n- VLAN 20 (Engineering): Ports 3, 4\n- VLAN 30 (HR):          Ports 5, 6\n\nBroadcast domains:\n- PC1 broadcasts → only PC2 receives (VLAN 10)\n- PC3 broadcasts → only PC4 receives (VLAN 20)\n- PC5 broadcasts → only PC6 receives (VLAN 30)\n\n802.1Q Tagged Frame:\n+----------+--------+----------+---------+------+-----+\n| Dest MAC | Src MAC| 802.1Q   | EtherType| Data | FCS |\n|          |        | Tag      |         |      |     |\n+----------+--------+----------+---------+------+-----+\n                    |\n                    v\n              +----+------+\n              |TPID| TCI  |\n              |8100|VID:10|\n              +----+------+"
  },
  {
    "id": 14,
    "question": "What is SMTP and how does email delivery work?",
    "answer": "**SMTP (Simple Mail Transfer Protocol)** is used for sending and relaying email messages.\n\n**Ports:**\n- 25: Server-to-server relay\n- 587: Client submission (with auth)\n- 465: SMTPS (deprecated, but used)\n\n**Email delivery flow:**\n1. Sender's MUA (Mail User Agent) → Sender's MTA (submission)\n2. Sender's MTA looks up recipient's MX record\n3. Sender's MTA → Recipient's MTA (relay)\n4. Recipient's MTA → Recipient's mailbox\n5. Recipient's MUA retrieves via IMAP/POP3\n\n**Related protocols:**\n- **IMAP** (143/993): Retrieve mail, keep on server\n- **POP3** (110/995): Download mail, delete from server\n\n**Security:**\n- STARTTLS: Upgrade to encrypted connection\n- SPF, DKIM, DMARC: Prevent spoofing",
    "example": "SMTP Session:\n\nClient                              Server\n   |                                   |\n   |<------ 220 mail.example.com ------|  Server ready\n   |                                   |\n   |------- EHLO client.com ---------->|  Client greeting\n   |<------ 250-STARTTLS --------------|  Server capabilities\n   |                                   |\n   |------- STARTTLS ----------------->|  Upgrade to TLS\n   |<------ 220 Ready -----------------|\n   |                                   |\n   |------- AUTH LOGIN --------------->|  Authentication\n   |<------ 334 Username --------------|  (base64)\n   |------- dXNlcm5hbWU= ------------->|\n   |<------ 334 Password --------------|  \n   |------- cGFzc3dvcmQ= ------------->|\n   |<------ 235 Authenticated ---------|  \n   |                                   |\n   |------- MAIL FROM:<a@x.com> ------>|  Sender\n   |<------ 250 OK --------------------|  \n   |                                   |\n   |------- RCPT TO:<b@y.com> -------->|  Recipient\n   |<------ 250 OK --------------------|  \n   |                                   |\n   |------- DATA --------------------->|  Start message\n   |<------ 354 Start mail input ------|  \n   |------- Subject: Hello             |  \n   |------- From: a@x.com              |  \n   |-------                            |  \n   |------- Message body here          |  \n   |------- . ------------------------>|  End with single dot\n   |<------ 250 Message accepted ------|  \n   |                                   |\n   |------- QUIT --------------------->|  \n   |<------ 221 Bye -------------------|"
  },
  {
    "id": 15,
    "question": "What is FTP and what are its modes?",
    "answer": "**FTP (File Transfer Protocol)** transfers files between client and server.\n\n**Ports:**\n- 21: Control connection (commands)\n- 20: Data connection (active mode)\n- Dynamic: Data connection (passive mode)\n\n**Modes:**\n\n**Active Mode:**\n- Client opens random port, tells server\n- Server connects FROM port 20 TO client's port\n- Problem: Client firewall may block incoming\n\n**Passive Mode (PASV):**\n- Client requests passive mode\n- Server opens random port, tells client\n- Client connects TO server's port\n- Firewall-friendly (all connections outbound)\n\n**Security:**\n- FTP sends credentials in plaintext\n- **FTPS**: FTP over TLS (ports 990/989)\n- **SFTP**: SSH File Transfer (port 22, different protocol)\n\n**Common commands:** USER, PASS, LIST, RETR, STOR, PWD, CWD",
    "example": "FTP Active vs Passive Mode:\n\nActive Mode:\nClient (192.168.1.10)              Server (203.0.113.5)\n    |                                   |\n    |-----> PORT 192,168,1,10,4,1 ----->|  Client: \"Connect to me on 1025\"\n    |       (port = 4*256+1 = 1025)     |  \n    |                                   |\n    |<----- Data connection <-----------| Server connects FROM :20\n    |       FROM :20 TO :1025           | TO client :1025\n    |                                   |\n    Problem: Client firewall blocks incoming connection!\n\nPassive Mode:\nClient (192.168.1.10)              Server (203.0.113.5)\n    |                                   |\n    |-----> PASV ---------------------->|  Client: \"Give me a port\"\n    |                                   |\n    |<----- 227 (203,0,113,5,39,5) -----|  Server: \"Connect to 9989\"\n    |       (port = 39*256+5 = 9989)    |  \n    |                                   |\n    |-----> Data connection ----------->|  Client connects TO :9989\n    |       TO :9989                    |  \n    |                                   |\n    Works: All connections are outbound from client!\n\nFTP Commands:\n$ ftp ftp.example.com\nftp> user username\nftp> pass password\nftp> ls              # LIST\nftp> get file.txt    # RETR\nftp> put local.txt   # STOR\nftp> bye             # QUIT"
  },
  {
    "id": 16,
    "question": "What is a load balancer and how does it work?",
    "answer": "A **load balancer** distributes incoming traffic across multiple servers to ensure availability and performance.\n\n**Types:**\n\n**Layer 4 (Transport):**\n- Routes based on IP and port\n- Fast, simple, no content inspection\n- TCP/UDP level\n\n**Layer 7 (Application):**\n- Routes based on content (URL, headers, cookies)\n- Can do SSL termination\n- More intelligent routing\n- HTTP/HTTPS level\n\n**Algorithms:**\n- **Round Robin**: Sequential distribution\n- **Least Connections**: Send to least busy server\n- **IP Hash**: Same client → same server\n- **Weighted**: Distribute by server capacity\n- **Least Response Time**: Fastest server\n\n**Health checks**: Monitors server status, removes unhealthy servers\n\n**Session persistence**: Sticky sessions keep user on same server",
    "example": "Load Balancer Setup:\n\n                    [Load Balancer]\n                    VIP: 203.0.113.10\n                          |\n            +-------------+-------------+\n            |             |             |\n        [Server 1]    [Server 2]    [Server 3]\n        10.0.0.1      10.0.0.2      10.0.0.3\n\nRound Robin distribution:\nRequest 1 → Server 1\nRequest 2 → Server 2\nRequest 3 → Server 3\nRequest 4 → Server 1\n...\n\nLayer 7 Content-Based Routing:\n\n/api/*     → API Server Pool\n/images/*  → Static Content Pool (CDN)\n/app/*     → Application Server Pool\n\nNginx Load Balancer Config:\nupstream backend {\n    least_conn;                    # Algorithm\n    server 10.0.0.1 weight=3;      # Higher weight\n    server 10.0.0.2 weight=2;\n    server 10.0.0.3 weight=1;\n    server 10.0.0.4 backup;        # Only if others fail\n}\n\nserver {\n    listen 80;\n    location / {\n        proxy_pass http://backend;\n        health_check interval=5s;\n    }\n}"
  },
  {
    "id": 17,
    "question": "What is a CDN and how does it work?",
    "answer": "**CDN (Content Delivery Network)** is a distributed network of servers that delivers content from locations closer to users.\n\n**How it works:**\n1. Content cached on edge servers worldwide\n2. DNS routes users to nearest edge server\n3. Edge server serves cached content\n4. Cache miss → fetch from origin, cache it\n\n**Benefits:**\n- **Reduced latency**: Closer servers = faster\n- **Reduced origin load**: Edge handles most traffic\n- **DDoS protection**: Distributed infrastructure\n- **High availability**: Multiple points of presence\n- **Bandwidth savings**: Origin serves less traffic\n\n**Cached content:**\n- Static files (images, CSS, JS)\n- Videos, downloads\n- API responses (with care)\n\n**Cache control:**\n- TTL (Time To Live)\n- Cache-Control headers\n- Purge/invalidation mechanisms",
    "example": "CDN Request Flow:\n\nUser in Tokyo                        Origin in New York\n     |                                      |\n     |--- DNS: cdn.example.com ------------>|\n     |                                      |\n     |<-- Nearest edge: tokyo.cdn.net ------|  (GeoDNS)\n     |                                      |\n     |--- GET /image.jpg -----> [Tokyo Edge]\n     |                               |\n     |                          Cache HIT?\n     |                          /        \\\n     |                        YES         NO\n     |                         |           |\n     |<-- 200 (from cache) ----|           |\n     |                                     |\n     |                    [Tokyo Edge] ---> Origin\n     |                         |      GET /image.jpg\n     |                         |<--------- |\n     |                    (cache response)\n     |<-- 200 (from origin) ---|           |\n\nCache-Control Headers:\nCache-Control: public, max-age=31536000  # Cache 1 year\nCache-Control: private, no-cache         # Don't cache\nCache-Control: max-age=3600, s-maxage=86400  # Different TTL for CDN\n\nCDN Providers: Cloudflare, AWS CloudFront, Akamai, Fastly"
  },
  {
    "id": 18,
    "question": "What is a VPN and how does it work?",
    "answer": "**VPN (Virtual Private Network)** creates an encrypted tunnel over a public network, allowing secure remote access to private networks.\n\n**Types:**\n\n**Remote Access VPN:**\n- Individual connects to corporate network\n- Client software on user device\n- Common protocols: OpenVPN, WireGuard, IKEv2\n\n**Site-to-Site VPN:**\n- Connects two networks\n- Router/firewall handles VPN\n- Common protocols: IPsec, GRE\n\n**How it works:**\n1. VPN client authenticates to VPN server\n2. Encrypted tunnel established\n3. Traffic encapsulated and encrypted\n4. Sent through tunnel to VPN server\n5. Server decrypts, forwards to destination\n6. Return traffic follows reverse path\n\n**Protocols:**\n- **IPsec**: Industry standard, complex\n- **OpenVPN**: Open source, SSL-based\n- **WireGuard**: Modern, fast, simple\n- **L2TP/IPsec**: Combines L2TP tunneling with IPsec encryption",
    "example": "VPN Tunnel:\n\nRemote User                  Internet              Corporate Network\n(Coffee Shop)                                      \n     |                                                    |\n[VPN Client]                                        [VPN Server]\n     |                                                    |\n     |============== Encrypted Tunnel ===================|\n     |                                                    |\n  Original packet:                              Decrypted at server:\n  +----------------+                            +----------------+\n  | IP: 10.0.0.50  |                            | IP: 10.0.0.50  |\n  | Data: GET /... |                            | Data: GET /... |\n  +----------------+                            +----------------+\n          |                                              |\n  Encapsulated:                                 Forwarded to:\n  +----------------------+                      Internal Server\n  | IP: Public VPN IP    |                      10.0.0.100\n  | ESP Header (IPsec)   |\n  | [Encrypted Original] |\n  +----------------------+\n\nSplit Tunneling:\n- All traffic through VPN: More secure\n- Only corporate traffic through VPN: Better performance\n\nWireGuard Config:\n[Interface]\nPrivateKey = <client-private-key>\nAddress = 10.0.0.2/24\n\n[Peer]\nPublicKey = <server-public-key>\nEndpoint = vpn.company.com:51820\nAllowedIPs = 10.0.0.0/24, 192.168.1.0/24"
  },
  {
    "id": 19,
    "question": "What is WebSocket and how does it differ from HTTP?",
    "answer": "**WebSocket** provides full-duplex, bidirectional communication over a single TCP connection.\n\n**HTTP vs WebSocket:**\n\n**HTTP:**\n- Request-response model\n- Client initiates every exchange\n- Connection closes after response (or keep-alive timeout)\n- Overhead per request (headers)\n- Good for: Static content, REST APIs\n\n**WebSocket:**\n- Persistent connection\n- Both sides can send anytime\n- Low latency, low overhead after handshake\n- Starts as HTTP, upgrades to WebSocket\n- Good for: Real-time apps, chat, gaming, live data\n\n**Handshake:**\n- Client sends HTTP Upgrade request\n- Server responds with 101 Switching Protocols\n- Connection upgraded to WebSocket\n\n**Port**: Uses 80 (ws://) or 443 (wss://)",
    "example": "WebSocket Handshake:\n\nClient Request:\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\n\nServer Response:\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n\n[Connection now uses WebSocket protocol]\n\nJavaScript WebSocket API:\nconst ws = new WebSocket('wss://server.example.com/chat');\n\nws.onopen = () => {\n  console.log('Connected');\n  ws.send(JSON.stringify({ type: 'join', room: 'general' }));\n};\n\nws.onmessage = (event) => {\n  const data = JSON.parse(event.data);\n  console.log('Received:', data);\n};\n\nws.onclose = () => {\n  console.log('Disconnected');\n};\n\n// Server can push messages anytime\n// No polling needed!\n\nUse cases:\n- Chat applications\n- Live sports scores\n- Stock tickers\n- Multiplayer games\n- Collaborative editing"
  },
  {
    "id": 20,
    "question": "What is TCP congestion control?",
    "answer": "**TCP Congestion Control** prevents network congestion by adjusting the sending rate based on network conditions.\n\n**Key concepts:**\n\n**Congestion Window (cwnd):**\n- Sender-side limit on unacknowledged data\n- Adjusted based on network feedback\n\n**Phases:**\n\n**1. Slow Start:**\n- Start with small cwnd (1-10 MSS)\n- Double cwnd every RTT (exponential growth)\n- Until: loss or ssthresh reached\n\n**2. Congestion Avoidance:**\n- Increase cwnd by 1 MSS per RTT (linear growth)\n- More conservative than slow start\n\n**3. Fast Retransmit/Recovery:**\n- 3 duplicate ACKs → retransmit immediately\n- Don't wait for timeout\n- Halve cwnd, continue without slow start\n\n**Algorithms:**\n- Reno, NewReno, CUBIC (Linux default), BBR (Google)",
    "example": "TCP Congestion Control Phases:\n\ncwnd\n  ^\n  |                    * packet loss\n  |                   /|\n  |                  / |\n  |                 /  |------ Congestion\n  |                /   |       Avoidance\n  |               /    |       (linear)\n  |              /     |\n  |    ssthresh /      |* loss: cwnd halved\n  |    --------/       |\\  new ssthresh\n  |           /|       | \\\n  |          / |       |  \\_____ Fast Recovery\n  |         /  |       |        \\\n  |        /   |       |         \\\n  |   Slow/    |       |          \\\n  |  Start     |       |           \\\n  | (exp)      |       |            \\\n  +------------+-------+-------------+---> time\n\nExample scenario:\n1. Start: cwnd = 1 MSS\n2. Slow Start: 1 → 2 → 4 → 8 → 16 (ssthresh = 16)\n3. Congestion Avoidance: 16 → 17 → 18 → 19 → 20\n4. Packet loss detected (3 dup ACKs)\n5. ssthresh = cwnd/2 = 10, cwnd = 10\n6. Continue with Congestion Avoidance: 10 → 11 → 12...\n\nBBR (Bottleneck Bandwidth and RTT):\n- Model-based, not loss-based\n- Probes for bandwidth and RTT\n- Better performance on lossy links\n- Used by Google, YouTube"
  }
]
