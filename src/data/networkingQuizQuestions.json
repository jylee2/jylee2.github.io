[
  {
    "id": 1,
    "question": "What is the OSI model and what are its seven layers?",
    "answer": "The **OSI (Open Systems Interconnection) model** is a conceptual framework that standardizes network communication into seven layers.\n\n**Layers (bottom to top):**\n\n1. **Physical** - Bits on the wire (cables, signals, voltages)\n2. **Data Link** - Node-to-node delivery, MAC addresses, frames (Ethernet, WiFi)\n3. **Network** - Routing between networks, IP addresses, packets (IP, ICMP)\n4. **Transport** - End-to-end delivery, ports, segments (TCP, UDP)\n5. **Session** - Session management, authentication\n6. **Presentation** - Data format, encryption, compression (SSL/TLS, JPEG)\n7. **Application** - User-facing protocols (HTTP, FTP, SMTP, DNS)\n\n**Mnemonic**: \"Please Do Not Throw Sausage Pizza Away\"\n\n**TCP/IP model** simplifies to 4 layers: Network Access, Internet, Transport, Application",
    "example": "Data flow through OSI layers:\n\nSending an HTTP request:\n\n7. Application: HTTP GET /index.html\n6. Presentation: Encrypt with TLS\n5. Session: Manage connection state\n4. Transport: Add TCP header (port 443)\n   [TCP Header | HTTP Data]\n3. Network: Add IP header (destination IP)\n   [IP Header | TCP Header | HTTP Data]\n2. Data Link: Add Ethernet frame (MAC address)\n   [Ethernet Header | IP | TCP | HTTP | Ethernet Trailer]\n1. Physical: Convert to electrical signals\n\nAt each layer, headers are added (encapsulation).\nReceiver strips headers in reverse order (decapsulation).\n\nProtocols at each layer:\n- Layer 7: HTTP, FTP, SMTP, DNS, SSH\n- Layer 4: TCP, UDP\n- Layer 3: IP, ICMP, ARP\n- Layer 2: Ethernet, WiFi (802.11)\n- Layer 1: Ethernet cables, fiber optics"
  },
  {
    "id": 2,
    "question": "What is the difference between TCP and UDP?",
    "answer": "**TCP (Transmission Control Protocol)**\n- Connection-oriented (3-way handshake)\n- Reliable delivery (acknowledgments, retransmission)\n- Ordered delivery (sequence numbers)\n- Flow control (sliding window)\n- Congestion control\n- Higher overhead, slower\n- Use: HTTP, FTP, SMTP, SSH - when reliability matters\n\n**UDP (User Datagram Protocol)**\n- Connectionless (no handshake)\n- Unreliable (no acknowledgments)\n- No ordering guarantee\n- No flow/congestion control\n- Lower overhead, faster\n- Use: DNS, streaming, gaming, VoIP - when speed matters\n\n**Key tradeoff**: TCP guarantees delivery at cost of latency; UDP prioritizes speed over reliability.",
    "example": "TCP Header (20+ bytes):\n+------------------+------------------+\n|   Source Port    |    Dest Port     |\n+------------------+------------------+\n|          Sequence Number            |\n+-----------------+-------------------+\n|       Acknowledgment Number         |\n+------+------+------+----------------+\n|Offset| Flags|Window|   Checksum     |\n+------+------+------+----------------+\n\nFlags: SYN, ACK, FIN, RST, PSH, URG\n\nUDP Header (8 bytes only):\n+------------------+------------------+\n|   Source Port    |    Dest Port     |\n+------------------+------------------+\n|     Length       |    Checksum      |\n+------------------+------------------+\n\nUse case examples:\n- Web browsing (HTTP): TCP - need complete, ordered pages\n- Video streaming: UDP - missing frame is better than delayed\n- Online gaming: UDP - low latency critical\n- File transfer: TCP - must have complete file\n- DNS queries: UDP - small, fast lookups (TCP for zone transfers)"
  },
  {
    "id": 3,
    "question": "How does the TCP three-way handshake work?",
    "answer": "The **TCP three-way handshake** establishes a reliable connection before data transfer.\n\n**Steps:**\n\n1. **SYN** (Client → Server)\n   - Client sends SYN flag with initial sequence number (ISN)\n   - \"I want to connect, starting at sequence X\"\n\n2. **SYN-ACK** (Server → Client)\n   - Server responds with SYN + ACK flags\n   - Acknowledges client's ISN (X+1)\n   - Sends its own ISN (Y)\n   - \"I acknowledge your request, my sequence starts at Y\"\n\n3. **ACK** (Client → Server)\n   - Client sends ACK flag\n   - Acknowledges server's ISN (Y+1)\n   - \"Connection established\"\n\n**Purpose:**\n- Synchronize sequence numbers\n- Verify both sides can send and receive\n- Allocate resources for connection\n\n**Connection termination**: 4-way handshake (FIN, ACK, FIN, ACK)",
    "example": "TCP Three-Way Handshake:\n\n    Client                          Server\n      |                               |\n      |------- SYN (seq=100) -------->|  1. Client initiates\n      |                               |\n      |<-- SYN-ACK (seq=300,ack=101) -|  2. Server responds\n      |                               |\n      |------- ACK (ack=301) -------->|  3. Client confirms\n      |                               |\n      |====== Connection Open ========|\n      |                               |\n      |<-------- Data Transfer ------>|\n      |                               |\n\nConnection Termination (4-way):\n\n      |------- FIN (seq=500) -------->|  Client wants to close\n      |<-------- ACK (ack=501) -------|  Server acknowledges\n      |<-------- FIN (seq=700) -------|  Server ready to close\n      |------- ACK (ack=701) -------->|  Client confirms\n      |                               |\n      |====== Connection Closed ======|\n\nCommon states:\n- LISTEN: Server waiting for connections\n- SYN_SENT: Client sent SYN, waiting\n- ESTABLISHED: Connection active\n- TIME_WAIT: Waiting before fully closing"
  },
  {
    "id": 4,
    "question": "What is an IP address and what's the difference between IPv4 and IPv6?",
    "answer": "An **IP address** is a unique numerical identifier for devices on a network, used for routing packets.\n\n**IPv4:**\n- 32-bit address (4 bytes)\n- Format: 192.168.1.1 (dotted decimal)\n- ~4.3 billion addresses (2³²)\n- Address exhaustion is real problem\n- NAT used to extend addresses\n- Header: 20-60 bytes\n\n**IPv6:**\n- 128-bit address (16 bytes)\n- Format: 2001:0db8:85a3:0000:0000:8a2e:0370:7334\n- ~340 undecillion addresses (2¹²⁸)\n- No need for NAT\n- Built-in IPsec support\n- Header: 40 bytes (fixed, simpler)\n\n**Special addresses:**\n- 127.0.0.1 / ::1 - Localhost\n- 10.x.x.x, 172.16-31.x.x, 192.168.x.x - Private (RFC 1918)\n- 0.0.0.0 - Default route / any interface",
    "example": "IPv4 Address Classes (historical):\n\nClass A: 1.0.0.0 - 126.255.255.255\n  - First octet: network, rest: host\n  - 16 million hosts per network\n  \nClass B: 128.0.0.0 - 191.255.255.255\n  - First two octets: network\n  - 65,534 hosts per network\n  \nClass C: 192.0.0.0 - 223.255.255.255\n  - First three octets: network\n  - 254 hosts per network\n\nCIDR Notation (modern):\n192.168.1.0/24\n  - /24 = 24 bits for network (255.255.255.0 mask)\n  - 8 bits for hosts = 256 addresses (254 usable)\n\n10.0.0.0/8\n  - /8 = 8 bits for network\n  - 24 bits for hosts = 16 million addresses\n\nIPv6 shortening rules:\n2001:0db8:0000:0000:0000:0000:0000:0001\n  → 2001:db8:0:0:0:0:0:1  (remove leading zeros)\n  → 2001:db8::1           (:: replaces consecutive zeros)\n\nSubnetting example:\n192.168.1.0/24 split into 4 /26 subnets:\n  192.168.1.0/26   (0-63)\n  192.168.1.64/26  (64-127)\n  192.168.1.128/26 (128-191)\n  192.168.1.192/26 (192-255)"
  },
  {
    "id": 5,
    "question": "How does DNS work?",
    "answer": "**DNS (Domain Name System)** translates human-readable domain names to IP addresses.\n\n**Hierarchy:**\n- Root servers (13 sets globally)\n- TLD servers (.com, .org, .net)\n- Authoritative name servers (specific domains)\n\n**Resolution process:**\n1. Check local cache\n2. Query recursive resolver (ISP/configured DNS)\n3. Resolver queries root → TLD → authoritative servers\n4. IP returned and cached\n\n**Record types:**\n- **A**: Domain → IPv4 address\n- **AAAA**: Domain → IPv6 address\n- **CNAME**: Alias to another domain\n- **MX**: Mail server for domain\n- **NS**: Authoritative name servers\n- **TXT**: Text records (SPF, DKIM, verification)\n- **PTR**: Reverse lookup (IP → domain)\n\n**Port**: UDP 53 (queries), TCP 53 (zone transfers, large responses)",
    "example": "DNS Resolution for www.example.com:\n\n1. Browser checks cache → Not found\n2. OS checks /etc/hosts → Not found\n3. Query recursive resolver (e.g., 8.8.8.8)\n\nResolver performs iterative queries:\n\n4. Query root server: \"Where is .com?\"\n   → Returns TLD server: a.gtld-servers.net\n\n5. Query .com TLD: \"Where is example.com?\"\n   → Returns authoritative: ns1.example.com\n\n6. Query authoritative: \"What is www.example.com?\"\n   → Returns A record: 93.184.216.34\n\n7. Resolver caches and returns to client\n8. Browser connects to 93.184.216.34\n\nDNS Records example (dig output):\n$ dig example.com\n\nexample.com.     300  IN  A      93.184.216.34\nexample.com.     300  IN  AAAA   2606:2800:220:1::248\nexample.com.     3600 IN  MX     10 mail.example.com.\nexample.com.     3600 IN  NS     ns1.example.com.\nexample.com.     3600 IN  TXT    \"v=spf1 -all\"\n\nTTL (Time To Live): How long to cache (seconds)"
  },
  {
    "id": 6,
    "question": "What is HTTP and how does it work?",
    "answer": "**HTTP (Hypertext Transfer Protocol)** is an application-layer protocol for transmitting hypermedia documents.\n\n**Characteristics:**\n- Request-response model\n- Stateless (each request independent)\n- Text-based protocol\n- Default port: 80 (HTTP), 443 (HTTPS)\n\n**HTTP Methods:**\n- **GET**: Retrieve resource (idempotent, cacheable)\n- **POST**: Submit data, create resource\n- **PUT**: Replace entire resource (idempotent)\n- **PATCH**: Partial update\n- **DELETE**: Remove resource (idempotent)\n- **HEAD**: GET without body (check headers)\n- **OPTIONS**: Supported methods (CORS preflight)\n\n**Status codes:**\n- 1xx: Informational\n- 2xx: Success (200 OK, 201 Created, 204 No Content)\n- 3xx: Redirection (301 Moved, 304 Not Modified)\n- 4xx: Client error (400 Bad Request, 401, 403, 404)\n- 5xx: Server error (500 Internal, 502, 503)",
    "example": "HTTP Request:\n\nGET /api/users/123 HTTP/1.1\nHost: api.example.com\nUser-Agent: Mozilla/5.0\nAccept: application/json\nAuthorization: Bearer eyJhbGc...\nConnection: keep-alive\n\nHTTP Response:\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 82\nCache-Control: max-age=3600\nETag: \"abc123\"\n\n{\"id\": 123, \"name\": \"John\", \"email\": \"john@example.com\"}\n\nHTTP Versions:\n\nHTTP/1.0: New connection per request\nHTTP/1.1: Keep-alive, pipelining, Host header\nHTTP/2: Binary, multiplexing, header compression, server push\nHTTP/3: QUIC (UDP-based), faster handshake\n\nCommon Headers:\n- Content-Type: MIME type of body\n- Cache-Control: Caching directives\n- Authorization: Authentication credentials\n- Cookie/Set-Cookie: State management\n- ETag/If-None-Match: Conditional requests\n- CORS headers: Access-Control-*"
  },
  {
    "id": 7,
    "question": "What is HTTPS and how does TLS/SSL work?",
    "answer": "**HTTPS** is HTTP over TLS (Transport Layer Security), providing encrypted communication.\n\n**What TLS provides:**\n- **Confidentiality**: Encryption prevents eavesdropping\n- **Integrity**: MAC prevents tampering\n- **Authentication**: Certificates verify server identity\n\n**TLS Handshake (simplified TLS 1.3):**\n1. **Client Hello**: Supported cipher suites, random number, key share\n2. **Server Hello**: Chosen cipher, certificate, key share\n3. **Key derivation**: Both compute shared secret\n4. **Finished**: Verify handshake integrity\n5. **Encrypted communication begins**\n\n**Certificates:**\n- Issued by Certificate Authorities (CA)\n- Contains: public key, domain, issuer, validity\n- Chain of trust: Root CA → Intermediate → Server cert\n\n**Modern best practices:**\n- TLS 1.3 (TLS 1.2 minimum)\n- HSTS header to force HTTPS\n- Certificate transparency",
    "example": "TLS 1.3 Handshake (1-RTT):\n\n    Client                           Server\n      |                                |\n      |---- ClientHello + KeyShare --->|  Supported ciphers,\n      |                                |  DH public key\n      |                                |\n      |<-- ServerHello + KeyShare -----|  Chosen cipher,\n      |    Certificate, Finished       |  Certificate,\n      |                                |  DH public key\n      |                                |\n      |---- Finished ----------------->|  Verify handshake\n      |                                |\n      |==== Encrypted Data ============|  Using derived keys\n\nCertificate chain verification:\n\n[Server Cert]\n  Issued by: Intermediate CA\n  For: www.example.com\n        ↓ verified by\n[Intermediate CA Cert]\n  Issued by: Root CA\n        ↓ verified by\n[Root CA Cert]\n  Self-signed, trusted by browser\n\nHTTPS URL: https://www.example.com:443/path\n\nHSTS Header:\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n\nForces browser to always use HTTPS for this domain."
  },
  {
    "id": 8,
    "question": "What is NAT (Network Address Translation)?",
    "answer": "**NAT** translates private IP addresses to public IP addresses, allowing multiple devices to share one public IP.\n\n**Why NAT exists:**\n- IPv4 address exhaustion\n- Security (hides internal network structure)\n- Flexibility in internal addressing\n\n**Types:**\n\n**Static NAT**: One-to-one mapping\n- Internal IP always maps to same external IP\n\n**Dynamic NAT**: Pool of public IPs\n- Internal IPs mapped from available pool\n\n**PAT (Port Address Translation) / NAPT**: Most common\n- Many internal IPs share one public IP\n- Distinguished by port numbers\n- Also called \"NAT overload\"\n\n**NAT traversal challenges:**\n- Breaks end-to-end connectivity\n- Peer-to-peer applications need workarounds (STUN, TURN, ICE)\n- Some protocols embed IP in payload (FTP, SIP)",
    "example": "PAT Example:\n\nInternal Network          NAT Router          Internet\n                                              \n192.168.1.10:5000  --->  203.0.113.1:10001 ---> Server\n192.168.1.11:5000  --->  203.0.113.1:10002 ---> Server\n192.168.1.12:6000  --->  203.0.113.1:10003 ---> Server\n\nNAT Table:\n+---------------+-------+----------------+-------+\n| Internal IP   | Port  | External IP    | Port  |\n+---------------+-------+----------------+-------+\n| 192.168.1.10  | 5000  | 203.0.113.1    | 10001 |\n| 192.168.1.11  | 5000  | 203.0.113.1    | 10002 |\n| 192.168.1.12  | 6000  | 203.0.113.1    | 10003 |\n+---------------+-------+----------------+-------+\n\nReturn traffic:\n- Server responds to 203.0.113.1:10001\n- Router looks up NAT table\n- Translates to 192.168.1.10:5000\n- Forwards to internal device\n\nPort Forwarding (for servers behind NAT):\n- External 203.0.113.1:80 → Internal 192.168.1.100:80\n- Allows incoming connections to reach internal server"
  },
  {
    "id": 9,
    "question": "What is a subnet and how does subnetting work?",
    "answer": "**Subnetting** divides a network into smaller, more manageable sub-networks.\n\n**Purpose:**\n- Efficient IP address allocation\n- Reduce broadcast domain size\n- Improve security (segment networks)\n- Better network organization\n\n**Subnet mask:**\n- Defines network vs host portion\n- 255.255.255.0 = /24 (24 network bits)\n- 1s represent network, 0s represent host\n\n**CIDR notation:**\n- /24 = 256 addresses (254 usable)\n- /25 = 128 addresses (126 usable)\n- /26 = 64 addresses (62 usable)\n- /27 = 32 addresses (30 usable)\n- /28 = 16 addresses (14 usable)\n\n**Reserved addresses per subnet:**\n- First: Network address (e.g., 192.168.1.0)\n- Last: Broadcast address (e.g., 192.168.1.255)\n\n**Formula**: Usable hosts = 2^(32-prefix) - 2",
    "example": "Subnetting 192.168.1.0/24 into 4 subnets:\n\nOriginal: 192.168.1.0/24 (256 addresses)\nNeed: 4 subnets → borrow 2 bits → /26\n\nSubnet 1: 192.168.1.0/26\n  Network:   192.168.1.0\n  First host: 192.168.1.1\n  Last host:  192.168.1.62\n  Broadcast:  192.168.1.63\n\nSubnet 2: 192.168.1.64/26\n  Range: 192.168.1.64 - 192.168.1.127\n\nSubnet 3: 192.168.1.128/26\n  Range: 192.168.1.128 - 192.168.1.191\n\nSubnet 4: 192.168.1.192/26\n  Range: 192.168.1.192 - 192.168.1.255\n\nSubnet mask conversion:\n/24 = 255.255.255.0   = 11111111.11111111.11111111.00000000\n/26 = 255.255.255.192 = 11111111.11111111.11111111.11000000\n/28 = 255.255.255.240 = 11111111.11111111.11111111.11110000\n\nDetermine subnet for 192.168.1.100 with /26:\n- 100 in binary: 01100100\n- /26 means first 2 bits of last octet = subnet\n- 01 = subnet 1 (64-127)\n- Answer: 192.168.1.64/26"
  },
  {
    "id": 10,
    "question": "What are the common email protocols (SMTP, POP3, IMAP)?",
    "answer": "**SMTP (Simple Mail Transfer Protocol)**\n- Purpose: Sending email\n- Port: 25 (server-to-server), 587 (submission), 465 (legacy SSL)\n- Push protocol\n- Used between: client→server, server→server\n\n**POP3 (Post Office Protocol v3)**\n- Purpose: Retrieving email\n- Port: 110 (plain), 995 (SSL/TLS)\n- Downloads and typically deletes from server\n- Simple, single device access\n- Offline access after download\n\n**IMAP (Internet Message Access Protocol)**\n- Purpose: Retrieving and managing email\n- Port: 143 (plain), 993 (SSL/TLS)\n- Keeps email on server\n- Sync across multiple devices\n- Folder management on server\n- Requires constant connection for full features\n\n**Modern email**: IMAP for reading + SMTP for sending",
    "example": "Email sending flow:\n\n1. User composes email in client\n2. Client connects to SMTP server (port 587)\n3. SMTP submission:\n   \n   EHLO client.example.com\n   AUTH LOGIN\n   [base64 credentials]\n   MAIL FROM:<sender@example.com>\n   RCPT TO:<recipient@other.com>\n   DATA\n   Subject: Hello\n   \n   Message body here.\n   .\n   QUIT\n\n4. Sender's SMTP server looks up MX record for other.com\n5. Connects to recipient's SMTP server (port 25)\n6. Delivers message\n\nEmail retrieval (IMAP):\n\n   A1 LOGIN username password\n   A2 SELECT INBOX\n   * 3 EXISTS\n   A3 FETCH 1:3 (FLAGS BODY[HEADER])\n   A4 FETCH 2 BODY[]\n   A5 STORE 2 +FLAGS (\\Seen)\n   A6 LOGOUT\n\nPOP3 vs IMAP:\n- POP3: Download all, delete from server, offline use\n- IMAP: Sync state, multiple devices, server storage\n\nSecurity: Always use TLS (ports 465/587, 993, 995)"
  },
  {
    "id": 11,
    "question": "What is FTP and how does it work?",
    "answer": "**FTP (File Transfer Protocol)** transfers files between client and server.\n\n**Ports:**\n- Port 21: Control connection (commands)\n- Port 20: Data connection (active mode)\n\n**Modes:**\n\n**Active Mode:**\n- Client opens random port, tells server\n- Server connects FROM port 20 TO client's port\n- Problem: Client firewalls often block incoming\n\n**Passive Mode (PASV):**\n- Client requests passive mode\n- Server opens random port, tells client\n- Client connects TO server's port\n- Firewall-friendly (client initiates both connections)\n\n**Security concerns:**\n- Credentials sent in plaintext\n- Data unencrypted\n- Solutions: FTPS (FTP + TLS), SFTP (SSH-based, different protocol)\n\n**Common commands:**\n- USER, PASS: Authentication\n- LIST, NLST: Directory listing\n- RETR, STOR: Download, upload\n- CWD, PWD: Change/print directory",
    "example": "FTP Session Example:\n\n1. Control connection (port 21):\n\n   220 FTP Server Ready\n   USER anonymous\n   331 Password required\n   PASS user@example.com\n   230 Login successful\n   PWD\n   257 \"/home/ftp\" is current directory\n   PASV\n   227 Entering Passive Mode (192,168,1,1,195,80)\n       → Server listening on 192.168.1.1:50000\n          (195*256 + 80 = 50000)\n\n2. Data connection (port 50000):\n   Client connects to server:50000\n   \n   LIST\n   150 Opening data connection\n   [Directory listing transferred]\n   226 Transfer complete\n   \n   RETR file.txt\n   150 Opening data connection\n   [File contents transferred]\n   226 Transfer complete\n   \n   QUIT\n   221 Goodbye\n\nActive vs Passive:\n\nActive:  Server:20 -----> Client:random_port\n         (Server initiates data connection)\n\nPassive: Client -----> Server:random_port\n         (Client initiates data connection)\n\nSecure alternatives:\n- FTPS: FTP + TLS encryption (ports 990, 989)\n- SFTP: SSH File Transfer (port 22, different protocol)"
  },
  {
    "id": 12,
    "question": "What is ARP and how does it work?",
    "answer": "**ARP (Address Resolution Protocol)** maps IP addresses to MAC (hardware) addresses on a local network.\n\n**Why needed:**\n- IP addresses work at Layer 3 (network)\n- Actual frame delivery needs MAC at Layer 2\n- Must resolve IP → MAC for local delivery\n\n**How it works:**\n\n1. **ARP Request** (broadcast):\n   - \"Who has IP 192.168.1.5? Tell 192.168.1.1\"\n   - Sent to FF:FF:FF:FF:FF:FF (broadcast MAC)\n   - All devices on segment receive it\n\n2. **ARP Reply** (unicast):\n   - Device with matching IP responds\n   - \"192.168.1.5 is at AA:BB:CC:DD:EE:FF\"\n   - Sent directly to requester\n\n3. **ARP Cache**: Results cached to avoid repeated broadcasts\n\n**Security concerns:**\n- ARP spoofing/poisoning: Attacker sends false ARP replies\n- Enables MITM attacks on local network\n- Mitigation: Static ARP entries, ARP inspection",
    "example": "ARP Resolution Example:\n\nHost A (192.168.1.1, MAC: AA:AA:AA:AA:AA:AA)\nwants to send to Host B (192.168.1.5)\n\n1. Host A checks ARP cache - not found\n\n2. ARP Request (broadcast):\n   Source MAC: AA:AA:AA:AA:AA:AA\n   Dest MAC:   FF:FF:FF:FF:FF:FF (broadcast)\n   Source IP:  192.168.1.1\n   Target IP:  192.168.1.5\n   \"Who has 192.168.1.5?\"\n\n3. All hosts receive, only 192.168.1.5 responds\n\n4. ARP Reply (unicast):\n   Source MAC: BB:BB:BB:BB:BB:BB\n   Dest MAC:   AA:AA:AA:AA:AA:AA\n   \"192.168.1.5 is at BB:BB:BB:BB:BB:BB\"\n\n5. Host A caches: 192.168.1.5 → BB:BB:BB:BB:BB:BB\n\n6. Host A can now send Ethernet frame:\n   Dest MAC: BB:BB:BB:BB:BB:BB\n   [IP packet with dest 192.168.1.5]\n\nView ARP cache:\n$ arp -a\n? (192.168.1.1) at aa:bb:cc:dd:ee:ff on en0\n? (192.168.1.5) at bb:bb:bb:bb:bb:bb on en0\n\nARP for different subnet:\n- Resolved to default gateway's MAC\n- Gateway forwards to destination network"
  },
  {
    "id": 13,
    "question": "What is a firewall and what types exist?",
    "answer": "A **firewall** monitors and controls network traffic based on security rules.\n\n**Types:**\n\n**Packet Filtering (Stateless):**\n- Examines individual packets\n- Checks: source/dest IP, ports, protocol\n- No connection tracking\n- Fast but limited\n\n**Stateful Inspection:**\n- Tracks connection state\n- Understands TCP handshake, sessions\n- More secure than stateless\n- Most common type\n\n**Application Layer / WAF:**\n- Inspects application data (HTTP, DNS)\n- Can detect SQL injection, XSS\n- Deep packet inspection\n- Higher overhead\n\n**Next-Generation (NGFW):**\n- Combines all above\n- Plus: IPS, threat intelligence, user identity\n\n**Host-based vs Network-based:**\n- Host: On individual machines (Windows Firewall, iptables)\n- Network: At network perimeter (dedicated appliances)",
    "example": "Firewall Rule Examples (iptables):\n\n# Default policies\niptables -P INPUT DROP\niptables -P FORWARD DROP\niptables -P OUTPUT ACCEPT\n\n# Allow established connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH from specific IP\niptables -A INPUT -p tcp --dport 22 -s 10.0.0.5 -j ACCEPT\n\n# Allow HTTP/HTTPS from anywhere\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Block specific IP\niptables -A INPUT -s 192.168.1.100 -j DROP\n\n# Allow ping (ICMP)\niptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT\n\nSecurity Group (Cloud):\n{\n  \"inbound\": [\n    {\"port\": 443, \"source\": \"0.0.0.0/0\"},\n    {\"port\": 22, \"source\": \"10.0.0.0/8\"}\n  ],\n  \"outbound\": [\n    {\"port\": \"all\", \"dest\": \"0.0.0.0/0\"}\n  ]\n}\n\nStateful tracking:\n- Outbound request to port 80 allowed\n- Return traffic on ephemeral port automatically allowed\n- No need to explicitly allow return traffic"
  },
  {
    "id": 14,
    "question": "What is a load balancer and what algorithms does it use?",
    "answer": "A **load balancer** distributes incoming traffic across multiple servers to improve availability and performance.\n\n**Types:**\n- **Layer 4 (Transport)**: Routes based on IP/port, faster\n- **Layer 7 (Application)**: Routes based on content (URL, headers), more flexible\n\n**Algorithms:**\n\n**Round Robin:**\n- Requests distributed sequentially\n- Simple, equal distribution\n\n**Weighted Round Robin:**\n- Servers have weights based on capacity\n- More requests to higher-weight servers\n\n**Least Connections:**\n- Route to server with fewest active connections\n- Good for varying request duration\n\n**IP Hash:**\n- Hash client IP to determine server\n- Same client always hits same server (sticky)\n\n**Health checks**: Monitor server availability, remove unhealthy servers from pool",
    "example": "Load Balancer Configuration (nginx):\n\nupstream backend {\n    # Weighted round robin\n    server 10.0.0.1:8080 weight=3;\n    server 10.0.0.2:8080 weight=2;\n    server 10.0.0.3:8080 weight=1;\n    \n    # Health check\n    server 10.0.0.4:8080 backup;  # Only if others fail\n}\n\n# Least connections\nupstream backend_lc {\n    least_conn;\n    server 10.0.0.1:8080;\n    server 10.0.0.2:8080;\n}\n\n# IP hash (sticky sessions)\nupstream backend_sticky {\n    ip_hash;\n    server 10.0.0.1:8080;\n    server 10.0.0.2:8080;\n}\n\nserver {\n    listen 80;\n    location / {\n        proxy_pass http://backend;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}\n\nLayer 4 vs Layer 7:\n\nL4: Client ──TCP──> LB ──TCP──> Server\n    Fast, can't inspect HTTP\n\nL7: Client ──HTTP──> LB (terminates, inspects) ──HTTP──> Server\n    Can route by URL: /api/* → API servers\n                      /static/* → CDN\n    SSL termination at LB"
  },
  {
    "id": 15,
    "question": "What is DHCP and how does it work?",
    "answer": "**DHCP (Dynamic Host Configuration Protocol)** automatically assigns IP addresses and network configuration to devices.\n\n**What DHCP provides:**\n- IP address\n- Subnet mask\n- Default gateway\n- DNS servers\n- Lease duration\n\n**DORA Process:**\n\n1. **Discover** (Client → Broadcast)\n   - Client broadcasts: \"I need an IP address\"\n\n2. **Offer** (Server → Client)\n   - Server offers available IP and configuration\n\n3. **Request** (Client → Broadcast)\n   - Client accepts offer: \"I'll take that IP\"\n\n4. **Acknowledge** (Server → Client)\n   - Server confirms: \"IP is yours for X hours\"\n\n**Lease renewal:**\n- At 50% of lease: Client requests renewal\n- At 87.5%: Client broadcasts for any server\n- At expiry: Must restart DORA\n\n**Ports**: Server 67, Client 68 (UDP)",
    "example": "DHCP DORA Process:\n\n    Client                          DHCP Server\n      |                                  |\n      |--- DISCOVER (broadcast) -------->|\n      |    src: 0.0.0.0                  |  \"I need an IP\"\n      |    dst: 255.255.255.255          |\n      |                                  |\n      |<-------- OFFER ------------------|  \"Here's 192.168.1.50\"\n      |    Your IP: 192.168.1.50         |\n      |    Subnet: 255.255.255.0         |\n      |    Gateway: 192.168.1.1          |\n      |    DNS: 8.8.8.8                  |\n      |    Lease: 24 hours               |\n      |                                  |\n      |--- REQUEST (broadcast) --------->|  \"I accept 192.168.1.50\"\n      |                                  |\n      |<-------- ACK --------------------|  \"Confirmed, it's yours\"\n      |                                  |\n      |==== Client configured ===========|\n\nDHCP Lease Renewal:\n\nTime 0: Lease granted (24 hours)\nTime 12h: Client sends REQUEST to server (unicast)\n  - If ACK: Lease renewed\n  - If no response: Try again at 87.5%\nTime 21h: Client broadcasts REQUEST\n  - Any DHCP server can respond\nTime 24h: Lease expires, restart DORA\n\nReserved IP (Static DHCP):\n- MAC AA:BB:CC:DD:EE:FF always gets 192.168.1.100\n- Configured on DHCP server"
  },
  {
    "id": 16,
    "question": "What is a VPN and what types exist?",
    "answer": "**VPN (Virtual Private Network)** creates an encrypted tunnel over public networks, providing secure remote access.\n\n**Use cases:**\n- Remote access to corporate network\n- Site-to-site connectivity\n- Privacy and anonymity\n- Bypass geo-restrictions\n\n**Types:**\n\n**Remote Access VPN:**\n- Individual users connect to network\n- Client software on user device\n- Common: OpenVPN, WireGuard, IPsec IKEv2\n\n**Site-to-Site VPN:**\n- Connects entire networks\n- Routers/firewalls at each site\n- Always-on connection\n\n**Protocols:**\n- **IPsec**: Layer 3, widely supported, complex\n- **OpenVPN**: SSL/TLS-based, flexible, open-source\n- **WireGuard**: Modern, fast, simple, small codebase\n- **L2TP/IPsec**: Layer 2, often with IPsec\n- **PPTP**: Legacy, insecure, avoid",
    "example": "VPN Tunnel Concept:\n\nWithout VPN:\nClient ─────[Public Internet]─────> Server\n  (Traffic visible, can be intercepted)\n\nWith VPN:\nClient ──[Encrypted Tunnel]──> VPN Server ──> Internet\n  \\___________________________/\n        Encrypted traffic\n        ISP sees only VPN connection\n\nIPsec VPN Phases:\n\nPhase 1 (IKE SA):\n  - Authenticate peers (PSK or certificates)\n  - Negotiate encryption (AES, SHA)\n  - Establish secure channel for Phase 2\n\nPhase 2 (IPsec SA):\n  - Negotiate IPsec parameters\n  - Create tunnel for actual traffic\n  - ESP (encrypted) or AH (authenticated only)\n\nWireGuard Configuration:\n\n[Interface]\nPrivateKey = <client_private_key>\nAddress = 10.0.0.2/24\nDNS = 1.1.1.1\n\n[Peer]\nPublicKey = <server_public_key>\nEndpoint = vpn.example.com:51820\nAllowedIPs = 0.0.0.0/0  # Route all traffic\nPersistentKeepalive = 25\n\nSplit tunneling:\n- AllowedIPs = 10.0.0.0/8  # Only route internal traffic\n- Direct internet access for other traffic"
  },
  {
    "id": 17,
    "question": "What is the difference between a switch, router, and hub?",
    "answer": "**Hub (Layer 1 - Physical)**\n- Repeats signal to ALL ports\n- No intelligence, just signal amplification\n- Creates one collision domain\n- Half-duplex only\n- Obsolete technology\n\n**Switch (Layer 2 - Data Link)**\n- Forwards frames based on MAC addresses\n- Learns MAC-to-port mapping (MAC table)\n- Each port is separate collision domain\n- Full-duplex capable\n- Creates one broadcast domain\n\n**Router (Layer 3 - Network)**\n- Forwards packets based on IP addresses\n- Connects different networks\n- Makes routing decisions\n- Separates broadcast domains\n- NAT, firewall capabilities\n\n**Key distinction:**\n- Switch: Within network (same IP subnet)\n- Router: Between networks (different subnets)",
    "example": "Network topology example:\n\n[Internet]\n    |\n [Router] ─── 192.168.1.1 (Gateway)\n    |\n    |─── WAN: Public IP (NAT)\n    |─── LAN: 192.168.1.0/24\n    |\n [Switch] ─── Layer 2 forwarding\n    |\n    |─── Port 1: PC-A (192.168.1.10, MAC: AA:AA)\n    |─── Port 2: PC-B (192.168.1.11, MAC: BB:BB)\n    |─── Port 3: PC-C (192.168.1.12, MAC: CC:CC)\n\nSwitch MAC Table:\nMAC Address    | Port\nAA:AA:AA:AA    | 1\nBB:BB:BB:BB    | 2\nCC:CC:CC:CC    | 3\n\nTraffic flow:\n\n1. PC-A → PC-B (same subnet):\n   - Switch looks up BB:BB in MAC table\n   - Forwards only to Port 2\n   - Router not involved\n\n2. PC-A → Internet:\n   - Destination not on local subnet\n   - Sent to default gateway (router)\n   - Router performs NAT\n   - Forwards to internet\n\nHub behavior (for comparison):\n- PC-A sends frame\n- Hub repeats to ALL ports\n- All devices receive (inefficient, security issue)"
  },
  {
    "id": 18,
    "question": "What is ICMP and how is it used?",
    "answer": "**ICMP (Internet Control Message Protocol)** is a network layer protocol for error reporting and diagnostics.\n\n**Characteristics:**\n- Part of IP (but separate protocol)\n- No ports (not TCP/UDP)\n- Used by network devices to communicate issues\n\n**Common ICMP Types:**\n- **Type 0**: Echo Reply (ping response)\n- **Type 3**: Destination Unreachable\n- **Type 4**: Source Quench (deprecated)\n- **Type 5**: Redirect\n- **Type 8**: Echo Request (ping)\n- **Type 11**: Time Exceeded (TTL = 0)\n\n**Tools using ICMP:**\n- **ping**: Echo request/reply to test connectivity\n- **traceroute**: Uses TTL expiration to map path\n- **Path MTU Discovery**: Uses \"Fragmentation Needed\"\n\n**Security:**\n- Often filtered by firewalls\n- Can be used for reconnaissance\n- Ping floods (DoS attack)",
    "example": "Ping (ICMP Echo):\n\n$ ping 8.8.8.8\nICMP Echo Request  ───────────────────>\n                                        8.8.8.8\nICMP Echo Reply    <───────────────────\n\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=117 time=12.3 ms\n\nTraceroute (ICMP Time Exceeded):\n\n$ traceroute example.com\n\n1. Send packet with TTL=1\n   → First router decrements to 0\n   → Sends ICMP Time Exceeded\n   → We learn first hop\n\n2. Send packet with TTL=2\n   → Second router sends Time Exceeded\n   → We learn second hop\n\n3. Continue until destination reached\n\nOutput:\n 1  192.168.1.1     1.2 ms   (gateway)\n 2  10.0.0.1        5.4 ms   (ISP)\n 3  72.14.215.85    12.1 ms  (backbone)\n 4  93.184.216.34   15.3 ms  (destination)\n\nICMP Destination Unreachable codes:\n- Code 0: Network unreachable\n- Code 1: Host unreachable\n- Code 3: Port unreachable\n- Code 4: Fragmentation needed (MTU discovery)\n- Code 13: Administratively prohibited (firewall)"
  },
  {
    "id": 19,
    "question": "What is a CDN (Content Delivery Network)?",
    "answer": "A **CDN** is a geographically distributed network of servers that delivers content to users from the nearest location.\n\n**Purpose:**\n- Reduce latency (closer servers)\n- Handle traffic spikes\n- Improve availability (redundancy)\n- Reduce origin server load\n- DDoS protection\n\n**How it works:**\n1. User requests content (e.g., image.jpg)\n2. DNS resolves to nearest CDN edge server\n3. If cached: Edge serves directly\n4. If not cached: Edge fetches from origin, caches, serves\n\n**Content types:**\n- Static: Images, CSS, JS, videos\n- Dynamic: API responses (with short TTL)\n\n**Key concepts:**\n- **Edge server/PoP**: Server close to users\n- **Origin**: Your actual server\n- **Cache hit ratio**: % served from cache\n- **TTL**: How long to cache",
    "example": "CDN Request Flow:\n\nUser (Tokyo) requests: cdn.example.com/image.jpg\n\n1. DNS Resolution:\n   cdn.example.com → CDN's DNS\n   → Returns IP of nearest edge (Tokyo PoP)\n\n2. Request to Edge:\n   User ──────> Tokyo Edge Server\n   \n   Cache HIT:  Edge has image.jpg\n               └─> Return immediately (fast!)\n   \n   Cache MISS: Edge doesn't have it\n               └─> Fetch from origin (US)\n               └─> Cache locally\n               └─> Return to user\n\n3. Subsequent requests:\n   All Tokyo users get cached version\n\nCDN Configuration (Cloudflare example):\n\n# Cache rules\n/static/*     cache=1year    # Static assets\n/api/*        cache=0        # No cache for API\n/*.html       cache=1hour    # HTML pages\n\n# Headers from origin control caching\nCache-Control: public, max-age=31536000\n\nBenefits measured:\n- Without CDN: User→Origin (200ms latency)\n- With CDN:    User→Edge (20ms latency)\n\nPopular CDNs:\n- Cloudflare, AWS CloudFront, Akamai\n- Fastly, Google Cloud CDN"
  },
  {
    "id": 20,
    "question": "What are WebSockets and how do they differ from HTTP?",
    "answer": "**WebSockets** provide full-duplex, persistent communication between client and server over a single TCP connection.\n\n**HTTP vs WebSocket:**\n\n**HTTP:**\n- Request-response model\n- Client initiates every exchange\n- Connection closes after response (or keep-alive timeout)\n- Overhead: Headers sent every request\n- Polling needed for real-time updates\n\n**WebSocket:**\n- Bidirectional communication\n- Server can push data anytime\n- Persistent connection\n- Minimal overhead after handshake\n- True real-time communication\n\n**Handshake:**\n- Starts as HTTP upgrade request\n- If accepted, protocol switches to WebSocket\n- Uses same port as HTTP (80/443)\n\n**Use cases:**\n- Chat applications\n- Live notifications\n- Gaming\n- Collaborative editing\n- Financial tickers",
    "example": "WebSocket Handshake:\n\n1. Client HTTP Upgrade Request:\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\n\n2. Server Response:\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n\n3. Now using WebSocket protocol (bidirectional)\n\nJavaScript Client:\nconst ws = new WebSocket('wss://server.example.com/chat');\n\nws.onopen = () => {\n  ws.send('Hello Server!');\n};\n\nws.onmessage = (event) => {\n  console.log('Received:', event.data);\n};\n\nws.onclose = () => {\n  console.log('Connection closed');\n};\n\nServer (Node.js):\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws) => {\n  ws.on('message', (message) => {\n    // Broadcast to all clients\n    wss.clients.forEach((client) => {\n      client.send(message);\n    });\n  });\n});\n\nAlternatives:\n- Server-Sent Events (SSE): Server→Client only\n- Long polling: HTTP with delayed response\n- HTTP/2 Server Push: Limited push capability"
  }
]
