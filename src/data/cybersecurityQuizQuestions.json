[
  {
    "id": 1,
    "question": "What is the CIA triad in cybersecurity?",
    "answer": "The **CIA triad** is the foundational model for information security:\n\n**Confidentiality**: Ensuring data is accessible only to authorized users. Achieved through encryption, access controls, authentication.\n\n**Integrity**: Ensuring data is accurate and unaltered. Achieved through hashing, digital signatures, checksums.\n\n**Availability**: Ensuring systems and data are accessible when needed. Achieved through redundancy, backups, DDoS protection.\n\nSome frameworks add **Non-repudiation** (proof of origin) and **Authentication** (verifying identity).",
    "example": "# Confidentiality - Encryption\nfrom cryptography.fernet import Fernet\nkey = Fernet.generate_key()\ncipher = Fernet(key)\nencrypted = cipher.encrypt(b\"sensitive data\")\n\n# Integrity - Hashing\nimport hashlib\ndata = b\"important document\"\nhash_value = hashlib.sha256(data).hexdigest()\n# Store hash, later verify: hashlib.sha256(received_data).hexdigest() == hash_value\n\n# Availability - Health checks, redundancy\n# Load balancers, failover systems, backup strategies"
  },
  {
    "id": 2,
    "question": "What is the difference between symmetric and asymmetric encryption?",
    "answer": "**Symmetric encryption** uses the same key for encryption and decryption:\n- Fast and efficient for large data\n- Key distribution is challenging\n- Examples: AES, ChaCha20, 3DES\n\n**Asymmetric encryption** uses a public/private key pair:\n- Public key encrypts, private key decrypts\n- Solves key distribution problem\n- Slower, used for small data or key exchange\n- Examples: RSA, ECC, Ed25519\n\n**Hybrid approach**: Use asymmetric to exchange symmetric key, then use symmetric for bulk data (TLS does this).",
    "example": "# Symmetric - AES\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport os\n\nkey = os.urandom(32)  # 256-bit key\niv = os.urandom(16)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(plaintext) + encryptor.finalize()\n\n# Asymmetric - RSA\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\n\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Encrypt with public key\nciphertext = public_key.encrypt(\n    plaintext,\n    padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                 algorithm=hashes.SHA256(), label=None)\n)\n\n# Decrypt with private key\nplaintext = private_key.decrypt(ciphertext, padding.OAEP(...))"
  },
  {
    "id": 3,
    "question": "What is SQL injection and how do you prevent it?",
    "answer": "**SQL injection** is an attack where malicious SQL code is inserted into application queries, allowing attackers to read, modify, or delete data.\n\n**Example attack:**\nInput: `' OR '1'='1' --`\nQuery becomes: `SELECT * FROM users WHERE username='' OR '1'='1' --'`\n\n**Prevention:**\n- **Parameterized queries/Prepared statements** (primary defense)\n- Input validation and sanitization\n- Least privilege database accounts\n- Web Application Firewall (WAF)\n- ORM usage (still validate inputs)\n- Escape special characters (last resort)",
    "example": "# VULNERABLE - String concatenation\nquery = f\"SELECT * FROM users WHERE username = '{username}'\"\n\n# SAFE - Parameterized query (Python/SQLite)\nimport sqlite3\nconn = sqlite3.connect('db.sqlite')\ncursor = conn.cursor()\ncursor.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\n\n# SAFE - SQLAlchemy ORM\nfrom sqlalchemy import select\nfrom models import User\nstmt = select(User).where(User.username == username)\nresult = session.execute(stmt)\n\n# SAFE - Django ORM\nUser.objects.filter(username=username)\n\n# SAFE - Node.js with pg\nconst result = await pool.query(\n  'SELECT * FROM users WHERE username = $1',\n  [username]\n);"
  },
  {
    "id": 4,
    "question": "What is Cross-Site Scripting (XSS) and what are its types?",
    "answer": "**XSS** attacks inject malicious scripts into web pages viewed by other users, stealing cookies, sessions, or performing actions on behalf of victims.\n\n**Types:**\n\n**Stored XSS**: Malicious script permanently stored on server (database, comments). Most dangerous.\n\n**Reflected XSS**: Script included in URL/request, reflected back in response. Requires victim to click malicious link.\n\n**DOM-based XSS**: Script manipulates DOM directly in browser, never sent to server.\n\n**Prevention:**\n- Output encoding/escaping\n- Content Security Policy (CSP)\n- HTTPOnly cookies\n- Input validation",
    "example": "// VULNERABLE\ndocument.getElementById('output').innerHTML = userInput;\n\n// SAFE - Use textContent instead of innerHTML\ndocument.getElementById('output').textContent = userInput;\n\n// SAFE - Escape HTML\nfunction escapeHtml(text) {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n// Server-side - Content Security Policy header\n// Content-Security-Policy: default-src 'self'; script-src 'self'\n\n// React automatically escapes (safe by default)\nfunction Comment({ text }) {\n  return <p>{text}</p>;  // Safe - React escapes\n}\n\n// DANGEROUS in React - avoid dangerouslySetInnerHTML\n<div dangerouslySetInnerHTML={{__html: userInput}} />  // XSS risk!"
  },
  {
    "id": 5,
    "question": "What is the difference between authentication and authorization?",
    "answer": "**Authentication (AuthN)**: Verifying WHO you are\n- Proves identity\n- \"Are you who you claim to be?\"\n- Methods: passwords, biometrics, MFA, certificates\n- Happens first\n\n**Authorization (AuthZ)**: Verifying WHAT you can do\n- Grants permissions based on identity\n- \"Are you allowed to access this resource?\"\n- Methods: RBAC, ABAC, ACLs, policies\n- Happens after authentication\n\n**Example**: Logging into your email (authentication) vs. being able to access admin settings (authorization).",
    "example": "# Authentication - Verify identity\nfrom werkzeug.security import check_password_hash\n\ndef authenticate(username, password):\n    user = User.query.filter_by(username=username).first()\n    if user and check_password_hash(user.password_hash, password):\n        return user  # Authenticated\n    return None\n\n# Authorization - Check permissions\ndef authorize(user, resource, action):\n    # Role-Based Access Control (RBAC)\n    if action == 'delete' and 'admin' not in user.roles:\n        raise PermissionDenied(\"Admin role required\")\n    \n    # Attribute-Based Access Control (ABAC)\n    if resource.owner_id != user.id and 'admin' not in user.roles:\n        raise PermissionDenied(\"Not owner or admin\")\n\n# Flask decorator example\nfrom functools import wraps\n\ndef require_role(role):\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            if role not in current_user.roles:\n                abort(403)\n            return f(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@app.route('/admin')\n@login_required  # Authentication\n@require_role('admin')  # Authorization\ndef admin_panel():\n    return render_template('admin.html')"
  },
  {
    "id": 6,
    "question": "What is a hash function and what properties should a cryptographic hash have?",
    "answer": "A **hash function** maps arbitrary-size input to fixed-size output (digest/hash).\n\n**Cryptographic hash properties:**\n\n1. **Deterministic**: Same input always produces same output\n\n2. **Pre-image resistance**: Given hash h, hard to find input m where hash(m) = h\n\n3. **Second pre-image resistance**: Given input m1, hard to find different m2 where hash(m1) = hash(m2)\n\n4. **Collision resistance**: Hard to find any two different inputs with same hash\n\n5. **Avalanche effect**: Small input change causes drastically different output\n\n**Common algorithms**: SHA-256, SHA-3, BLAKE2/3\n**Broken/Weak**: MD5, SHA-1 (collision attacks found)",
    "example": "import hashlib\n\n# SHA-256 (recommended)\ndata = b\"Hello, World!\"\nhash_sha256 = hashlib.sha256(data).hexdigest()\nprint(f\"SHA-256: {hash_sha256}\")\n\n# Avalanche effect demonstration\ndata1 = b\"Hello\"\ndata2 = b\"Hellp\"  # One character different\nprint(hashlib.sha256(data1).hexdigest())\nprint(hashlib.sha256(data2).hexdigest())\n# Completely different hashes!\n\n# Password hashing - use specialized functions (bcrypt, argon2)\nimport bcrypt\n\npassword = b\"user_password\"\nsalt = bcrypt.gensalt(rounds=12)\nhashed = bcrypt.hashpw(password, salt)\n\n# Verify password\nif bcrypt.checkpw(password, hashed):\n    print(\"Password matches!\")\n\n# NEVER use plain SHA for passwords!\n# hashlib.sha256(password).hexdigest()  # BAD - vulnerable to rainbow tables"
  },
  {
    "id": 7,
    "question": "What is HTTPS/TLS and how does the TLS handshake work?",
    "answer": "**HTTPS** is HTTP over TLS (Transport Layer Security), providing encrypted communication.\n\n**TLS Handshake (simplified TLS 1.3):**\n\n1. **Client Hello**: Client sends supported cipher suites, TLS version, random number, key share\n\n2. **Server Hello**: Server chooses cipher suite, sends certificate, key share, random number\n\n3. **Key Derivation**: Both derive shared secret using ECDHE key exchange\n\n4. **Finished**: Both send encrypted \"finished\" message to verify handshake integrity\n\n**Benefits:**\n- Confidentiality (encryption)\n- Integrity (MAC)\n- Authentication (certificates)",
    "example": "# Python - Enforce HTTPS with proper verification\nimport requests\n\n# Good - Verifies SSL certificate\nresponse = requests.get('https://api.example.com', verify=True)\n\n# BAD - Never disable verification in production!\n# response = requests.get('https://api.example.com', verify=False)\n\n# Flask - Redirect HTTP to HTTPS\nfrom flask_tls import Tls\nTls(app)  # or use reverse proxy (nginx)\n\n# Node.js - Create HTTPS server\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('private-key.pem'),\n  cert: fs.readFileSync('certificate.pem')\n};\n\nhttps.createServer(options, (req, res) => {\n  res.writeHead(200);\n  res.end('Secure!');\n}).listen(443);\n\n# Check certificate with OpenSSL\n# openssl s_client -connect example.com:443 -servername example.com"
  },
  {
    "id": 8,
    "question": "What is Cross-Site Request Forgery (CSRF) and how do you prevent it?",
    "answer": "**CSRF** tricks authenticated users into performing unwanted actions on a trusted site by exploiting their existing session.\n\n**Attack scenario:**\n1. User logs into bank.com\n2. User visits malicious site\n3. Malicious site sends hidden request to bank.com/transfer\n4. Browser includes bank.com cookies automatically\n5. Transfer executes with user's credentials\n\n**Prevention:**\n- **CSRF tokens**: Unique token per session/request\n- **SameSite cookies**: Restrict cookie sending\n- **Double-submit cookies**\n- Check Origin/Referer headers\n- Re-authentication for sensitive actions",
    "example": "# Flask - CSRF protection with Flask-WTF\nfrom flask_wtf.csrf import CSRFProtect\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key'\ncsrf = CSRFProtect(app)\n\n# In template\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n    <!-- form fields -->\n</form>\n\n# Django - CSRF protection (enabled by default)\n<form method=\"post\">\n    {% csrf_token %}\n    <!-- form fields -->\n</form>\n\n# SameSite cookie attribute\nSet-Cookie: session=abc123; SameSite=Strict; Secure; HttpOnly\n\n# Express.js - csurf middleware\nconst csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.get('/form', csrfProtection, (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\napp.post('/process', csrfProtection, (req, res) => {\n  // Token automatically validated\n});"
  },
  {
    "id": 9,
    "question": "What is Multi-Factor Authentication (MFA) and what are the factor types?",
    "answer": "**MFA** requires two or more verification factors to gain access, significantly improving security.\n\n**Factor types:**\n\n**Something you know**: Password, PIN, security questions\n\n**Something you have**: Phone (SMS/TOTP), hardware token (YubiKey), smart card\n\n**Something you are**: Biometrics - fingerprint, face, iris, voice\n\n**Somewhere you are**: Geolocation, IP address (weaker factor)\n\n**Best practices:**\n- Avoid SMS (vulnerable to SIM swapping)\n- Prefer TOTP apps or hardware keys\n- FIDO2/WebAuthn for phishing resistance\n- Have backup codes for account recovery",
    "example": "# TOTP (Time-based One-Time Password) implementation\nimport pyotp\nimport qrcode\n\n# Generate secret for user (store securely)\nsecret = pyotp.random_base32()\n\n# Generate QR code for authenticator app\ntotp = pyotp.TOTP(secret)\nuri = totp.provisioning_uri(name=\"user@example.com\", issuer_name=\"MyApp\")\nqrcode.make(uri).save(\"totp_qr.png\")\n\n# Verify code from user\ndef verify_totp(user_secret, code):\n    totp = pyotp.TOTP(user_secret)\n    return totp.verify(code, valid_window=1)  # Allow 30s clock skew\n\n# WebAuthn (FIDO2) - More secure, phishing resistant\n# Server generates challenge, client signs with hardware key\n# Libraries: py_webauthn (Python), @simplewebauthn (JS)\n\n# Example verification flow\nif verify_password(username, password):  # Factor 1\n    if verify_totp(user.totp_secret, totp_code):  # Factor 2\n        create_session(user)\n    else:\n        return \"Invalid 2FA code\"\nelse:\n    return \"Invalid credentials\""
  },
  {
    "id": 10,
    "question": "What are the OWASP Top 10 vulnerabilities?",
    "answer": "**OWASP Top 10 (2021)** lists the most critical web application security risks:\n\n1. **Broken Access Control**: Unauthorized access to resources\n2. **Cryptographic Failures**: Weak crypto, exposed sensitive data\n3. **Injection**: SQL, NoSQL, OS, LDAP injection\n4. **Insecure Design**: Missing security controls in design\n5. **Security Misconfiguration**: Default configs, unnecessary features\n6. **Vulnerable Components**: Outdated libraries with known CVEs\n7. **Authentication Failures**: Weak passwords, session issues\n8. **Software/Data Integrity Failures**: Untrusted updates, CI/CD compromise\n9. **Logging & Monitoring Failures**: Missing audit trails\n10. **Server-Side Request Forgery (SSRF)**: Server fetches attacker-controlled URLs",
    "example": "# 1. Broken Access Control - Always verify authorization\n@app.route('/api/user/<user_id>/data')\n@login_required\ndef get_user_data(user_id):\n    if current_user.id != user_id and not current_user.is_admin:\n        abort(403)  # Must check authorization!\n    return get_data(user_id)\n\n# 6. Vulnerable Components - Keep dependencies updated\n# pip-audit (Python)\n# npm audit (Node.js)\n# dependabot (GitHub)\n\n# 9. Logging - Log security events\nimport logging\nlogger = logging.getLogger('security')\n\ndef login(username, password):\n    user = authenticate(username, password)\n    if user:\n        logger.info(f\"Successful login: {username} from {request.remote_addr}\")\n    else:\n        logger.warning(f\"Failed login attempt: {username} from {request.remote_addr}\")\n\n# 10. SSRF Prevention - Validate URLs\nfrom urllib.parse import urlparse\n\nALLOWED_HOSTS = ['api.trusted.com']\n\ndef fetch_url(url):\n    parsed = urlparse(url)\n    if parsed.hostname not in ALLOWED_HOSTS:\n        raise ValueError(\"URL not allowed\")\n    # Also block internal IPs (127.0.0.1, 10.x.x.x, 192.168.x.x)"
  },
  {
    "id": 11,
    "question": "What is a firewall and what are the different types?",
    "answer": "A **firewall** monitors and controls network traffic based on security rules, creating a barrier between trusted and untrusted networks.\n\n**Types:**\n\n**Packet Filtering**: Examines packet headers (IP, port). Simple, fast, stateless.\n\n**Stateful Inspection**: Tracks connection state, more context-aware.\n\n**Application Layer (WAF)**: Inspects application data (HTTP), detects XSS/SQLi.\n\n**Next-Gen (NGFW)**: Combines traditional firewall + IPS + application awareness + threat intelligence.\n\n**Host-based**: Runs on individual hosts (Windows Firewall, iptables).\n\n**Network-based**: Protects entire network segments.",
    "example": "# Linux iptables - Basic firewall rules\n# Block all incoming, allow outgoing\niptables -P INPUT DROP\niptables -P OUTPUT ACCEPT\n\n# Allow established connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH from specific IP\niptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT\n\n# Allow HTTP/HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Block specific IP\niptables -A INPUT -s 10.0.0.5 -j DROP\n\n# UFW (Uncomplicated Firewall) - Simpler interface\nufw default deny incoming\nufw default allow outgoing\nufw allow ssh\nufw allow 80/tcp\nufw enable\n\n# AWS Security Group (cloud firewall)\n# Inbound: Allow 443 from 0.0.0.0/0\n# Outbound: Allow all"
  },
  {
    "id": 12,
    "question": "What is the principle of least privilege?",
    "answer": "**Principle of Least Privilege (PoLP)** states that users, processes, and systems should have only the minimum permissions necessary to perform their tasks.\n\n**Benefits:**\n- Limits damage from compromised accounts\n- Reduces attack surface\n- Prevents accidental damage\n- Improves audit and compliance\n\n**Implementation:**\n- Default deny, explicitly grant\n- Role-based access control (RBAC)\n- Time-limited elevated access\n- Separate admin and regular accounts\n- Service accounts with specific permissions\n- Regular access reviews",
    "example": "# Database - Create limited user\nCREATE USER 'app_user'@'localhost' IDENTIFIED BY 'password';\nGRANT SELECT, INSERT, UPDATE ON mydb.users TO 'app_user'@'localhost';\n-- Don't grant DELETE, DROP, or access to other tables\n\n# AWS IAM - Minimal S3 policy\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\n      \"s3:GetObject\",\n      \"s3:PutObject\"\n    ],\n    \"Resource\": \"arn:aws:s3:::my-bucket/uploads/*\"\n  }]\n}\n\n# Linux - Run service as non-root\n# Create dedicated user\nuseradd -r -s /bin/false appuser\n\n# Run application as that user\nsu -s /bin/bash -c './app' appuser\n\n# Docker - Don't run as root\nFROM node:18\nRUN useradd -m appuser\nUSER appuser\nCOPY --chown=appuser:appuser . .\nCMD [\"node\", \"app.js\"]"
  },
  {
    "id": 13,
    "question": "What is a Man-in-the-Middle (MITM) attack and how do you prevent it?",
    "answer": "**MITM attack** occurs when an attacker secretly intercepts and possibly alters communication between two parties who believe they're communicating directly.\n\n**Attack vectors:**\n- ARP spoofing on local network\n- DNS spoofing/poisoning\n- Rogue WiFi access points\n- SSL stripping (downgrade HTTPS to HTTP)\n- Compromised certificates\n\n**Prevention:**\n- Use HTTPS everywhere (HSTS)\n- Certificate pinning for mobile apps\n- VPN on untrusted networks\n- DNSSEC for DNS integrity\n- Verify certificate warnings\n- 802.1X for network access",
    "example": "# HSTS Header - Force HTTPS\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\n\n# Python Flask - Add HSTS\nfrom flask_talisman import Talisman\nTalisman(app, force_https=True, strict_transport_security=True)\n\n# Certificate Pinning (Mobile) - Android\n// OkHttp certificate pinning\nval certificatePinner = CertificatePinner.Builder()\n    .add(\"api.example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .build()\n\nval client = OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build()\n\n# Python requests - Certificate pinning\nimport requests\nfrom requests_toolbelt.adapters.fingerprint import FingerprintAdapter\n\nsession = requests.Session()\nsession.mount(\n    'https://api.example.com',\n    FingerprintAdapter('AA:BB:CC:DD:...')  # Expected cert fingerprint\n)\n\n# Detect ARP spoofing\n# arpwatch - monitors ARP table changes\n# Static ARP entries for critical systems"
  },
  {
    "id": 14,
    "question": "What is a Zero Trust security model?",
    "answer": "**Zero Trust** is a security model based on \"never trust, always verify\" - no implicit trust based on network location.\n\n**Core principles:**\n\n1. **Verify explicitly**: Always authenticate and authorize based on all available data points\n\n2. **Least privilege access**: Just-in-time and just-enough-access (JIT/JEA)\n\n3. **Assume breach**: Minimize blast radius, segment access, encrypt end-to-end, use analytics\n\n**Key components:**\n- Strong identity verification (MFA)\n- Device health validation\n- Micro-segmentation\n- Continuous monitoring\n- Data-centric security\n- Encrypted communications everywhere",
    "example": "# Zero Trust Architecture Components:\n\n# 1. Identity-based access (not network-based)\n# Instead of: if (ip in internal_network) { allow }\n# Use: verify_identity() && verify_device() && check_context()\n\n# 2. Micro-segmentation - Each service authenticates\n# Service A calling Service B\nimport jwt\n\ndef call_service_b(data):\n    # Service A must authenticate to Service B\n    token = get_service_token('service-a', 'service-b')\n    response = requests.post(\n        'https://service-b/api',\n        headers={'Authorization': f'Bearer {token}'},\n        json=data\n    )\n    return response\n\n# 3. Continuous verification\n@app.before_request\ndef verify_request():\n    verify_token(request.headers.get('Authorization'))\n    verify_device_posture(request.headers.get('X-Device-ID'))\n    check_risk_score(current_user, request)\n    log_access(current_user, request.path)\n\n# 4. Network policies (Kubernetes example)\n# apiVersion: networking.k8s.io/v1\n# kind: NetworkPolicy\n# spec:\n#   podSelector: {matchLabels: {app: backend}}\n#   ingress:\n#   - from:\n#     - podSelector: {matchLabels: {app: frontend}}"
  },
  {
    "id": 15,
    "question": "What is penetration testing and what are its phases?",
    "answer": "**Penetration testing** is authorized simulated attacks on systems to identify security vulnerabilities before malicious actors exploit them.\n\n**Phases:**\n\n1. **Planning/Scoping**: Define targets, rules of engagement, legal agreements\n\n2. **Reconnaissance**: Gather information (passive/active). OSINT, network scanning\n\n3. **Scanning/Enumeration**: Port scanning, vulnerability scanning, service identification\n\n4. **Exploitation**: Attempt to exploit found vulnerabilities\n\n5. **Post-Exploitation**: Privilege escalation, lateral movement, data exfiltration\n\n6. **Reporting**: Document findings, risk ratings, remediation recommendations\n\n**Types**: Black box (no info), White box (full info), Gray box (partial info)",
    "example": "# Reconnaissance - Passive OSINT\n# whois example.com\n# dig example.com\n# theHarvester -d example.com -b google\n\n# Scanning - Nmap\nnmap -sV -sC -O target.com  # Version, scripts, OS detection\nnmap -p- target.com          # All ports\nnmap --script vuln target.com  # Vulnerability scripts\n\n# Vulnerability scanning\n# nikto -h https://target.com  # Web server scanner\n# sqlmap -u \"http://target.com/page?id=1\"  # SQL injection\n\n# Web application testing\n# OWASP ZAP or Burp Suite for intercepting/modifying requests\n\n# Password attacks (authorized testing only)\n# hydra -l admin -P wordlist.txt target.com ssh\n# hashcat -m 0 hashes.txt wordlist.txt  # Crack hashes\n\n# Post-exploitation\n# LinPEAS/WinPEAS for privilege escalation enumeration\n# Mimikatz for Windows credential extraction\n\n# Always document findings with:\n# - Vulnerability description\n# - CVSS score\n# - Proof of concept\n# - Remediation steps"
  },
  {
    "id": 16,
    "question": "What is a Security Operations Center (SOC) and what does it do?",
    "answer": "A **SOC** is a centralized unit that monitors, detects, analyzes, and responds to cybersecurity incidents 24/7.\n\n**Key functions:**\n- **Continuous monitoring**: SIEM, network traffic, endpoints\n- **Threat detection**: Identify anomalies and attacks\n- **Incident response**: Contain and remediate threats\n- **Threat intelligence**: Track emerging threats\n- **Vulnerability management**: Prioritize patching\n- **Compliance**: Ensure regulatory requirements\n\n**SOC tiers:**\n- **Tier 1**: Alert triage, initial analysis\n- **Tier 2**: Deep investigation, incident handling\n- **Tier 3**: Advanced threats, threat hunting, forensics",
    "example": "# SIEM Query Examples (Splunk-like syntax)\n\n# Detect brute force attempts\nindex=auth sourcetype=linux_secure \"Failed password\"\n| stats count by src_ip, user\n| where count > 10\n\n# Detect potential data exfiltration\nindex=network dest_port=443\n| stats sum(bytes_out) as total_bytes by src_ip\n| where total_bytes > 1000000000\n\n# Detect lateral movement (unusual internal connections)\nindex=network src_ip=10.* dest_ip=10.*\n| stats dc(dest_ip) as unique_dests by src_ip\n| where unique_dests > 50\n\n# Alert correlation - Multiple failed logins then success\nindex=auth \"Failed password\" OR \"Accepted password\"\n| transaction user maxspan=5m\n| where eventcount > 5 AND match(events, \"Accepted\")\n\n# Key metrics tracked:\n# - MTTD (Mean Time to Detect)\n# - MTTR (Mean Time to Respond)\n# - Alert volume and false positive rate\n# - Incidents by severity and type"
  },
  {
    "id": 17,
    "question": "What is JWT and what are its security considerations?",
    "answer": "**JWT (JSON Web Token)** is a compact, URL-safe token format for securely transmitting claims between parties.\n\n**Structure**: Header.Payload.Signature (Base64 encoded)\n\n**Security considerations:**\n\n- **Always verify signature**: Don't trust payload without verification\n- **Use strong algorithms**: RS256/ES256, avoid HS256 with weak secrets, never \"none\"\n- **Validate claims**: exp (expiry), iss (issuer), aud (audience)\n- **Short expiration**: Use refresh tokens for long sessions\n- **Don't store sensitive data**: Payload is encoded, not encrypted\n- **Secure transmission**: Always use HTTPS\n- **Secure storage**: HttpOnly cookies or secure storage",
    "example": "# Python - PyJWT\nimport jwt\nfrom datetime import datetime, timedelta\n\n# GOOD - RS256 with RSA keys\nprivate_key = open('private.pem').read()\npublic_key = open('public.pem').read()\n\npayload = {\n    'sub': 'user123',\n    'iat': datetime.utcnow(),\n    'exp': datetime.utcnow() + timedelta(hours=1),\n    'iss': 'myapp',\n    'aud': 'myapp-client'\n}\n\ntoken = jwt.encode(payload, private_key, algorithm='RS256')\n\n# Verify with all checks\ntry:\n    decoded = jwt.decode(\n        token,\n        public_key,\n        algorithms=['RS256'],  # Explicitly specify allowed algorithms!\n        audience='myapp-client',\n        issuer='myapp'\n    )\nexcept jwt.ExpiredSignatureError:\n    print(\"Token expired\")\nexcept jwt.InvalidTokenError:\n    print(\"Invalid token\")\n\n# BAD practices:\n# jwt.decode(token, options={\"verify_signature\": False})  # Never disable!\n# jwt.decode(token, algorithms=['none'])  # Algorithm confusion attack"
  },
  {
    "id": 18,
    "question": "What is a buffer overflow attack?",
    "answer": "**Buffer overflow** occurs when a program writes data beyond the allocated buffer boundary, potentially overwriting adjacent memory and allowing code execution.\n\n**Types:**\n- **Stack overflow**: Overwrite return address to hijack execution\n- **Heap overflow**: Corrupt heap metadata or function pointers\n- **Integer overflow**: Arithmetic overflow leads to small buffer allocation\n\n**Mitigations:**\n- **ASLR**: Randomize memory layout\n- **Stack canaries**: Detect stack corruption\n- **DEP/NX**: Non-executable stack/heap\n- **Safe functions**: strncpy vs strcpy, snprintf vs sprintf\n- **Memory-safe languages**: Rust, Go, Java",
    "example": "// VULNERABLE C code\n#include <string.h>\n\nvoid vulnerable(char *input) {\n    char buffer[64];\n    strcpy(buffer, input);  // No bounds checking!\n}\n\n// Attacker input longer than 64 bytes overwrites return address\n\n// SAFE - Use bounds-checked functions\nvoid safe(char *input) {\n    char buffer[64];\n    strncpy(buffer, input, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n}\n\n// Compile with protections\n// gcc -fstack-protector-strong -D_FORTIFY_SOURCE=2 -pie -fPIE program.c\n\n// Check binary protections\n// checksec --file=./program\n// RELRO:    Full RELRO\n// Stack:    Canary found\n// NX:       NX enabled\n// PIE:      PIE enabled\n\n// Memory-safe alternative (Rust)\nfn safe_rust(input: &str) {\n    let buffer: String = input.chars().take(64).collect();\n    // Rust prevents buffer overflows at compile time\n}"
  },
  {
    "id": 19,
    "question": "What is Public Key Infrastructure (PKI) and how does certificate validation work?",
    "answer": "**PKI** is a framework for managing digital certificates and public-key encryption, enabling secure communication and identity verification.\n\n**Components:**\n- **Certificate Authority (CA)**: Issues and signs certificates\n- **Registration Authority (RA)**: Verifies identity before cert issuance\n- **Certificate**: Binds public key to identity\n- **Certificate Revocation List (CRL)** / **OCSP**: Check if cert is revoked\n\n**Certificate validation:**\n1. Check signature chain to trusted root CA\n2. Verify certificate not expired\n3. Check revocation status (CRL/OCSP)\n4. Validate domain name matches\n5. Check key usage extensions",
    "example": "# View certificate details\nopenssl s_client -connect example.com:443 -servername example.com\nopenssl x509 -in cert.pem -text -noout\n\n# Verify certificate chain\nopenssl verify -CAfile ca-bundle.crt server.crt\n\n# Python - Certificate validation\nimport ssl\nimport socket\n\ndef verify_certificate(hostname, port=443):\n    context = ssl.create_default_context()\n    \n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            \n            # Check expiration\n            ssl.match_hostname(cert, hostname)\n            \n            print(f\"Subject: {cert['subject']}\")\n            print(f\"Issuer: {cert['issuer']}\")\n            print(f\"Valid until: {cert['notAfter']}\")\n\n# Generate self-signed certificate (testing only)\nopenssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n\n# Let's Encrypt - Free production certificates\n# certbot certonly --webroot -w /var/www/html -d example.com"
  },
  {
    "id": 20,
    "question": "What is security hardening and what are common hardening practices?",
    "answer": "**Security hardening** reduces the attack surface by removing unnecessary features, applying secure configurations, and following security best practices.\n\n**Common practices:**\n\n**OS Hardening:**\n- Remove unnecessary services/packages\n- Apply security patches\n- Configure host firewall\n- Enable audit logging\n- Disable root SSH login\n\n**Application Hardening:**\n- Remove default credentials\n- Disable debug mode\n- Security headers\n- Input validation\n- Error handling (no stack traces)\n\n**Network Hardening:**\n- Segment networks\n- Close unused ports\n- Enable encryption\n- IDS/IPS deployment",
    "example": "# SSH Hardening - /etc/ssh/sshd_config\nPermitRootLogin no\nPasswordAuthentication no  # Use keys only\nPubkeyAuthentication yes\nX11Forwarding no\nAllowUsers deploy admin\nMaxAuthTries 3\nClientAliveInterval 300\nClientAliveCountMax 2\n\n# Linux hardening\n# Disable unused services\nsystemctl disable bluetooth cups avahi-daemon\n\n# Set secure permissions\nchmod 700 /root\nchmod 600 /etc/shadow\n\n# Enable automatic security updates\napt install unattended-upgrades\ndpkg-reconfigure -plow unattended-upgrades\n\n# Nginx hardening\nserver_tokens off;  # Hide version\nadd_header X-Content-Type-Options nosniff;\nadd_header X-Frame-Options DENY;\nadd_header X-XSS-Protection \"1; mode=block\";\nadd_header Content-Security-Policy \"default-src 'self'\";\n\n# Kubernetes pod security\napiVersion: v1\nkind: Pod\nspec:\n  securityContext:\n    runAsNonRoot: true\n    readOnlyRootFilesystem: true\n    capabilities:\n      drop: [\"ALL\"]"
  },
  {
    "id": 21,
    "question": "What is a DDoS attack and how do you mitigate it?",
    "answer": "**DDoS (Distributed Denial of Service)** overwhelms a target with traffic from multiple sources, making services unavailable to legitimate users.\n\n**Types:**\n- **Volumetric**: Flood bandwidth (UDP flood, amplification attacks)\n- **Protocol**: Exploit protocol weaknesses (SYN flood, Ping of Death)\n- **Application Layer**: Target specific services (HTTP flood, Slowloris)\n\n**Mitigation:**\n- CDN/DDoS protection services (Cloudflare, AWS Shield)\n- Rate limiting and traffic shaping\n- Anycast network distribution\n- Web Application Firewall (WAF)\n- Over-provisioning bandwidth\n- Traffic analysis and anomaly detection",
    "example": "# Nginx rate limiting\nhttp {\n    limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;\n    \n    server {\n        location /api/ {\n            limit_req zone=one burst=20 nodelay;\n        }\n    }\n}\n\n# iptables - SYN flood protection\niptables -A INPUT -p tcp --syn -m limit --limit 1/s --limit-burst 3 -j ACCEPT\niptables -A INPUT -p tcp --syn -j DROP\n\n# AWS WAF rate-based rule (JSON)\n{\n  \"Name\": \"RateLimitRule\",\n  \"Priority\": 1,\n  \"Statement\": {\n    \"RateBasedStatement\": {\n      \"Limit\": 2000,\n      \"AggregateKeyType\": \"IP\"\n    }\n  },\n  \"Action\": { \"Block\": {} }\n}\n\n# Application-level rate limiting (Python/Flask)\nfrom flask_limiter import Limiter\nlimiter = Limiter(app, key_func=get_remote_address)\n\n@app.route('/api/resource')\n@limiter.limit('100/minute')\ndef resource():\n    return 'OK'"
  },
  {
    "id": 22,
    "question": "What is OAuth 2.0 and what are its grant types?",
    "answer": "**OAuth 2.0** is an authorization framework that enables third-party applications to access resources on behalf of users without sharing credentials.\n\n**Grant types:**\n\n**Authorization Code**: Most secure for server-side apps. Exchanges code for token.\n\n**Authorization Code + PKCE**: For mobile/SPA apps. Adds code verifier for security.\n\n**Client Credentials**: Machine-to-machine. No user involved.\n\n**Refresh Token**: Obtain new access token without re-authentication.\n\n**Implicit (deprecated)**: Token in URL fragment. Insecure, replaced by PKCE.\n\n**Resource Owner Password (deprecated)**: Direct username/password. Only for trusted apps.",
    "example": "# Authorization Code Flow with PKCE\nimport secrets\nimport hashlib\nimport base64\n\n# 1. Generate PKCE verifier and challenge\ncode_verifier = secrets.token_urlsafe(32)\ncode_challenge = base64.urlsafe_b64encode(\n    hashlib.sha256(code_verifier.encode()).digest()\n).rstrip(b'=').decode()\n\n# 2. Authorization request\nauth_url = (\n    f\"https://auth.example.com/authorize?\"\n    f\"response_type=code&\"\n    f\"client_id={client_id}&\"\n    f\"redirect_uri={redirect_uri}&\"\n    f\"scope=openid profile&\"\n    f\"code_challenge={code_challenge}&\"\n    f\"code_challenge_method=S256\"\n)\n\n# 3. Exchange code for token\ntoken_response = requests.post(\n    'https://auth.example.com/token',\n    data={\n        'grant_type': 'authorization_code',\n        'code': authorization_code,\n        'redirect_uri': redirect_uri,\n        'client_id': client_id,\n        'code_verifier': code_verifier  # PKCE verification\n    }\n)\naccess_token = token_response.json()['access_token']"
  },
  {
    "id": 23,
    "question": "What is a Security Information and Event Management (SIEM) system?",
    "answer": "**SIEM** collects, analyzes, and correlates security events from multiple sources to detect threats and support incident response.\n\n**Key capabilities:**\n- **Log aggregation**: Collect logs from servers, network devices, applications\n- **Event correlation**: Connect related events across systems\n- **Real-time alerting**: Notify on suspicious activity\n- **Threat detection**: Identify known attack patterns\n- **Compliance reporting**: Generate audit reports\n- **Forensic analysis**: Investigate incidents historically\n\n**Common SIEMs**: Splunk, Elastic SIEM, Microsoft Sentinel, IBM QRadar, Sumo Logic",
    "example": "# Splunk query examples\n\n# Failed login attempts by IP\nindex=auth sourcetype=linux_secure \"Failed password\"\n| stats count by src_ip\n| where count > 5\n| sort -count\n\n# Detect potential privilege escalation\nindex=linux sourcetype=syslog \"sudo\" OR \"su root\"\n| stats count by user, host\n| where count > 10\n\n# Correlate: Failed logins followed by success (brute force)\nindex=auth\n| transaction user maxspan=10m\n| search \"Failed password\" AND \"Accepted\"\n| where eventcount > 3\n\n# Elastic SIEM (KQL)\nevent.category:authentication AND event.outcome:failure\n| stats count by source.ip\n| where count > 10\n\n# Alert rule (pseudo-code)\nalert:\n  name: \"Brute Force Detection\"\n  condition: count(failed_logins) > 10 in 5m by source_ip\n  action: notify_soc, block_ip_temporary"
  },
  {
    "id": 24,
    "question": "What is input validation and what are best practices?",
    "answer": "**Input validation** ensures data conforms to expected format before processing, preventing injection attacks and data corruption.\n\n**Best practices:**\n\n**Allowlist over denylist**: Define what's allowed, reject everything else.\n\n**Validate on server side**: Client-side validation can be bypassed.\n\n**Validate type, length, format, range**: Check all applicable constraints.\n\n**Canonicalize before validation**: Decode/normalize input first.\n\n**Context-specific output encoding**: Encode for HTML, SQL, URL, etc.\n\n**Reject invalid input**: Don't try to sanitize/fix malformed data.\n\n**Use established libraries**: Don't write custom validation for emails, URLs, etc.",
    "example": "# Python - Input validation examples\nimport re\nfrom email_validator import validate_email\nfrom urllib.parse import urlparse\n\ndef validate_username(username: str) -> bool:\n    # Allowlist: alphanumeric, 3-20 chars\n    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):\n        raise ValueError(\"Invalid username\")\n    return True\n\ndef validate_age(age: str) -> int:\n    try:\n        age_int = int(age)\n        if not 0 <= age_int <= 150:\n            raise ValueError(\"Age out of range\")\n        return age_int\n    except ValueError:\n        raise ValueError(\"Invalid age\")\n\ndef validate_url(url: str, allowed_hosts: list) -> bool:\n    parsed = urlparse(url)\n    if parsed.scheme not in ('http', 'https'):\n        raise ValueError(\"Invalid scheme\")\n    if parsed.hostname not in allowed_hosts:\n        raise ValueError(\"Host not allowed\")\n    return True\n\n# Pydantic for structured validation\nfrom pydantic import BaseModel, EmailStr, constr, validator\n\nclass UserInput(BaseModel):\n    username: constr(regex=r'^[a-zA-Z0-9_]{3,20}$')\n    email: EmailStr\n    age: int\n    \n    @validator('age')\n    def age_must_be_valid(cls, v):\n        if not 0 <= v <= 150:\n            raise ValueError('Invalid age')\n        return v"
  },
  {
    "id": 25,
    "question": "What is a honeypot in cybersecurity?",
    "answer": "A **honeypot** is a decoy system designed to attract attackers, allowing security teams to study attack methods and detect intrusions.\n\n**Types:**\n\n**Low-interaction**: Simulates services, limited attacker engagement. Easy to deploy.\n\n**High-interaction**: Full systems attackers can compromise. Rich data but higher risk.\n\n**Research honeypots**: Study attack techniques and malware.\n\n**Production honeypots**: Detect intrusions in real environments.\n\n**Benefits:**\n- Early attack detection\n- Threat intelligence gathering\n- Attacker distraction\n- Low false positives (any interaction is suspicious)\n\n**Honeynets**: Networks of honeypots simulating realistic infrastructure.",
    "example": "# Simple SSH honeypot (Python - Cowrie-like)\nimport socket\nimport logging\n\nlogging.basicConfig(filename='honeypot.log', level=logging.INFO)\n\ndef fake_ssh_server(host='0.0.0.0', port=2222):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((host, port))\n    sock.listen(5)\n    \n    while True:\n        conn, addr = sock.accept()\n        logging.warning(f\"Connection from {addr[0]}:{addr[1]}\")\n        \n        # Send SSH banner\n        conn.send(b\"SSH-2.0-OpenSSH_7.4\\r\\n\")\n        \n        # Log attempted credentials\n        try:\n            data = conn.recv(1024)\n            logging.warning(f\"Data received: {data}\")\n        except:\n            pass\n        \n        conn.close()\n\n# Popular honeypot tools:\n# - Cowrie: SSH/Telnet honeypot\n# - Dionaea: Malware-capturing honeypot\n# - HoneyD: Low-interaction, simulates network\n# - T-Pot: All-in-one honeypot platform\n\n# Deploy honeypot on non-standard port, redirect real service\n# iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port 2222"
  },
  {
    "id": 26,
    "question": "What is privilege escalation and what are common techniques?",
    "answer": "**Privilege escalation** is gaining higher access rights than originally granted, either vertically (user to admin) or horizontally (accessing other users' data).\n\n**Vertical escalation techniques:**\n- Exploiting SUID/SUDO misconfigurations\n- Kernel exploits\n- Service misconfigurations\n- Credential theft\n- DLL hijacking (Windows)\n\n**Horizontal escalation:**\n- IDOR (Insecure Direct Object Reference)\n- Session hijacking\n- Parameter tampering\n\n**Prevention:**\n- Principle of least privilege\n- Regular patching\n- Audit SUID binaries and sudo rules\n- Input validation for user identifiers",
    "example": "# Linux privilege escalation enumeration\n\n# Check sudo permissions\nsudo -l\n\n# Find SUID binaries\nfind / -perm -4000 -type f 2>/dev/null\n\n# Check for writable /etc/passwd\nls -la /etc/passwd\n\n# Find world-writable directories\nfind / -type d -perm -0002 2>/dev/null\n\n# Check cron jobs\ncat /etc/crontab\nls -la /etc/cron.*\n\n# Kernel version (check for exploits)\nuname -a\n\n# Common sudo misconfigurations to exploit:\n# sudo vim -> :!/bin/bash\n# sudo less /etc/passwd -> !/bin/bash\n# sudo find / -exec /bin/bash \\;\n# sudo python -c 'import os; os.system(\"/bin/bash\")'\n\n# IDOR prevention (always verify authorization)\n@app.route('/api/user/<user_id>/data')\ndef get_user_data(user_id):\n    # BAD: No authorization check\n    # return User.query.get(user_id).data\n    \n    # GOOD: Verify user owns the resource\n    if current_user.id != int(user_id):\n        abort(403)\n    return User.query.get(user_id).data"
  },
  {
    "id": 27,
    "question": "What is a Web Application Firewall (WAF) and how does it work?",
    "answer": "A **WAF** monitors, filters, and blocks HTTP traffic to/from web applications, protecting against application-layer attacks.\n\n**How it works:**\n- Inspects HTTP requests/responses\n- Applies rules to detect malicious patterns\n- Blocks or alerts on suspicious traffic\n- Can operate in block or monitor mode\n\n**Protection against:**\n- SQL injection, XSS, CSRF\n- File inclusion attacks\n- Bot traffic and scraping\n- Protocol violations\n- Known vulnerability exploits (virtual patching)\n\n**Deployment modes:**\n- Reverse proxy (inline)\n- Cloud-based (CDN integration)\n- Host-based (server module)",
    "example": "# ModSecurity WAF rules (Apache/Nginx)\n\n# Block SQL injection patterns\nSecRule ARGS \"@detectSQLi\" \\\n    \"id:1001,phase:2,deny,status:403,msg:'SQL Injection Detected'\"\n\n# Block XSS patterns\nSecRule ARGS \"@detectXSS\" \\\n    \"id:1002,phase:2,deny,status:403,msg:'XSS Detected'\"\n\n# Block common attack patterns\nSecRule REQUEST_URI \"@contains /etc/passwd\" \\\n    \"id:1003,phase:1,deny,status:403\"\n\n# Rate limiting\nSecRule IP:REQUEST_COUNT \"@gt 100\" \\\n    \"id:1004,phase:1,deny,status:429,msg:'Rate limit exceeded'\"\n\n# AWS WAF rule (Terraform)\nresource \"aws_wafv2_rule_group\" \"example\" {\n  name     = \"block-sqli\"\n  scope    = \"REGIONAL\"\n  capacity = 50\n\n  rule {\n    name     = \"SQLiRule\"\n    priority = 1\n\n    statement {\n      sqli_match_statement {\n        field_to_match { body {} }\n        text_transformation {\n          priority = 0\n          type     = \"URL_DECODE\"\n        }\n      }\n    }\n    action { block {} }\n  }\n}"
  },
  {
    "id": 28,
    "question": "What is secure coding and what are OWASP secure coding practices?",
    "answer": "**Secure coding** integrates security into the software development process, preventing vulnerabilities at the source.\n\n**OWASP Secure Coding Practices:**\n\n1. **Input Validation**: Validate all input on server side\n2. **Output Encoding**: Encode output for context (HTML, SQL, etc.)\n3. **Authentication/Password Management**: Strong passwords, MFA, secure storage\n4. **Session Management**: Secure session IDs, timeouts, invalidation\n5. **Access Control**: Deny by default, check on every request\n6. **Cryptographic Practices**: Strong algorithms, secure key management\n7. **Error Handling**: Don't leak sensitive info in errors\n8. **Data Protection**: Encrypt sensitive data, minimize data collection\n9. **Communication Security**: Use TLS everywhere\n10. **Database Security**: Parameterized queries, least privilege",
    "example": "# Secure coding examples\n\n# 1. Input validation\ndef process_user_input(data: str) -> str:\n    if not re.match(r'^[a-zA-Z0-9]{1,100}$', data):\n        raise ValueError(\"Invalid input\")\n    return data\n\n# 3. Password management\nfrom argon2 import PasswordHasher\nph = PasswordHasher()\nhash = ph.hash(password)\nph.verify(hash, password)  # Raises exception if invalid\n\n# 5. Access control on every request\n@app.before_request\ndef check_authorization():\n    if request.endpoint in protected_endpoints:\n        if not current_user.has_permission(request.endpoint):\n            abort(403)\n\n# 7. Secure error handling\n@app.errorhandler(Exception)\ndef handle_error(e):\n    app.logger.error(f\"Error: {e}\", exc_info=True)  # Log full error\n    return {\"error\": \"An error occurred\"}, 500  # Generic message to user\n\n# 8. Data protection - Encrypt PII\nfrom cryptography.fernet import Fernet\n\nclass User(db.Model):\n    _ssn = db.Column(db.LargeBinary)  # Encrypted\n    \n    @property\n    def ssn(self):\n        return cipher.decrypt(self._ssn).decode()\n    \n    @ssn.setter\n    def ssn(self, value):\n        self._ssn = cipher.encrypt(value.encode())"
  },
  {
    "id": 29,
    "question": "What is network segmentation and why is it important?",
    "answer": "**Network segmentation** divides a network into smaller, isolated segments to limit lateral movement and contain breaches.\n\n**Benefits:**\n- **Limits blast radius**: Compromise in one segment doesn't spread\n- **Improves monitoring**: Easier to detect anomalies in smaller segments\n- **Compliance**: Isolate systems handling sensitive data (PCI DSS)\n- **Performance**: Reduces broadcast traffic\n\n**Segmentation strategies:**\n- **VLANs**: Layer 2 separation\n- **Subnets**: Layer 3 separation with routing\n- **Firewalls**: Control traffic between segments\n- **Micro-segmentation**: Application-level isolation (Zero Trust)\n- **Air gap**: Physical isolation for critical systems",
    "example": "# Network segmentation example\n\n# VLANs:\n# VLAN 10: Web servers (DMZ) - 10.0.10.0/24\n# VLAN 20: Application servers - 10.0.20.0/24\n# VLAN 30: Database servers - 10.0.30.0/24\n# VLAN 40: Management - 10.0.40.0/24\n\n# Firewall rules between segments\n# DMZ -> App: Allow TCP 8080\niptables -A FORWARD -s 10.0.10.0/24 -d 10.0.20.0/24 -p tcp --dport 8080 -j ACCEPT\n\n# App -> DB: Allow TCP 5432 (PostgreSQL)\niptables -A FORWARD -s 10.0.20.0/24 -d 10.0.30.0/24 -p tcp --dport 5432 -j ACCEPT\n\n# DB -> Internet: Deny all\niptables -A FORWARD -s 10.0.30.0/24 -d 0.0.0.0/0 -j DROP\n\n# Kubernetes Network Policy (micro-segmentation)\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: db-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: database\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: backend\n    ports:\n    - port: 5432"
  },
  {
    "id": 30,
    "question": "What is malware and what are the common types?",
    "answer": "**Malware** is malicious software designed to damage, disrupt, or gain unauthorized access to systems.\n\n**Common types:**\n\n**Virus**: Self-replicating, attaches to files, requires user action to spread.\n\n**Worm**: Self-propagating across networks without user action.\n\n**Trojan**: Disguised as legitimate software, provides backdoor access.\n\n**Ransomware**: Encrypts data, demands payment for decryption.\n\n**Spyware**: Secretly monitors user activity, steals data.\n\n**Rootkit**: Hides malware presence, provides persistent access.\n\n**Keylogger**: Records keystrokes to steal credentials.\n\n**Botnet**: Network of compromised machines controlled remotely.",
    "example": "# Malware detection indicators\n\n# Check for suspicious processes\nps aux | grep -E '(cryptominer|backdoor|shell)'\n\n# Check for unusual network connections\nnetstat -tulpn | grep ESTABLISHED\nss -tulpn\n\n# Check for modified system binaries\nrpm -Va  # RedHat/CentOS\ndebsums -c  # Debian/Ubuntu\n\n# Check for rootkits\nchkrootkit\nrkhunter --check\n\n# Suspicious file indicators\nfind / -name \"*.php\" -mtime -1  # Recently modified PHP files\nfind /tmp -type f -executable    # Executables in /tmp\n\n# YARA rule example for malware detection\nrule SuspiciousShell {\n    strings:\n        $s1 = \"/bin/sh\" nocase\n        $s2 = \"eval(base64_decode\" nocase\n        $s3 = \"<?php @eval($_\" nocase\n    condition:\n        any of them\n}\n\n# Prevention best practices:\n# - Keep systems patched\n# - Use antivirus/EDR\n# - Email filtering\n# - Application whitelisting\n# - User awareness training\n# - Network monitoring"
  },
  {
    "id": 31,
    "question": "What is a VPN and how does it provide security?",
    "answer": "**VPN (Virtual Private Network)** creates an encrypted tunnel between your device and a VPN server, securing traffic over untrusted networks.\n\n**Security benefits:**\n- **Encryption**: Traffic encrypted end-to-end\n- **Privacy**: Hides real IP address\n- **Bypass restrictions**: Access geo-blocked content\n- **Secure remote access**: Connect to corporate network safely\n\n**Types:**\n- **Remote Access VPN**: Individual user to network\n- **Site-to-Site VPN**: Connect two networks\n- **SSL/TLS VPN**: Browser-based, no client needed\n\n**Protocols**: WireGuard, OpenVPN, IPSec/IKEv2, L2TP\n\n**Limitations**: VPN provider can see traffic, endpoint security still matters.",
    "example": "# WireGuard server configuration\n# /etc/wireguard/wg0.conf\n[Interface]\nAddress = 10.0.0.1/24\nPrivateKey = <server_private_key>\nListenPort = 51820\nPostUp = iptables -A FORWARD -i wg0 -j ACCEPT\nPostDown = iptables -D FORWARD -i wg0 -j ACCEPT\n\n[Peer]\nPublicKey = <client_public_key>\nAllowedIPs = 10.0.0.2/32\n\n# Start WireGuard\nwg-quick up wg0\n\n# Client configuration\n[Interface]\nAddress = 10.0.0.2/24\nPrivateKey = <client_private_key>\nDNS = 1.1.1.1\n\n[Peer]\nPublicKey = <server_public_key>\nEndpoint = vpn.example.com:51820\nAllowedIPs = 0.0.0.0/0  # Route all traffic through VPN\nPersistentKeepalive = 25\n\n# OpenVPN client connection\nopenvpn --config client.ovpn\n\n# IPSec/IKEv2 with strongSwan\nconn vpn-connection\n    type=tunnel\n    left=%defaultroute\n    right=vpn.example.com\n    rightauth=pubkey\n    auto=start"
  },
  {
    "id": 32,
    "question": "What is phishing and how do you protect against it?",
    "answer": "**Phishing** is social engineering attack using fraudulent communications to trick users into revealing sensitive information or installing malware.\n\n**Types:**\n- **Email phishing**: Mass emails impersonating trusted entities\n- **Spear phishing**: Targeted attacks on specific individuals\n- **Whaling**: Targeting executives/high-value targets\n- **Smishing**: SMS-based phishing\n- **Vishing**: Voice/phone phishing\n\n**Protection:**\n- **Technical**: Email filtering, DMARC/SPF/DKIM, URL filtering\n- **User training**: Security awareness programs\n- **MFA**: Limits damage from stolen credentials\n- **Reporting mechanism**: Easy way to report suspicious emails\n- **Verify requests**: Out-of-band verification for sensitive requests",
    "example": "# Email authentication (DNS records)\n\n# SPF - Specify authorized mail servers\n# v=spf1 include:_spf.google.com ~all\n\n# DKIM - Sign emails cryptographically\n# selector._domainkey.example.com TXT \"v=DKIM1; k=rsa; p=MIIBIj...\"\n\n# DMARC - Policy for failed authentication\n# _dmarc.example.com TXT \"v=DMARC1; p=reject; rua=mailto:dmarc@example.com\"\n\n# Phishing indicators to check:\n# - Sender address mismatch (display name vs actual email)\n# - Urgency/fear tactics\n# - Generic greetings\n# - Suspicious links (hover to check)\n# - Unexpected attachments\n# - Grammar/spelling errors\n\n# Python - Check URL against known phishing\nimport requests\n\ndef check_url_reputation(url: str) -> bool:\n    # Google Safe Browsing API\n    api_url = \"https://safebrowsing.googleapis.com/v4/threatMatches:find\"\n    payload = {\n        \"threatInfo\": {\n            \"threatTypes\": [\"MALWARE\", \"SOCIAL_ENGINEERING\"],\n            \"platformTypes\": [\"ANY_PLATFORM\"],\n            \"threatEntryTypes\": [\"URL\"],\n            \"threatEntries\": [{\"url\": url}]\n        }\n    }\n    response = requests.post(api_url, json=payload)\n    return len(response.json().get('matches', [])) == 0"
  },
  {
    "id": 33,
    "question": "What is a digital signature and how does it work?",
    "answer": "A **digital signature** uses asymmetric cryptography to verify the authenticity and integrity of a message or document.\n\n**How it works:**\n1. **Signing**: Create hash of message, encrypt hash with private key\n2. **Verification**: Decrypt signature with public key, compare with computed hash\n\n**Properties:**\n- **Authentication**: Proves signer's identity\n- **Integrity**: Detects if message was modified\n- **Non-repudiation**: Signer cannot deny signing\n\n**Use cases:**\n- Code signing\n- Document signing (PDF, contracts)\n- Email (S/MIME, PGP)\n- TLS certificates\n- Software updates",
    "example": "# Python - Create and verify digital signatures\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.exceptions import InvalidSignature\n\n# Generate key pair\nprivate_key = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048\n)\npublic_key = private_key.public_key()\n\nmessage = b\"Important document content\"\n\n# Sign message\nsignature = private_key.sign(\n    message,\n    padding.PSS(\n        mgf=padding.MGF1(hashes.SHA256()),\n        salt_length=padding.PSS.MAX_LENGTH\n    ),\n    hashes.SHA256()\n)\n\n# Verify signature\ntry:\n    public_key.verify(\n        signature,\n        message,\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    print(\"Signature valid!\")\nexcept InvalidSignature:\n    print(\"Signature invalid!\")\n\n# GPG command line\n# Sign: gpg --sign document.pdf\n# Verify: gpg --verify document.pdf.gpg"
  },
  {
    "id": 34,
    "question": "What is an Intrusion Detection/Prevention System (IDS/IPS)?",
    "answer": "**IDS (Intrusion Detection System)** monitors network/host for malicious activity and alerts administrators.\n\n**IPS (Intrusion Prevention System)** actively blocks detected threats in real-time.\n\n**Types:**\n- **Network-based (NIDS/NIPS)**: Monitors network traffic\n- **Host-based (HIDS/HIPS)**: Monitors individual hosts\n\n**Detection methods:**\n- **Signature-based**: Match known attack patterns\n- **Anomaly-based**: Detect deviations from baseline\n- **Behavior-based**: Analyze behavior patterns\n\n**Popular tools:**\n- Snort, Suricata (NIDS)\n- OSSEC, Wazuh (HIDS)\n- Fail2ban (automated response)",
    "example": "# Snort IDS rule examples\n\n# Detect SQL injection attempt\nalert tcp any any -> $HOME_NET 80 (\n    msg:\"SQL Injection Attempt\";\n    content:\"UNION SELECT\";\n    nocase;\n    sid:1000001;\n    rev:1;\n)\n\n# Detect SSH brute force\nalert tcp any any -> $HOME_NET 22 (\n    msg:\"SSH Brute Force\";\n    flow:to_server;\n    threshold:type both, track by_src, count 5, seconds 60;\n    sid:1000002;\n)\n\n# Suricata rule for outbound malware C2\nalert http $HOME_NET any -> $EXTERNAL_NET any (\n    msg:\"Possible C2 Communication\";\n    http.host; content:\"malware-c2.com\";\n    sid:1000003;\n)\n\n# Fail2ban configuration for SSH\n# /etc/fail2ban/jail.local\n[sshd]\nenabled = true\nport = ssh\nfilter = sshd\nlogpath = /var/log/auth.log\nmaxretry = 3\nbantime = 3600\nfindtime = 600\n\n# OSSEC active response\n<active-response>\n    <command>firewall-drop</command>\n    <location>local</location>\n    <rules_id>5712</rules_id>\n    <timeout>600</timeout>\n</active-response>"
  },
  {
    "id": 35,
    "question": "What is secrets management and what are best practices?",
    "answer": "**Secrets management** securely stores, accesses, and manages sensitive credentials like API keys, passwords, certificates, and encryption keys.\n\n**Best practices:**\n\n- **Never hardcode secrets**: No secrets in code or version control\n- **Use secrets manager**: HashiCorp Vault, AWS Secrets Manager, Azure Key Vault\n- **Rotate secrets regularly**: Automate rotation where possible\n- **Audit access**: Log who accessed what secrets when\n- **Encrypt at rest and in transit**: Secrets encrypted in storage\n- **Least privilege**: Minimal access to secrets\n- **Environment-specific**: Different secrets per environment\n- **Detect leaks**: Scan repos for accidentally committed secrets",
    "example": "# BAD - Hardcoded secrets\nAPI_KEY = \"sk-1234567890abcdef\"  # Never do this!\n\n# GOOD - Environment variables\nimport os\napi_key = os.environ.get('API_KEY')\n\n# BETTER - Secrets manager (AWS)\nimport boto3\n\ndef get_secret(secret_name):\n    client = boto3.client('secretsmanager')\n    response = client.get_secret_value(SecretId=secret_name)\n    return response['SecretString']\n\napi_key = get_secret('prod/api-key')\n\n# HashiCorp Vault\nimport hvac\n\nclient = hvac.Client(url='https://vault.example.com')\nclient.token = os.environ['VAULT_TOKEN']\nsecret = client.secrets.kv.read_secret_version(path='myapp/config')\napi_key = secret['data']['data']['api_key']\n\n# Kubernetes secrets\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-credentials\ntype: Opaque\ndata:\n  api-key: c2stMTIzNDU2Nzg5MA==  # base64 encoded\n\n# Git pre-commit hook to detect secrets\n# pip install detect-secrets\n# detect-secrets scan > .secrets.baseline"
  },
  {
    "id": 36,
    "question": "What is threat modeling and how do you perform it?",
    "answer": "**Threat modeling** systematically identifies and prioritizes potential threats to a system, helping focus security efforts.\n\n**Popular frameworks:**\n\n**STRIDE** (Microsoft):\n- **S**poofing identity\n- **T**ampering with data\n- **R**epudiation\n- **I**nformation disclosure\n- **D**enial of service\n- **E**levation of privilege\n\n**Steps:**\n1. **Decompose application**: Identify components, data flows, trust boundaries\n2. **Identify threats**: Apply framework (STRIDE) to each component\n3. **Rate threats**: Risk = Likelihood  Impact\n4. **Mitigate**: Design countermeasures\n5. **Validate**: Verify mitigations are effective",
    "example": "# Threat modeling example - Web application\n\n# 1. System components:\n# - Web frontend (React)\n# - API server (Node.js)\n# - Database (PostgreSQL)\n# - Authentication (OAuth)\n\n# 2. Data Flow Diagram (DFD) elements:\n# - External entities: Users, Third-party APIs\n# - Processes: Auth service, API handlers\n# - Data stores: User DB, Session store\n# - Trust boundaries: Internet/DMZ, DMZ/Internal\n\n# 3. STRIDE analysis for API Server:\nthreats = {\n    \"Spoofing\": {\n        \"threat\": \"Attacker impersonates legitimate user\",\n        \"mitigation\": \"JWT validation, MFA\"\n    },\n    \"Tampering\": {\n        \"threat\": \"API request modification\",\n        \"mitigation\": \"Input validation, HTTPS, request signing\"\n    },\n    \"Repudiation\": {\n        \"threat\": \"User denies actions\",\n        \"mitigation\": \"Comprehensive audit logging\"\n    },\n    \"Information Disclosure\": {\n        \"threat\": \"Sensitive data leaked\",\n        \"mitigation\": \"Encryption, access controls, data masking\"\n    },\n    \"Denial of Service\": {\n        \"threat\": \"API overwhelmed\",\n        \"mitigation\": \"Rate limiting, WAF, auto-scaling\"\n    },\n    \"Elevation of Privilege\": {\n        \"threat\": \"User gains admin access\",\n        \"mitigation\": \"RBAC, input validation, secure session management\"\n    }\n}\n\n# Tools: Microsoft Threat Modeling Tool, OWASP Threat Dragon"
  },
  {
    "id": 37,
    "question": "What is Container Security and what are best practices?",
    "answer": "**Container security** protects containerized applications throughout their lifecycle: build, ship, and run.\n\n**Key areas:**\n\n**Image security:**\n- Use minimal base images (Alpine, distroless)\n- Scan for vulnerabilities\n- Don't run as root\n- Sign and verify images\n\n**Runtime security:**\n- Read-only file systems\n- Drop capabilities\n- Resource limits\n- Network policies\n- Seccomp/AppArmor profiles\n\n**Orchestration security:**\n- RBAC for Kubernetes\n- Pod security policies/standards\n- Secrets management\n- Network segmentation",
    "example": "# Secure Dockerfile\nFROM alpine:3.18 AS builder\nRUN apk add --no-cache build-base\nCOPY . /app\nRUN make build\n\n# Minimal runtime image\nFROM gcr.io/distroless/static\nCOPY --from=builder /app/bin /\nUSER nonroot:nonroot\nENTRYPOINT [\"/app\"]\n\n# Scan image for vulnerabilities\n# trivy image myapp:latest\n# grype myapp:latest\n\n# Kubernetes Pod Security\napiVersion: v1\nkind: Pod\nspec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    fsGroup: 1000\n  containers:\n  - name: app\n    image: myapp:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop: [\"ALL\"]\n    resources:\n      limits:\n        memory: \"128Mi\"\n        cpu: \"500m\"\n    volumeMounts:\n    - name: tmp\n      mountPath: /tmp\n  volumes:\n  - name: tmp\n    emptyDir: {}\n\n# Network Policy - Restrict egress\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nspec:\n  podSelector: {}\n  policyTypes: [\"Egress\"]\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: database"
  },
  {
    "id": 38,
    "question": "What is API security and what are common vulnerabilities?",
    "answer": "**API security** protects APIs from attacks and misuse, ensuring data confidentiality, integrity, and availability.\n\n**Common vulnerabilities (OWASP API Top 10):**\n\n1. **Broken Object Level Authorization**: Accessing other users' data\n2. **Broken Authentication**: Weak auth mechanisms\n3. **Broken Object Property Level Authorization**: Exposing sensitive fields\n4. **Unrestricted Resource Consumption**: No rate limits\n5. **Broken Function Level Authorization**: Accessing admin functions\n6. **Mass Assignment**: Binding unintended parameters\n7. **Security Misconfiguration**: Verbose errors, missing headers\n8. **Injection**: SQLi, NoSQLi, command injection\n9. **Improper Asset Management**: Undocumented/deprecated endpoints\n10. **Unsafe API Consumption**: Trusting third-party APIs",
    "example": "# API Security best practices\n\n# 1. Object-level authorization\n@app.route('/api/orders/<order_id>')\ndef get_order(order_id):\n    order = Order.query.get(order_id)\n    if order.user_id != current_user.id:  # Always check!\n        abort(403)\n    return order.to_dict()\n\n# 3. Field-level authorization (don't expose sensitive fields)\nclass UserSchema(Schema):\n    id = fields.Int()\n    name = fields.Str()\n    email = fields.Str()\n    # password_hash = fields.Str()  # Never expose!\n    # ssn = fields.Str()  # Only for authorized roles\n\n# 4. Rate limiting\nfrom flask_limiter import Limiter\nlimiter = Limiter(app)\n\n@app.route('/api/login', methods=['POST'])\n@limiter.limit('5/minute')\ndef login():\n    pass\n\n# 6. Prevent mass assignment\n@app.route('/api/users/<id>', methods=['PUT'])\ndef update_user(id):\n    allowed_fields = ['name', 'email']  # Whitelist fields\n    data = {k: v for k, v in request.json.items() if k in allowed_fields}\n    # Don't allow: is_admin, role, balance, etc.\n\n# Security headers\n@app.after_request\ndef add_security_headers(response):\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    response.headers['X-Frame-Options'] = 'DENY'\n    response.headers['Cache-Control'] = 'no-store'\n    return response"
  },
  {
    "id": 39,
    "question": "What is Security by Design and Defense in Depth?",
    "answer": "**Security by Design** integrates security throughout the development lifecycle, not as an afterthought.\n\n**Principles:**\n- Minimize attack surface\n- Secure defaults\n- Principle of least privilege\n- Fail securely\n- Don't trust services\n- Separation of duties\n- Keep security simple\n\n**Defense in Depth** layers multiple security controls so if one fails, others provide protection.\n\n**Layers:**\n- Physical security\n- Network security (firewalls, segmentation)\n- Host security (hardening, AV)\n- Application security (secure coding, WAF)\n- Data security (encryption, access controls)\n- Policies and procedures",
    "example": "# Defense in Depth example - Web application\n\n# Layer 1: Network\n# - CDN with DDoS protection\n# - WAF blocking common attacks\n# - Network segmentation\n\n# Layer 2: Transport\n# - TLS 1.3 only\n# - HSTS enabled\n# - Certificate pinning (mobile)\n\n# Layer 3: Application\nfrom flask import Flask\nfrom flask_talisman import Talisman\n\napp = Flask(__name__)\nTalisman(app, \n    force_https=True,\n    strict_transport_security=True,\n    content_security_policy={'default-src': \"'self'\"})\n\n# Input validation\n@app.route('/api/data', methods=['POST'])\ndef create_data():\n    schema = DataSchema()\n    data = schema.load(request.json)  # Validates input\n    # Parameterized query (SQL injection prevention)\n    db.execute(\"INSERT INTO data (value) VALUES (?)\", [data['value']])\n\n# Layer 4: Data\n# - Encryption at rest (database, files)\n# - Field-level encryption for PII\n# - Secure key management (Vault)\n\n# Layer 5: Monitoring\n# - SIEM integration\n# - Anomaly detection\n# - Security alerts\n\n# Layer 6: Response\n# - Incident response plan\n# - Automated blocking\n# - Forensic capabilities"
  },
  {
    "id": 40,
    "question": "What is a security audit and what does it involve?",
    "answer": "A **security audit** systematically evaluates an organization's security posture against standards, policies, or regulatory requirements.\n\n**Types:**\n- **Internal audit**: Conducted by organization's own team\n- **External audit**: Independent third-party assessment\n- **Compliance audit**: Verify regulatory compliance (SOC 2, PCI DSS, HIPAA)\n\n**Components:**\n\n1. **Policy review**: Evaluate security policies and procedures\n2. **Technical assessment**: Vulnerability scanning, configuration review\n3. **Access control review**: User permissions, authentication mechanisms\n4. **Physical security**: Data center, device security\n5. **Incident response**: Test plans and procedures\n6. **Documentation**: Findings, risks, recommendations",
    "example": "# Security audit checklist example\n\n# Access Control\naudit_checklist = {\n    \"access_control\": [\n        \"MFA enabled for all users\",\n        \"Service accounts have minimal permissions\",\n        \"Access reviews conducted quarterly\",\n        \"Terminated employee access revoked within 24h\",\n        \"Privileged access is logged and monitored\"\n    ],\n    \"network_security\": [\n        \"Firewalls configured with deny-by-default\",\n        \"Network segmentation implemented\",\n        \"VPN required for remote access\",\n        \"IDS/IPS deployed and monitored\",\n        \"Unused ports/services disabled\"\n    ],\n    \"data_protection\": [\n        \"Data classified by sensitivity\",\n        \"Encryption at rest for sensitive data\",\n        \"TLS 1.2+ for data in transit\",\n        \"Backup encryption enabled\",\n        \"Data retention policies enforced\"\n    ],\n    \"vulnerability_management\": [\n        \"Regular vulnerability scans scheduled\",\n        \"Critical patches applied within 7 days\",\n        \"Penetration testing conducted annually\",\n        \"Third-party dependencies tracked\",\n        \"Remediation tracking in place\"\n    ]\n}\n\n# Automated compliance checks\n# - AWS Config Rules\n# - Azure Policy\n# - Chef InSpec\n# - OpenSCAP\n\n# InSpec example\ncontrol 'ssh-config' do\n  describe sshd_config do\n    its('PermitRootLogin') { should eq 'no' }\n    its('PasswordAuthentication') { should eq 'no' }\n  end\nend"
  },
  {
    "id": 41,
    "question": "What is the difference between vulnerability scanning and penetration testing?",
    "answer": "**Vulnerability Scanning:**\n- Automated tools identify known vulnerabilities\n- Broad coverage, shallow depth\n- Safe, non-intrusive\n- Can run frequently (daily/weekly)\n- Produces list of potential vulnerabilities\n- May have false positives\n\n**Penetration Testing:**\n- Human-driven, simulates real attacks\n- Deep exploration, targeted\n- Attempts actual exploitation\n- Periodic (quarterly/annually)\n- Proves vulnerabilities are exploitable\n- Discovers logic flaws and chained attacks\n\n**Both are complementary**: Scanning for continuous monitoring, pentesting for thorough assessment.",
    "example": "# Vulnerability Scanning Tools\n\n# Network vulnerability scanner\nnmap --script vuln target.com\n\n# Web application scanner\nnikto -h https://target.com\nowasp-zap -cmd -quickurl https://target.com\n\n# Container image scanning\ntrivy image myapp:latest\ngrype myapp:latest\n\n# Dependency scanning\nnpm audit\npip-audit\n\n# Infrastructure as Code scanning\ntfsec .\ncheckov -d .\n\n# Penetration Testing Methodology\n\n# 1. Reconnaissance\ntheHarvester -d target.com -b google\nsublist3r -d target.com\n\n# 2. Scanning\nnmap -sV -sC -A target.com\n\n# 3. Exploitation\n# Manual testing, Burp Suite, sqlmap\nsqlmap -u \"http://target.com/page?id=1\" --dbs\n\n# 4. Post-exploitation\n# Privilege escalation, lateral movement\n# LinPEAS, WinPEAS for enumeration\n\n# 5. Reporting\n# Document findings with:\n# - Description, CVSS score\n# - Proof of concept\n# - Business impact\n# - Remediation steps"
  },
  {
    "id": 42,
    "question": "What is ransomware and how do you protect against it?",
    "answer": "**Ransomware** is malware that encrypts victim's files and demands payment (usually cryptocurrency) for the decryption key.\n\n**Attack vectors:**\n- Phishing emails with malicious attachments\n- Exploiting vulnerabilities (RDP, VPN)\n- Drive-by downloads\n- Supply chain attacks\n\n**Protection:**\n\n**Prevention:**\n- Regular patching\n- Email filtering and awareness training\n- Disable RDP or use MFA\n- Application whitelisting\n- Network segmentation\n\n**Detection:**\n- EDR/antivirus with behavior analysis\n- File integrity monitoring\n- Network monitoring for C2 traffic\n\n**Recovery:**\n- Regular, tested, offline backups\n- Incident response plan\n- Don't pay ransom (no guarantee, funds criminals)",
    "example": "# Ransomware protection measures\n\n# 1. Backup strategy (3-2-1 rule)\n# 3 copies, 2 different media, 1 offsite/offline\n\n# Automated backup script\n#!/bin/bash\nBACKUP_DIR=\"/mnt/backup/$(date +%Y%m%d)\"\nmkdir -p $BACKUP_DIR\ntar -czf $BACKUP_DIR/data.tar.gz /important/data\n# Verify backup integrity\ntar -tzf $BACKUP_DIR/data.tar.gz > /dev/null && echo \"Backup valid\"\n# Sync to offline storage (disconnect after)\nrsync -av $BACKUP_DIR /mnt/offline-storage/\n\n# 2. Disable unnecessary services\nnetstat -tlnp | grep -E '(3389|445)'  # Check RDP, SMB\nsystemctl disable rdp  # Disable if not needed\n\n# 3. Network segmentation\n# Isolate backup systems\n# Restrict lateral movement\n\n# 4. File integrity monitoring (AIDE)\naide --init\naide --check\n\n# 5. Monitor for ransomware indicators\n# - Mass file encryption (entropy increase)\n# - Known ransomware file extensions\n# - Ransom note files\n\n# Detection rule (YARA)\nrule Ransomware_Note {\n    strings:\n        $s1 = \"Your files have been encrypted\"\n        $s2 = \"bitcoin\" nocase\n        $s3 = \".onion\"\n    condition:\n        2 of them\n}"
  },
  {
    "id": 43,
    "question": "What is the Cyber Kill Chain?",
    "answer": "The **Cyber Kill Chain** (Lockheed Martin) is a framework describing stages of a cyberattack, helping defenders identify and stop attacks.\n\n**Stages:**\n\n1. **Reconnaissance**: Research target, gather information (OSINT, scanning)\n\n2. **Weaponization**: Create malware/exploit payload\n\n3. **Delivery**: Transmit weapon (phishing, USB, web exploit)\n\n4. **Exploitation**: Execute code via vulnerability\n\n5. **Installation**: Install persistent backdoor\n\n6. **Command & Control (C2)**: Establish communication channel\n\n7. **Actions on Objectives**: Achieve goals (data theft, destruction)\n\n**Defense**: Break the chain at any stage to stop the attack.",
    "example": "# Detection at each Kill Chain stage\n\nkill_chain_defenses = {\n    \"reconnaissance\": {\n        \"indicators\": [\"Port scans\", \"DNS lookups\", \"Social media research\"],\n        \"defenses\": [\"IDS alerts\", \"Minimize public info\", \"Honeypots\"]\n    },\n    \"weaponization\": {\n        \"indicators\": [\"Malware development (external)\"],\n        \"defenses\": [\"Threat intelligence\", \"Sandbox analysis\"]\n    },\n    \"delivery\": {\n        \"indicators\": [\"Phishing emails\", \"Malicious downloads\"],\n        \"defenses\": [\"Email filtering\", \"Web proxy\", \"User training\"]\n    },\n    \"exploitation\": {\n        \"indicators\": [\"Exploit attempts\", \"Vulnerability triggers\"],\n        \"defenses\": [\"Patching\", \"WAF\", \"Exploit protection\"]\n    },\n    \"installation\": {\n        \"indicators\": [\"New files\", \"Registry changes\", \"Scheduled tasks\"],\n        \"defenses\": [\"EDR\", \"Application whitelisting\", \"FIM\"]\n    },\n    \"c2\": {\n        \"indicators\": [\"Beaconing\", \"DNS tunneling\", \"Unusual traffic\"],\n        \"defenses\": [\"Network monitoring\", \"DNS filtering\", \"Egress filtering\"]\n    },\n    \"actions\": {\n        \"indicators\": [\"Data exfiltration\", \"Lateral movement\"],\n        \"defenses\": [\"DLP\", \"Segmentation\", \"Least privilege\"]\n    }\n}\n\n# SIEM correlation across kill chain\n# Alert: Phishing email -> Execution -> C2 beacon = High priority incident"
  },
  {
    "id": 44,
    "question": "What is Endpoint Detection and Response (EDR)?",
    "answer": "**EDR** continuously monitors endpoints (laptops, servers, mobile) to detect, investigate, and respond to threats.\n\n**Key capabilities:**\n\n- **Continuous monitoring**: Record endpoint activities\n- **Threat detection**: Behavioral analysis, ML-based detection\n- **Investigation**: Query endpoint telemetry, timeline analysis\n- **Response**: Isolate hosts, kill processes, remediate\n- **Forensics**: Historical data for incident investigation\n\n**Difference from antivirus:**\n- AV: Signature-based, preventive\n- EDR: Behavioral, detective and responsive\n\n**Popular EDR solutions**: CrowdStrike, Carbon Black, SentinelOne, Microsoft Defender for Endpoint",
    "example": "# EDR capabilities and use cases\n\n# 1. Behavioral detection\n# Detects: Process injection, fileless malware, living-off-the-land\n\n# Example alert: Suspicious PowerShell execution\n{\n    \"alert\": \"Suspicious PowerShell\",\n    \"process\": \"powershell.exe\",\n    \"command_line\": \"powershell -enc SQBuAHYAbwBrAGUALQBX...\",\n    \"parent_process\": \"outlook.exe\",\n    \"risk_score\": 85\n}\n\n# 2. Threat hunting query (example syntax)\n# Find processes with encoded PowerShell\nprocess_name:powershell.exe AND command_line:*-enc*\n\n# Find lateral movement via PsExec\nprocess_name:psexec.exe OR \nfile_name:psexesvc.exe OR \nprocess_command_line:*\\\\ADMIN$*\n\n# 3. Response actions\n# Isolate compromised host\nedr_api.isolate_host(host_id=\"abc123\")\n\n# Kill malicious process\nedr_api.kill_process(host_id=\"abc123\", pid=4567)\n\n# Collect forensic data\nedr_api.collect_artifacts(host_id=\"abc123\", \n    artifacts=[\"memory\", \"registry\", \"event_logs\"])\n\n# 4. IOC search across all endpoints\nedr_api.search_ioc(\n    ioc_type=\"hash\",\n    value=\"a1b2c3d4e5f6...\",\n    scope=\"all_endpoints\"\n)"
  },
  {
    "id": 45,
    "question": "What is supply chain security in software?",
    "answer": "**Supply chain security** protects the software development and delivery pipeline from attacks that compromise dependencies, build systems, or distribution channels.\n\n**Attack vectors:**\n- **Dependency attacks**: Malicious packages (typosquatting, compromised maintainers)\n- **Build system compromise**: CI/CD pipeline attacks\n- **Code signing attacks**: Stolen signing keys\n- **Update mechanism attacks**: Compromised update servers\n\n**Protections:**\n- Verify dependency integrity (checksums, signatures)\n- Lock dependency versions\n- Private package repositories\n- Secure CI/CD pipelines\n- Software Bill of Materials (SBOM)\n- Code signing and verification",
    "example": "# Supply chain security practices\n\n# 1. Lock dependencies with checksums\n# package-lock.json, Pipfile.lock, Cargo.lock\n\n# Python - pip with hash verification\npip install --require-hashes -r requirements.txt\n# requirements.txt:\n# requests==2.28.0 --hash=sha256:abc123...\n\n# 2. Dependency scanning\nnpm audit\npip-audit\nsnyk test\n\n# 3. Software Bill of Materials (SBOM)\n# Generate SBOM in CycloneDX format\nsyft packages myapp:latest -o cyclonedx-json > sbom.json\n\n# 4. Secure CI/CD pipeline\n# GitHub Actions security\njobs:\n  build:\n    permissions:\n      contents: read  # Minimal permissions\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          persist-credentials: false\n      # Pin actions to SHA, not tags\n      - uses: actions/setup-node@2b5e...\n\n# 5. Code signing\n# Sign releases with GPG\ngpg --armor --detach-sign release.tar.gz\n\n# Verify signature before deployment\ngpg --verify release.tar.gz.asc release.tar.gz\n\n# 6. Artifact verification (Sigstore/cosign)\ncosign sign --key cosign.key myimage:latest\ncosign verify --key cosign.pub myimage:latest"
  },
  {
    "id": 46,
    "question": "What is cloud security and what is the shared responsibility model?",
    "answer": "**Cloud security** protects data, applications, and infrastructure in cloud environments.\n\n**Shared Responsibility Model** divides security duties between cloud provider and customer:\n\n**Provider responsible for:**\n- Physical security\n- Network infrastructure\n- Hypervisor/host security\n- Service availability\n\n**Customer responsible for:**\n- Data classification and encryption\n- Identity and access management\n- Application security\n- Network configuration (security groups)\n- OS patching (IaaS)\n\n**Varies by model:**\n- **IaaS**: Customer manages most (VMs, networking)\n- **PaaS**: Provider manages more (runtime, middleware)\n- **SaaS**: Provider manages nearly all",
    "example": "# Cloud security best practices (AWS example)\n\n# 1. Identity and Access Management\n# Use IAM roles instead of long-term credentials\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\"s3:GetObject\"],\n    \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n    \"Condition\": {\n      \"IpAddress\": {\"aws:SourceIp\": \"10.0.0.0/8\"}\n    }\n  }]\n}\n\n# 2. Network security\n# Security group - allow only necessary traffic\nresource \"aws_security_group\" \"web\" {\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# 3. Encryption\n# S3 bucket encryption\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"example\" {\n  bucket = aws_s3_bucket.example.id\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"aws:kms\"\n    }\n  }\n}\n\n# 4. Monitoring and compliance\n# Enable CloudTrail, GuardDuty, Config\n# aws cloudtrail create-trail --name my-trail --s3-bucket-name my-bucket"
  },
  {
    "id": 47,
    "question": "What is CORS and what are the security implications?",
    "answer": "**CORS (Cross-Origin Resource Sharing)** allows servers to specify which origins can access resources, relaxing the Same-Origin Policy.\n\n**How it works:**\n- Browser sends `Origin` header\n- Server responds with `Access-Control-Allow-Origin`\n- Browser enforces the policy\n\n**Security implications:**\n\n- **Overly permissive**: `Access-Control-Allow-Origin: *` allows any site\n- **Credential leakage**: `Allow-Credentials: true` with `*` origin is blocked by browsers\n- **Reflected origin**: Don't blindly reflect Origin header without validation\n\n**Best practices:**\n- Whitelist specific trusted origins\n- Never use `*` with credentials\n- Validate Origin against allowlist",
    "example": "# CORS security examples\n\n# BAD - Too permissive\n@app.after_request\ndef add_cors(response):\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response\n\n# WORSE - Reflecting origin without validation\norigin = request.headers.get('Origin')\nresponse.headers['Access-Control-Allow-Origin'] = origin  # Dangerous!\n\n# GOOD - Whitelist trusted origins\nALLOWED_ORIGINS = [\n    'https://myapp.com',\n    'https://admin.myapp.com'\n]\n\n@app.after_request\ndef add_cors(response):\n    origin = request.headers.get('Origin')\n    if origin in ALLOWED_ORIGINS:\n        response.headers['Access-Control-Allow-Origin'] = origin\n        response.headers['Access-Control-Allow-Credentials'] = 'true'\n        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'\n        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'\n    return response\n\n# Express.js with cors middleware\nconst cors = require('cors');\nconst corsOptions = {\n  origin: ['https://myapp.com', 'https://admin.myapp.com'],\n  credentials: true,\n  methods: ['GET', 'POST'],\n  allowedHeaders: ['Content-Type', 'Authorization']\n};\napp.use(cors(corsOptions));"
  },
  {
    "id": 48,
    "question": "What is password security and what are best practices for storage?",
    "answer": "**Password security** protects user credentials through proper storage and policy enforcement.\n\n**Storage best practices:**\n\n- **Never store plaintext**: Always hash passwords\n- **Use adaptive hashing**: bcrypt, Argon2, scrypt (not MD5/SHA)\n- **Salt passwords**: Unique random salt per password (automatic in bcrypt/Argon2)\n- **Use high work factor**: Slow down brute force attacks\n\n**Policy best practices (NIST 800-63B):**\n- Minimum 8 characters (longer better)\n- Check against breached password lists\n- Don't require arbitrary complexity rules\n- Don't force periodic rotation\n- Support password managers (paste allowed)\n- Implement MFA",
    "example": "# Password hashing examples\n\n# BAD - Plain MD5/SHA\nimport hashlib\nhash = hashlib.md5(password.encode()).hexdigest()  # Never do this!\n\n# GOOD - bcrypt\nimport bcrypt\n\ndef hash_password(password: str) -> bytes:\n    salt = bcrypt.gensalt(rounds=12)  # Work factor 12\n    return bcrypt.hashpw(password.encode(), salt)\n\ndef verify_password(password: str, hashed: bytes) -> bool:\n    return bcrypt.checkpw(password.encode(), hashed)\n\n# BETTER - Argon2 (recommended by OWASP)\nfrom argon2 import PasswordHasher\n\nph = PasswordHasher(\n    time_cost=3,      # Iterations\n    memory_cost=65536, # 64MB memory\n    parallelism=4\n)\n\nhashed = ph.hash(password)\nph.verify(hashed, password)  # Raises exception if invalid\n\n# Check against breached passwords (Have I Been Pwned API)\nimport hashlib\nimport requests\n\ndef is_password_breached(password: str) -> bool:\n    sha1 = hashlib.sha1(password.encode()).hexdigest().upper()\n    prefix, suffix = sha1[:5], sha1[5:]\n    response = requests.get(f'https://api.pwnedpasswords.com/range/{prefix}')\n    return suffix in response.text\n\n# Django settings\nAUTH_PASSWORD_VALIDATORS = [\n    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n     'OPTIONS': {'min_length': 12}},\n    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},\n]"
  },
  {
    "id": 49,
    "question": "What is session management and what are security best practices?",
    "answer": "**Session management** tracks user state across requests after authentication.\n\n**Best practices:**\n\n**Session ID:**\n- Cryptographically random, sufficient length (128+ bits)\n- Regenerate after login (prevent fixation)\n- Invalidate on logout and timeout\n\n**Cookie security:**\n- `HttpOnly`: Prevent JavaScript access (XSS protection)\n- `Secure`: Only send over HTTPS\n- `SameSite`: Prevent CSRF (Strict or Lax)\n- Short expiration for sensitive apps\n\n**Storage:**\n- Server-side sessions (Redis, database)\n- Or signed/encrypted tokens (JWT with caveats)\n\n**Protect against:**\n- Session fixation\n- Session hijacking\n- Session prediction",
    "example": "# Secure session configuration\n\n# Flask\nfrom flask import Flask, session\nimport os\n\napp = Flask(__name__)\napp.config.update(\n    SECRET_KEY=os.urandom(32),\n    SESSION_COOKIE_SECURE=True,      # HTTPS only\n    SESSION_COOKIE_HTTPONLY=True,    # No JavaScript access\n    SESSION_COOKIE_SAMESITE='Lax',   # CSRF protection\n    PERMANENT_SESSION_LIFETIME=1800   # 30 min timeout\n)\n\n# Regenerate session on login\n@app.route('/login', methods=['POST'])\ndef login():\n    if authenticate(request.form):\n        session.clear()  # Clear old session\n        session.regenerate()  # New session ID\n        session['user_id'] = user.id\n        return redirect('/dashboard')\n\n# Express.js session configuration\nconst session = require('express-session');\nconst RedisStore = require('connect-redis')(session);\n\napp.use(session({\n    store: new RedisStore({ client: redisClient }),\n    secret: process.env.SESSION_SECRET,\n    resave: false,\n    saveUninitialized: false,\n    cookie: {\n        secure: true,\n        httpOnly: true,\n        sameSite: 'strict',\n        maxAge: 1800000  // 30 minutes\n    }\n}));\n\n// Regenerate session on login\nreq.session.regenerate((err) => {\n    req.session.userId = user.id;\n});"
  },
  {
    "id": 50,
    "question": "What is security compliance and what are common frameworks?",
    "answer": "**Security compliance** ensures organizations meet regulatory requirements and industry standards for protecting data and systems.\n\n**Common frameworks:**\n\n**SOC 2**: Service organization controls - Trust Service Criteria (Security, Availability, Confidentiality)\n\n**PCI DSS**: Payment card data protection - 12 requirements for handling cardholder data\n\n**HIPAA**: Healthcare data protection - PHI safeguards\n\n**GDPR**: EU data protection - Privacy rights, data handling\n\n**ISO 27001**: Information security management system (ISMS)\n\n**NIST CSF**: Cybersecurity framework - Identify, Protect, Detect, Respond, Recover\n\n**FedRAMP**: US government cloud security standards",
    "example": "# Compliance implementation examples\n\n# PCI DSS - Encrypt cardholder data\nfrom cryptography.fernet import Fernet\n\nclass PaymentProcessor:\n    def __init__(self, encryption_key):\n        self.cipher = Fernet(encryption_key)\n    \n    def store_card(self, card_number: str) -> bytes:\n        # PCI DSS: Encrypt PAN at rest\n        return self.cipher.encrypt(card_number.encode())\n    \n    def mask_card(self, card_number: str) -> str:\n        # PCI DSS: Mask when displayed\n        return f\"****-****-****-{card_number[-4:]}\"\n\n# GDPR - Data subject rights\nclass UserDataController:\n    def export_user_data(self, user_id: int) -> dict:\n        \"\"\"GDPR Article 20 - Right to data portability\"\"\"\n        return {\n            'profile': User.query.get(user_id).to_dict(),\n            'orders': [o.to_dict() for o in user.orders],\n            'exported_at': datetime.utcnow().isoformat()\n        }\n    \n    def delete_user_data(self, user_id: int):\n        \"\"\"GDPR Article 17 - Right to erasure\"\"\"\n        user = User.query.get(user_id)\n        db.session.delete(user)\n        audit_log.record('user_deleted', user_id=user_id)\n        db.session.commit()\n\n# Compliance as Code (InSpec)\ncontrol 'pci-dss-3.4' do\n  title 'Render PAN unreadable anywhere it is stored'\n  describe file('/app/data/cards.db') do\n    it { should be_encrypted }\n  end\nend"
  }
]
