[
  {
    "id": 1,
    "question": "What is the CIA triad in cybersecurity?",
    "answer": "The **CIA triad** is the foundational model for information security:\n\n**Confidentiality**: Ensuring data is accessible only to authorized users. Achieved through encryption, access controls, authentication.\n\n**Integrity**: Ensuring data is accurate and unaltered. Achieved through hashing, digital signatures, checksums.\n\n**Availability**: Ensuring systems and data are accessible when needed. Achieved through redundancy, backups, DDoS protection.\n\nSome frameworks add **Non-repudiation** (proof of origin) and **Authentication** (verifying identity).",
    "example": "# Confidentiality - Encryption\nfrom cryptography.fernet import Fernet\nkey = Fernet.generate_key()\ncipher = Fernet(key)\nencrypted = cipher.encrypt(b\"sensitive data\")\n\n# Integrity - Hashing\nimport hashlib\ndata = b\"important document\"\nhash_value = hashlib.sha256(data).hexdigest()\n# Store hash, later verify: hashlib.sha256(received_data).hexdigest() == hash_value\n\n# Availability - Health checks, redundancy\n# Load balancers, failover systems, backup strategies"
  },
  {
    "id": 2,
    "question": "What is the difference between symmetric and asymmetric encryption?",
    "answer": "**Symmetric encryption** uses the same key for encryption and decryption:\n- Fast and efficient for large data\n- Key distribution is challenging\n- Examples: AES, ChaCha20, 3DES\n\n**Asymmetric encryption** uses a public/private key pair:\n- Public key encrypts, private key decrypts\n- Solves key distribution problem\n- Slower, used for small data or key exchange\n- Examples: RSA, ECC, Ed25519\n\n**Hybrid approach**: Use asymmetric to exchange symmetric key, then use symmetric for bulk data (TLS does this).",
    "example": "# Symmetric - AES\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nimport os\n\nkey = os.urandom(32)  # 256-bit key\niv = os.urandom(16)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv))\nencryptor = cipher.encryptor()\nciphertext = encryptor.update(plaintext) + encryptor.finalize()\n\n# Asymmetric - RSA\nfrom cryptography.hazmat.primitives.asymmetric import rsa, padding\nfrom cryptography.hazmat.primitives import hashes\n\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n# Encrypt with public key\nciphertext = public_key.encrypt(\n    plaintext,\n    padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                 algorithm=hashes.SHA256(), label=None)\n)\n\n# Decrypt with private key\nplaintext = private_key.decrypt(ciphertext, padding.OAEP(...))"
  },
  {
    "id": 3,
    "question": "What is SQL injection and how do you prevent it?",
    "answer": "**SQL injection** is an attack where malicious SQL code is inserted into application queries, allowing attackers to read, modify, or delete data.\n\n**Example attack:**\nInput: `' OR '1'='1' --`\nQuery becomes: `SELECT * FROM users WHERE username='' OR '1'='1' --'`\n\n**Prevention:**\n- **Parameterized queries/Prepared statements** (primary defense)\n- Input validation and sanitization\n- Least privilege database accounts\n- Web Application Firewall (WAF)\n- ORM usage (still validate inputs)\n- Escape special characters (last resort)",
    "example": "# VULNERABLE - String concatenation\nquery = f\"SELECT * FROM users WHERE username = '{username}'\"\n\n# SAFE - Parameterized query (Python/SQLite)\nimport sqlite3\nconn = sqlite3.connect('db.sqlite')\ncursor = conn.cursor()\ncursor.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\n\n# SAFE - SQLAlchemy ORM\nfrom sqlalchemy import select\nfrom models import User\nstmt = select(User).where(User.username == username)\nresult = session.execute(stmt)\n\n# SAFE - Django ORM\nUser.objects.filter(username=username)\n\n# SAFE - Node.js with pg\nconst result = await pool.query(\n  'SELECT * FROM users WHERE username = $1',\n  [username]\n);"
  },
  {
    "id": 4,
    "question": "What is Cross-Site Scripting (XSS) and what are its types?",
    "answer": "**XSS** attacks inject malicious scripts into web pages viewed by other users, stealing cookies, sessions, or performing actions on behalf of victims.\n\n**Types:**\n\n**Stored XSS**: Malicious script permanently stored on server (database, comments). Most dangerous.\n\n**Reflected XSS**: Script included in URL/request, reflected back in response. Requires victim to click malicious link.\n\n**DOM-based XSS**: Script manipulates DOM directly in browser, never sent to server.\n\n**Prevention:**\n- Output encoding/escaping\n- Content Security Policy (CSP)\n- HTTPOnly cookies\n- Input validation",
    "example": "// VULNERABLE\ndocument.getElementById('output').innerHTML = userInput;\n\n// SAFE - Use textContent instead of innerHTML\ndocument.getElementById('output').textContent = userInput;\n\n// SAFE - Escape HTML\nfunction escapeHtml(text) {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n// Server-side - Content Security Policy header\n// Content-Security-Policy: default-src 'self'; script-src 'self'\n\n// React automatically escapes (safe by default)\nfunction Comment({ text }) {\n  return <p>{text}</p>;  // Safe - React escapes\n}\n\n// DANGEROUS in React - avoid dangerouslySetInnerHTML\n<div dangerouslySetInnerHTML={{__html: userInput}} />  // XSS risk!"
  },
  {
    "id": 5,
    "question": "What is the difference between authentication and authorization?",
    "answer": "**Authentication (AuthN)**: Verifying WHO you are\n- Proves identity\n- \"Are you who you claim to be?\"\n- Methods: passwords, biometrics, MFA, certificates\n- Happens first\n\n**Authorization (AuthZ)**: Verifying WHAT you can do\n- Grants permissions based on identity\n- \"Are you allowed to access this resource?\"\n- Methods: RBAC, ABAC, ACLs, policies\n- Happens after authentication\n\n**Example**: Logging into your email (authentication) vs. being able to access admin settings (authorization).",
    "example": "# Authentication - Verify identity\nfrom werkzeug.security import check_password_hash\n\ndef authenticate(username, password):\n    user = User.query.filter_by(username=username).first()\n    if user and check_password_hash(user.password_hash, password):\n        return user  # Authenticated\n    return None\n\n# Authorization - Check permissions\ndef authorize(user, resource, action):\n    # Role-Based Access Control (RBAC)\n    if action == 'delete' and 'admin' not in user.roles:\n        raise PermissionDenied(\"Admin role required\")\n    \n    # Attribute-Based Access Control (ABAC)\n    if resource.owner_id != user.id and 'admin' not in user.roles:\n        raise PermissionDenied(\"Not owner or admin\")\n\n# Flask decorator example\nfrom functools import wraps\n\ndef require_role(role):\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            if role not in current_user.roles:\n                abort(403)\n            return f(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@app.route('/admin')\n@login_required  # Authentication\n@require_role('admin')  # Authorization\ndef admin_panel():\n    return render_template('admin.html')"
  },
  {
    "id": 6,
    "question": "What is a hash function and what properties should a cryptographic hash have?",
    "answer": "A **hash function** maps arbitrary-size input to fixed-size output (digest/hash).\n\n**Cryptographic hash properties:**\n\n1. **Deterministic**: Same input always produces same output\n\n2. **Pre-image resistance**: Given hash h, hard to find input m where hash(m) = h\n\n3. **Second pre-image resistance**: Given input m1, hard to find different m2 where hash(m1) = hash(m2)\n\n4. **Collision resistance**: Hard to find any two different inputs with same hash\n\n5. **Avalanche effect**: Small input change causes drastically different output\n\n**Common algorithms**: SHA-256, SHA-3, BLAKE2/3\n**Broken/Weak**: MD5, SHA-1 (collision attacks found)",
    "example": "import hashlib\n\n# SHA-256 (recommended)\ndata = b\"Hello, World!\"\nhash_sha256 = hashlib.sha256(data).hexdigest()\nprint(f\"SHA-256: {hash_sha256}\")\n\n# Avalanche effect demonstration\ndata1 = b\"Hello\"\ndata2 = b\"Hellp\"  # One character different\nprint(hashlib.sha256(data1).hexdigest())\nprint(hashlib.sha256(data2).hexdigest())\n# Completely different hashes!\n\n# Password hashing - use specialized functions (bcrypt, argon2)\nimport bcrypt\n\npassword = b\"user_password\"\nsalt = bcrypt.gensalt(rounds=12)\nhashed = bcrypt.hashpw(password, salt)\n\n# Verify password\nif bcrypt.checkpw(password, hashed):\n    print(\"Password matches!\")\n\n# NEVER use plain SHA for passwords!\n# hashlib.sha256(password).hexdigest()  # BAD - vulnerable to rainbow tables"
  },
  {
    "id": 7,
    "question": "What is HTTPS/TLS and how does the TLS handshake work?",
    "answer": "**HTTPS** is HTTP over TLS (Transport Layer Security), providing encrypted communication.\n\n**TLS Handshake (simplified TLS 1.3):**\n\n1. **Client Hello**: Client sends supported cipher suites, TLS version, random number, key share\n\n2. **Server Hello**: Server chooses cipher suite, sends certificate, key share, random number\n\n3. **Key Derivation**: Both derive shared secret using ECDHE key exchange\n\n4. **Finished**: Both send encrypted \"finished\" message to verify handshake integrity\n\n**Benefits:**\n- Confidentiality (encryption)\n- Integrity (MAC)\n- Authentication (certificates)",
    "example": "# Python - Enforce HTTPS with proper verification\nimport requests\n\n# Good - Verifies SSL certificate\nresponse = requests.get('https://api.example.com', verify=True)\n\n# BAD - Never disable verification in production!\n# response = requests.get('https://api.example.com', verify=False)\n\n# Flask - Redirect HTTP to HTTPS\nfrom flask_tls import Tls\nTls(app)  # or use reverse proxy (nginx)\n\n# Node.js - Create HTTPS server\nconst https = require('https');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('private-key.pem'),\n  cert: fs.readFileSync('certificate.pem')\n};\n\nhttps.createServer(options, (req, res) => {\n  res.writeHead(200);\n  res.end('Secure!');\n}).listen(443);\n\n# Check certificate with OpenSSL\n# openssl s_client -connect example.com:443 -servername example.com"
  },
  {
    "id": 8,
    "question": "What is Cross-Site Request Forgery (CSRF) and how do you prevent it?",
    "answer": "**CSRF** tricks authenticated users into performing unwanted actions on a trusted site by exploiting their existing session.\n\n**Attack scenario:**\n1. User logs into bank.com\n2. User visits malicious site\n3. Malicious site sends hidden request to bank.com/transfer\n4. Browser includes bank.com cookies automatically\n5. Transfer executes with user's credentials\n\n**Prevention:**\n- **CSRF tokens**: Unique token per session/request\n- **SameSite cookies**: Restrict cookie sending\n- **Double-submit cookies**\n- Check Origin/Referer headers\n- Re-authentication for sensitive actions",
    "example": "# Flask - CSRF protection with Flask-WTF\nfrom flask_wtf.csrf import CSRFProtect\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key'\ncsrf = CSRFProtect(app)\n\n# In template\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n    <!-- form fields -->\n</form>\n\n# Django - CSRF protection (enabled by default)\n<form method=\"post\">\n    {% csrf_token %}\n    <!-- form fields -->\n</form>\n\n# SameSite cookie attribute\nSet-Cookie: session=abc123; SameSite=Strict; Secure; HttpOnly\n\n# Express.js - csurf middleware\nconst csrf = require('csurf');\nconst csrfProtection = csrf({ cookie: true });\n\napp.get('/form', csrfProtection, (req, res) => {\n  res.render('form', { csrfToken: req.csrfToken() });\n});\n\napp.post('/process', csrfProtection, (req, res) => {\n  // Token automatically validated\n});"
  },
  {
    "id": 9,
    "question": "What is Multi-Factor Authentication (MFA) and what are the factor types?",
    "answer": "**MFA** requires two or more verification factors to gain access, significantly improving security.\n\n**Factor types:**\n\n**Something you know**: Password, PIN, security questions\n\n**Something you have**: Phone (SMS/TOTP), hardware token (YubiKey), smart card\n\n**Something you are**: Biometrics - fingerprint, face, iris, voice\n\n**Somewhere you are**: Geolocation, IP address (weaker factor)\n\n**Best practices:**\n- Avoid SMS (vulnerable to SIM swapping)\n- Prefer TOTP apps or hardware keys\n- FIDO2/WebAuthn for phishing resistance\n- Have backup codes for account recovery",
    "example": "# TOTP (Time-based One-Time Password) implementation\nimport pyotp\nimport qrcode\n\n# Generate secret for user (store securely)\nsecret = pyotp.random_base32()\n\n# Generate QR code for authenticator app\ntotp = pyotp.TOTP(secret)\nuri = totp.provisioning_uri(name=\"user@example.com\", issuer_name=\"MyApp\")\nqrcode.make(uri).save(\"totp_qr.png\")\n\n# Verify code from user\ndef verify_totp(user_secret, code):\n    totp = pyotp.TOTP(user_secret)\n    return totp.verify(code, valid_window=1)  # Allow 30s clock skew\n\n# WebAuthn (FIDO2) - More secure, phishing resistant\n# Server generates challenge, client signs with hardware key\n# Libraries: py_webauthn (Python), @simplewebauthn (JS)\n\n# Example verification flow\nif verify_password(username, password):  # Factor 1\n    if verify_totp(user.totp_secret, totp_code):  # Factor 2\n        create_session(user)\n    else:\n        return \"Invalid 2FA code\"\nelse:\n    return \"Invalid credentials\""
  },
  {
    "id": 10,
    "question": "What are the OWASP Top 10 vulnerabilities?",
    "answer": "**OWASP Top 10 (2021)** lists the most critical web application security risks:\n\n1. **Broken Access Control**: Unauthorized access to resources\n2. **Cryptographic Failures**: Weak crypto, exposed sensitive data\n3. **Injection**: SQL, NoSQL, OS, LDAP injection\n4. **Insecure Design**: Missing security controls in design\n5. **Security Misconfiguration**: Default configs, unnecessary features\n6. **Vulnerable Components**: Outdated libraries with known CVEs\n7. **Authentication Failures**: Weak passwords, session issues\n8. **Software/Data Integrity Failures**: Untrusted updates, CI/CD compromise\n9. **Logging & Monitoring Failures**: Missing audit trails\n10. **Server-Side Request Forgery (SSRF)**: Server fetches attacker-controlled URLs",
    "example": "# 1. Broken Access Control - Always verify authorization\n@app.route('/api/user/<user_id>/data')\n@login_required\ndef get_user_data(user_id):\n    if current_user.id != user_id and not current_user.is_admin:\n        abort(403)  # Must check authorization!\n    return get_data(user_id)\n\n# 6. Vulnerable Components - Keep dependencies updated\n# pip-audit (Python)\n# npm audit (Node.js)\n# dependabot (GitHub)\n\n# 9. Logging - Log security events\nimport logging\nlogger = logging.getLogger('security')\n\ndef login(username, password):\n    user = authenticate(username, password)\n    if user:\n        logger.info(f\"Successful login: {username} from {request.remote_addr}\")\n    else:\n        logger.warning(f\"Failed login attempt: {username} from {request.remote_addr}\")\n\n# 10. SSRF Prevention - Validate URLs\nfrom urllib.parse import urlparse\n\nALLOWED_HOSTS = ['api.trusted.com']\n\ndef fetch_url(url):\n    parsed = urlparse(url)\n    if parsed.hostname not in ALLOWED_HOSTS:\n        raise ValueError(\"URL not allowed\")\n    # Also block internal IPs (127.0.0.1, 10.x.x.x, 192.168.x.x)"
  },
  {
    "id": 11,
    "question": "What is a firewall and what are the different types?",
    "answer": "A **firewall** monitors and controls network traffic based on security rules, creating a barrier between trusted and untrusted networks.\n\n**Types:**\n\n**Packet Filtering**: Examines packet headers (IP, port). Simple, fast, stateless.\n\n**Stateful Inspection**: Tracks connection state, more context-aware.\n\n**Application Layer (WAF)**: Inspects application data (HTTP), detects XSS/SQLi.\n\n**Next-Gen (NGFW)**: Combines traditional firewall + IPS + application awareness + threat intelligence.\n\n**Host-based**: Runs on individual hosts (Windows Firewall, iptables).\n\n**Network-based**: Protects entire network segments.",
    "example": "# Linux iptables - Basic firewall rules\n# Block all incoming, allow outgoing\niptables -P INPUT DROP\niptables -P OUTPUT ACCEPT\n\n# Allow established connections\niptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n\n# Allow SSH from specific IP\niptables -A INPUT -p tcp --dport 22 -s 192.168.1.100 -j ACCEPT\n\n# Allow HTTP/HTTPS\niptables -A INPUT -p tcp --dport 80 -j ACCEPT\niptables -A INPUT -p tcp --dport 443 -j ACCEPT\n\n# Block specific IP\niptables -A INPUT -s 10.0.0.5 -j DROP\n\n# UFW (Uncomplicated Firewall) - Simpler interface\nufw default deny incoming\nufw default allow outgoing\nufw allow ssh\nufw allow 80/tcp\nufw enable\n\n# AWS Security Group (cloud firewall)\n# Inbound: Allow 443 from 0.0.0.0/0\n# Outbound: Allow all"
  },
  {
    "id": 12,
    "question": "What is the principle of least privilege?",
    "answer": "**Principle of Least Privilege (PoLP)** states that users, processes, and systems should have only the minimum permissions necessary to perform their tasks.\n\n**Benefits:**\n- Limits damage from compromised accounts\n- Reduces attack surface\n- Prevents accidental damage\n- Improves audit and compliance\n\n**Implementation:**\n- Default deny, explicitly grant\n- Role-based access control (RBAC)\n- Time-limited elevated access\n- Separate admin and regular accounts\n- Service accounts with specific permissions\n- Regular access reviews",
    "example": "# Database - Create limited user\nCREATE USER 'app_user'@'localhost' IDENTIFIED BY 'password';\nGRANT SELECT, INSERT, UPDATE ON mydb.users TO 'app_user'@'localhost';\n-- Don't grant DELETE, DROP, or access to other tables\n\n# AWS IAM - Minimal S3 policy\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Action\": [\n      \"s3:GetObject\",\n      \"s3:PutObject\"\n    ],\n    \"Resource\": \"arn:aws:s3:::my-bucket/uploads/*\"\n  }]\n}\n\n# Linux - Run service as non-root\n# Create dedicated user\nuseradd -r -s /bin/false appuser\n\n# Run application as that user\nsu -s /bin/bash -c './app' appuser\n\n# Docker - Don't run as root\nFROM node:18\nRUN useradd -m appuser\nUSER appuser\nCOPY --chown=appuser:appuser . .\nCMD [\"node\", \"app.js\"]"
  },
  {
    "id": 13,
    "question": "What is a Man-in-the-Middle (MITM) attack and how do you prevent it?",
    "answer": "**MITM attack** occurs when an attacker secretly intercepts and possibly alters communication between two parties who believe they're communicating directly.\n\n**Attack vectors:**\n- ARP spoofing on local network\n- DNS spoofing/poisoning\n- Rogue WiFi access points\n- SSL stripping (downgrade HTTPS to HTTP)\n- Compromised certificates\n\n**Prevention:**\n- Use HTTPS everywhere (HSTS)\n- Certificate pinning for mobile apps\n- VPN on untrusted networks\n- DNSSEC for DNS integrity\n- Verify certificate warnings\n- 802.1X for network access",
    "example": "# HSTS Header - Force HTTPS\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\n\n# Python Flask - Add HSTS\nfrom flask_talisman import Talisman\nTalisman(app, force_https=True, strict_transport_security=True)\n\n# Certificate Pinning (Mobile) - Android\n// OkHttp certificate pinning\nval certificatePinner = CertificatePinner.Builder()\n    .add(\"api.example.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n    .build()\n\nval client = OkHttpClient.Builder()\n    .certificatePinner(certificatePinner)\n    .build()\n\n# Python requests - Certificate pinning\nimport requests\nfrom requests_toolbelt.adapters.fingerprint import FingerprintAdapter\n\nsession = requests.Session()\nsession.mount(\n    'https://api.example.com',\n    FingerprintAdapter('AA:BB:CC:DD:...')  # Expected cert fingerprint\n)\n\n# Detect ARP spoofing\n# arpwatch - monitors ARP table changes\n# Static ARP entries for critical systems"
  },
  {
    "id": 14,
    "question": "What is a Zero Trust security model?",
    "answer": "**Zero Trust** is a security model based on \"never trust, always verify\" - no implicit trust based on network location.\n\n**Core principles:**\n\n1. **Verify explicitly**: Always authenticate and authorize based on all available data points\n\n2. **Least privilege access**: Just-in-time and just-enough-access (JIT/JEA)\n\n3. **Assume breach**: Minimize blast radius, segment access, encrypt end-to-end, use analytics\n\n**Key components:**\n- Strong identity verification (MFA)\n- Device health validation\n- Micro-segmentation\n- Continuous monitoring\n- Data-centric security\n- Encrypted communications everywhere",
    "example": "# Zero Trust Architecture Components:\n\n# 1. Identity-based access (not network-based)\n# Instead of: if (ip in internal_network) { allow }\n# Use: verify_identity() && verify_device() && check_context()\n\n# 2. Micro-segmentation - Each service authenticates\n# Service A calling Service B\nimport jwt\n\ndef call_service_b(data):\n    # Service A must authenticate to Service B\n    token = get_service_token('service-a', 'service-b')\n    response = requests.post(\n        'https://service-b/api',\n        headers={'Authorization': f'Bearer {token}'},\n        json=data\n    )\n    return response\n\n# 3. Continuous verification\n@app.before_request\ndef verify_request():\n    verify_token(request.headers.get('Authorization'))\n    verify_device_posture(request.headers.get('X-Device-ID'))\n    check_risk_score(current_user, request)\n    log_access(current_user, request.path)\n\n# 4. Network policies (Kubernetes example)\n# apiVersion: networking.k8s.io/v1\n# kind: NetworkPolicy\n# spec:\n#   podSelector: {matchLabels: {app: backend}}\n#   ingress:\n#   - from:\n#     - podSelector: {matchLabels: {app: frontend}}"
  },
  {
    "id": 15,
    "question": "What is penetration testing and what are its phases?",
    "answer": "**Penetration testing** is authorized simulated attacks on systems to identify security vulnerabilities before malicious actors exploit them.\n\n**Phases:**\n\n1. **Planning/Scoping**: Define targets, rules of engagement, legal agreements\n\n2. **Reconnaissance**: Gather information (passive/active). OSINT, network scanning\n\n3. **Scanning/Enumeration**: Port scanning, vulnerability scanning, service identification\n\n4. **Exploitation**: Attempt to exploit found vulnerabilities\n\n5. **Post-Exploitation**: Privilege escalation, lateral movement, data exfiltration\n\n6. **Reporting**: Document findings, risk ratings, remediation recommendations\n\n**Types**: Black box (no info), White box (full info), Gray box (partial info)",
    "example": "# Reconnaissance - Passive OSINT\n# whois example.com\n# dig example.com\n# theHarvester -d example.com -b google\n\n# Scanning - Nmap\nnmap -sV -sC -O target.com  # Version, scripts, OS detection\nnmap -p- target.com          # All ports\nnmap --script vuln target.com  # Vulnerability scripts\n\n# Vulnerability scanning\n# nikto -h https://target.com  # Web server scanner\n# sqlmap -u \"http://target.com/page?id=1\"  # SQL injection\n\n# Web application testing\n# OWASP ZAP or Burp Suite for intercepting/modifying requests\n\n# Password attacks (authorized testing only)\n# hydra -l admin -P wordlist.txt target.com ssh\n# hashcat -m 0 hashes.txt wordlist.txt  # Crack hashes\n\n# Post-exploitation\n# LinPEAS/WinPEAS for privilege escalation enumeration\n# Mimikatz for Windows credential extraction\n\n# Always document findings with:\n# - Vulnerability description\n# - CVSS score\n# - Proof of concept\n# - Remediation steps"
  },
  {
    "id": 16,
    "question": "What is a Security Operations Center (SOC) and what does it do?",
    "answer": "A **SOC** is a centralized unit that monitors, detects, analyzes, and responds to cybersecurity incidents 24/7.\n\n**Key functions:**\n- **Continuous monitoring**: SIEM, network traffic, endpoints\n- **Threat detection**: Identify anomalies and attacks\n- **Incident response**: Contain and remediate threats\n- **Threat intelligence**: Track emerging threats\n- **Vulnerability management**: Prioritize patching\n- **Compliance**: Ensure regulatory requirements\n\n**SOC tiers:**\n- **Tier 1**: Alert triage, initial analysis\n- **Tier 2**: Deep investigation, incident handling\n- **Tier 3**: Advanced threats, threat hunting, forensics",
    "example": "# SIEM Query Examples (Splunk-like syntax)\n\n# Detect brute force attempts\nindex=auth sourcetype=linux_secure \"Failed password\"\n| stats count by src_ip, user\n| where count > 10\n\n# Detect potential data exfiltration\nindex=network dest_port=443\n| stats sum(bytes_out) as total_bytes by src_ip\n| where total_bytes > 1000000000\n\n# Detect lateral movement (unusual internal connections)\nindex=network src_ip=10.* dest_ip=10.*\n| stats dc(dest_ip) as unique_dests by src_ip\n| where unique_dests > 50\n\n# Alert correlation - Multiple failed logins then success\nindex=auth \"Failed password\" OR \"Accepted password\"\n| transaction user maxspan=5m\n| where eventcount > 5 AND match(events, \"Accepted\")\n\n# Key metrics tracked:\n# - MTTD (Mean Time to Detect)\n# - MTTR (Mean Time to Respond)\n# - Alert volume and false positive rate\n# - Incidents by severity and type"
  },
  {
    "id": 17,
    "question": "What is JWT and what are its security considerations?",
    "answer": "**JWT (JSON Web Token)** is a compact, URL-safe token format for securely transmitting claims between parties.\n\n**Structure**: Header.Payload.Signature (Base64 encoded)\n\n**Security considerations:**\n\n- **Always verify signature**: Don't trust payload without verification\n- **Use strong algorithms**: RS256/ES256, avoid HS256 with weak secrets, never \"none\"\n- **Validate claims**: exp (expiry), iss (issuer), aud (audience)\n- **Short expiration**: Use refresh tokens for long sessions\n- **Don't store sensitive data**: Payload is encoded, not encrypted\n- **Secure transmission**: Always use HTTPS\n- **Secure storage**: HttpOnly cookies or secure storage",
    "example": "# Python - PyJWT\nimport jwt\nfrom datetime import datetime, timedelta\n\n# GOOD - RS256 with RSA keys\nprivate_key = open('private.pem').read()\npublic_key = open('public.pem').read()\n\npayload = {\n    'sub': 'user123',\n    'iat': datetime.utcnow(),\n    'exp': datetime.utcnow() + timedelta(hours=1),\n    'iss': 'myapp',\n    'aud': 'myapp-client'\n}\n\ntoken = jwt.encode(payload, private_key, algorithm='RS256')\n\n# Verify with all checks\ntry:\n    decoded = jwt.decode(\n        token,\n        public_key,\n        algorithms=['RS256'],  # Explicitly specify allowed algorithms!\n        audience='myapp-client',\n        issuer='myapp'\n    )\nexcept jwt.ExpiredSignatureError:\n    print(\"Token expired\")\nexcept jwt.InvalidTokenError:\n    print(\"Invalid token\")\n\n# BAD practices:\n# jwt.decode(token, options={\"verify_signature\": False})  # Never disable!\n# jwt.decode(token, algorithms=['none'])  # Algorithm confusion attack"
  },
  {
    "id": 18,
    "question": "What is a buffer overflow attack?",
    "answer": "**Buffer overflow** occurs when a program writes data beyond the allocated buffer boundary, potentially overwriting adjacent memory and allowing code execution.\n\n**Types:**\n- **Stack overflow**: Overwrite return address to hijack execution\n- **Heap overflow**: Corrupt heap metadata or function pointers\n- **Integer overflow**: Arithmetic overflow leads to small buffer allocation\n\n**Mitigations:**\n- **ASLR**: Randomize memory layout\n- **Stack canaries**: Detect stack corruption\n- **DEP/NX**: Non-executable stack/heap\n- **Safe functions**: strncpy vs strcpy, snprintf vs sprintf\n- **Memory-safe languages**: Rust, Go, Java",
    "example": "// VULNERABLE C code\n#include <string.h>\n\nvoid vulnerable(char *input) {\n    char buffer[64];\n    strcpy(buffer, input);  // No bounds checking!\n}\n\n// Attacker input longer than 64 bytes overwrites return address\n\n// SAFE - Use bounds-checked functions\nvoid safe(char *input) {\n    char buffer[64];\n    strncpy(buffer, input, sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n}\n\n// Compile with protections\n// gcc -fstack-protector-strong -D_FORTIFY_SOURCE=2 -pie -fPIE program.c\n\n// Check binary protections\n// checksec --file=./program\n// RELRO:    Full RELRO\n// Stack:    Canary found\n// NX:       NX enabled\n// PIE:      PIE enabled\n\n// Memory-safe alternative (Rust)\nfn safe_rust(input: &str) {\n    let buffer: String = input.chars().take(64).collect();\n    // Rust prevents buffer overflows at compile time\n}"
  },
  {
    "id": 19,
    "question": "What is Public Key Infrastructure (PKI) and how does certificate validation work?",
    "answer": "**PKI** is a framework for managing digital certificates and public-key encryption, enabling secure communication and identity verification.\n\n**Components:**\n- **Certificate Authority (CA)**: Issues and signs certificates\n- **Registration Authority (RA)**: Verifies identity before cert issuance\n- **Certificate**: Binds public key to identity\n- **Certificate Revocation List (CRL)** / **OCSP**: Check if cert is revoked\n\n**Certificate validation:**\n1. Check signature chain to trusted root CA\n2. Verify certificate not expired\n3. Check revocation status (CRL/OCSP)\n4. Validate domain name matches\n5. Check key usage extensions",
    "example": "# View certificate details\nopenssl s_client -connect example.com:443 -servername example.com\nopenssl x509 -in cert.pem -text -noout\n\n# Verify certificate chain\nopenssl verify -CAfile ca-bundle.crt server.crt\n\n# Python - Certificate validation\nimport ssl\nimport socket\n\ndef verify_certificate(hostname, port=443):\n    context = ssl.create_default_context()\n    \n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            cert = ssock.getpeercert()\n            \n            # Check expiration\n            ssl.match_hostname(cert, hostname)\n            \n            print(f\"Subject: {cert['subject']}\")\n            print(f\"Issuer: {cert['issuer']}\")\n            print(f\"Valid until: {cert['notAfter']}\")\n\n# Generate self-signed certificate (testing only)\nopenssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes\n\n# Let's Encrypt - Free production certificates\n# certbot certonly --webroot -w /var/www/html -d example.com"
  },
  {
    "id": 20,
    "question": "What is security hardening and what are common hardening practices?",
    "answer": "**Security hardening** reduces the attack surface by removing unnecessary features, applying secure configurations, and following security best practices.\n\n**Common practices:**\n\n**OS Hardening:**\n- Remove unnecessary services/packages\n- Apply security patches\n- Configure host firewall\n- Enable audit logging\n- Disable root SSH login\n\n**Application Hardening:**\n- Remove default credentials\n- Disable debug mode\n- Security headers\n- Input validation\n- Error handling (no stack traces)\n\n**Network Hardening:**\n- Segment networks\n- Close unused ports\n- Enable encryption\n- IDS/IPS deployment",
    "example": "# SSH Hardening - /etc/ssh/sshd_config\nPermitRootLogin no\nPasswordAuthentication no  # Use keys only\nPubkeyAuthentication yes\nX11Forwarding no\nAllowUsers deploy admin\nMaxAuthTries 3\nClientAliveInterval 300\nClientAliveCountMax 2\n\n# Linux hardening\n# Disable unused services\nsystemctl disable bluetooth cups avahi-daemon\n\n# Set secure permissions\nchmod 700 /root\nchmod 600 /etc/shadow\n\n# Enable automatic security updates\napt install unattended-upgrades\ndpkg-reconfigure -plow unattended-upgrades\n\n# Nginx hardening\nserver_tokens off;  # Hide version\nadd_header X-Content-Type-Options nosniff;\nadd_header X-Frame-Options DENY;\nadd_header X-XSS-Protection \"1; mode=block\";\nadd_header Content-Security-Policy \"default-src 'self'\";\n\n# Kubernetes pod security\napiVersion: v1\nkind: Pod\nspec:\n  securityContext:\n    runAsNonRoot: true\n    readOnlyRootFilesystem: true\n    capabilities:\n      drop: [\"ALL\"]"
  }
]
