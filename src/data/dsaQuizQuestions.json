[
  {
    "id": 1,
    "question": "What is the Two Pointers pattern and when do you use it?",
    "answer": "**Two Pointers** uses two indices to traverse data, often from opposite ends or at different speeds.\n\n**Patterns:**\n\n**1. Converging (opposite ends)**\n- Start at beginning and end, move toward middle\n- Use: Pair sum in sorted array, palindrome check, container problems\n\n**2. Same direction (fast/slow)**\n- Both start at beginning, move at different speeds\n- Use: Cycle detection, remove duplicates, find middle of linked list\n\n**3. Diverging**\n- Start from middle, expand outward\n- Use: Longest palindromic substring\n\n**Benefits:**\n- Reduces O(n²) brute force to O(n)\n- Constant extra space O(1)\n\n**Requirements:**\n- Usually sorted array or specific structure\n- Monotonic property to guide pointer movement",
    "example": "// Two Sum (sorted array) - Converging pointers\nfunction twoSum(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left < right) {\n    const sum = arr[left] + arr[right];\n    if (sum === target) return [left, right];\n    if (sum < target) left++;\n    else right--;\n  }\n  return [-1, -1];\n}\n\n// Remove duplicates in-place - Same direction\nfunction removeDuplicates(arr) {\n  if (arr.length === 0) return 0;\n  let slow = 0;\n  for (let fast = 1; fast < arr.length; fast++) {\n    if (arr[fast] !== arr[slow]) {\n      slow++;\n      arr[slow] = arr[fast];\n    }\n  }\n  return slow + 1;\n}\n\n// Cycle detection (Floyd's) - Fast/Slow\nfunction hasCycle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n\n// Container with most water - Converging\nfunction maxArea(heights) {\n  let left = 0, right = heights.length - 1, max = 0;\n  while (left < right) {\n    const area = Math.min(heights[left], heights[right]) * (right - left);\n    max = Math.max(max, area);\n    if (heights[left] < heights[right]) left++;\n    else right--;\n  }\n  return max;\n}"
  },
  {
    "id": 2,
    "question": "What is the Sliding Window pattern and how do you apply it?",
    "answer": "**Sliding Window** maintains a subset (window) of elements and slides it across the data structure.\n\n**Types:**\n\n**1. Fixed-size window**\n- Window size k is constant\n- Slide by adding right element, removing left element\n- Use: Max sum of k elements, moving average\n\n**2. Variable-size window**\n- Expand right to include, shrink left when constraint violated\n- Use: Longest substring with k distinct chars, minimum window substring\n\n**Template:**\n```\nleft = 0\nfor right in range(n):\n    # Add arr[right] to window\n    while window_invalid:\n        # Remove arr[left] from window\n        left++\n    # Update answer\n```\n\n**Benefits:**\n- O(n) instead of O(n²) brute force\n- Reuse computation from previous window\n\n**Key insight**: Each element enters and leaves window at most once → O(n)",
    "example": "// Fixed window - Max sum of k consecutive elements\nfunction maxSumSubarray(arr, k) {\n  let windowSum = 0, maxSum = -Infinity;\n  \n  for (let i = 0; i < arr.length; i++) {\n    windowSum += arr[i];           // Add right\n    if (i >= k - 1) {\n      maxSum = Math.max(maxSum, windowSum);\n      windowSum -= arr[i - k + 1]; // Remove left\n    }\n  }\n  return maxSum;\n}\n\n// Variable window - Longest substring with k distinct chars\nfunction longestWithKDistinct(s, k) {\n  const charCount = new Map();\n  let left = 0, maxLen = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    // Expand: add right char\n    charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n    // Shrink: while invalid (more than k distinct)\n    while (charCount.size > k) {\n      charCount.set(s[left], charCount.get(s[left]) - 1);\n      if (charCount.get(s[left]) === 0) charCount.delete(s[left]);\n      left++;\n    }\n\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}\n\n// Minimum window substring\nfunction minWindow(s, t) {\n  const need = new Map(), have = new Map();\n  for (const c of t) need.set(c, (need.get(c) || 0) + 1);\n  \n  let left = 0, formed = 0, minLen = Infinity, result = \"\";\n  \n  for (let right = 0; right < s.length; right++) {\n    const c = s[right];\n    have.set(c, (have.get(c) || 0) + 1);\n    if (need.has(c) && have.get(c) === need.get(c)) formed++;\n    \n    while (formed === need.size) {\n      if (right - left + 1 < minLen) {\n        minLen = right - left + 1;\n        result = s.slice(left, right + 1);\n      }\n      const leftChar = s[left];\n      have.set(leftChar, have.get(leftChar) - 1);\n      if (need.has(leftChar) && have.get(leftChar) < need.get(leftChar)) formed--;\n      left++;\n    }\n  }\n  return result;\n}"
  },
  {
    "id": 3,
    "question": "What is Modified Binary Search and what variations exist?",
    "answer": "**Modified Binary Search** extends classic binary search to solve problems beyond simple target finding.\n\n**Classic binary search**: Find exact target in sorted array - O(log n)\n\n**Variations:**\n\n**1. Find boundaries**\n- First/last occurrence of target\n- First element >= target (lower bound)\n- First element > target (upper bound)\n\n**2. Search in rotated array**\n- Array sorted then rotated at unknown pivot\n- Determine which half is sorted, check if target is there\n\n**3. Search in infinite/unknown size**\n- Double the search range until target is within bounds\n\n**4. Search on answer space**\n- When answer has monotonic property\n- Use binary search to find minimum/maximum valid answer\n- Examples: Koko eating bananas, capacity to ship packages\n\n**Key insight**: Binary search works whenever there's a monotonic predicate - left side satisfies condition, right side doesn't (or vice versa)",
    "example": "// Find first occurrence of target\nfunction findFirst(arr, target) {\n  let left = 0, right = arr.length - 1, result = -1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      result = mid;\n      right = mid - 1;  // Keep searching left\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return result;\n}\n\n// Search in rotated sorted array\nfunction searchRotated(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    \n    // Left half is sorted\n    if (arr[left] <= arr[mid]) {\n      if (target >= arr[left] && target < arr[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else { // Right half is sorted\n      if (target > arr[mid] && target <= arr[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}\n\n// Binary search on answer - Koko eating bananas\nfunction minEatingSpeed(piles, h) {\n  let left = 1, right = Math.max(...piles);\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const hours = piles.reduce((sum, p) => sum + Math.ceil(p / mid), 0);\n    if (hours <= h) right = mid;   // Can eat slower\n    else left = mid + 1;           // Need to eat faster\n  }\n  return left;\n}"
  },
  {
    "id": 4,
    "question": "What is Tree BFS (Level-Order Traversal) and when do you use it?",
    "answer": "**Tree BFS** (Breadth-First Search) visits nodes level by level using a queue.\n\n**Algorithm:**\n1. Start with root in queue\n2. While queue not empty:\n   - Process all nodes at current level\n   - Add their children to queue for next level\n\n**Use cases:**\n- Level-order traversal\n- Find minimum depth (first leaf encountered)\n- Level averages/maximums\n- Right side view of tree\n- Connect nodes at same level\n- Zigzag traversal\n\n**Time**: O(n) - visit each node once\n**Space**: O(w) where w is max width (can be n/2 for complete tree)\n\n**Key insight**: BFS naturally processes by levels. Use level size to track when level ends.\n\n**When to use BFS vs DFS:**\n- BFS: Level-related problems, find shortest/minimum\n- DFS: Path problems, tree shape problems, backtracking",
    "example": "// Basic level-order traversal\nfunction levelOrder(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  \n  while (queue.length) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      currentLevel.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(currentLevel);\n  }\n  return result;\n}\n\n// Minimum depth of binary tree\nfunction minDepth(root) {\n  if (!root) return 0;\n  const queue = [[root, 1]];\n  \n  while (queue.length) {\n    const [node, depth] = queue.shift();\n    // First leaf node = minimum depth\n    if (!node.left && !node.right) return depth;\n    if (node.left) queue.push([node.left, depth + 1]);\n    if (node.right) queue.push([node.right, depth + 1]);\n  }\n}\n\n// Right side view\nfunction rightSideView(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  \n  while (queue.length) {\n    const levelSize = queue.length;\n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      if (i === levelSize - 1) result.push(node.val); // Last node of level\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n  }\n  return result;\n}\n\n// Zigzag level order\nfunction zigzagLevelOrder(root) {\n  if (!root) return [];\n  const result = [];\n  const queue = [root];\n  let leftToRight = true;\n  \n  while (queue.length) {\n    const level = [];\n    for (let i = queue.length; i > 0; i--) {\n      const node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(leftToRight ? level : level.reverse());\n    leftToRight = !leftToRight;\n  }\n  return result;\n}"
  },
  {
    "id": 5,
    "question": "What is Tree DFS and what are the traversal orders?",
    "answer": "**Tree DFS** (Depth-First Search) explores as deep as possible before backtracking.\n\n**Three traversal orders:**\n\n**1. Preorder (Root → Left → Right)**\n- Process node before children\n- Use: Copy tree, serialize tree, prefix expression\n\n**2. Inorder (Left → Root → Right)**\n- Process node between children\n- Use: BST gives sorted order, expression tree\n\n**3. Postorder (Left → Right → Root)**\n- Process node after children\n- Use: Delete tree, postfix expression, calculate tree height\n\n**Implementation**: Recursive (natural) or iterative (using stack)\n\n**Time**: O(n)\n**Space**: O(h) where h is height (O(log n) balanced, O(n) skewed)\n\n**Use cases:**\n- Path sum problems\n- Tree validation (BST)\n- Lowest common ancestor\n- Tree diameter\n- Subtree problems",
    "example": "// Recursive DFS - All three orders\nfunction preorder(root, result = []) {\n  if (!root) return result;\n  result.push(root.val);        // Process root\n  preorder(root.left, result);  // Then left\n  preorder(root.right, result); // Then right\n  return result;\n}\n\nfunction inorder(root, result = []) {\n  if (!root) return result;\n  inorder(root.left, result);   // Left first\n  result.push(root.val);        // Then root\n  inorder(root.right, result);  // Then right\n  return result;\n}\n\nfunction postorder(root, result = []) {\n  if (!root) return result;\n  postorder(root.left, result);  // Left\n  postorder(root.right, result); // Right\n  result.push(root.val);         // Root last\n  return result;\n}\n\n// Iterative DFS with stack\nfunction preorderIterative(root) {\n  if (!root) return [];\n  const result = [], stack = [root];\n  while (stack.length) {\n    const node = stack.pop();\n    result.push(node.val);\n    if (node.right) stack.push(node.right); // Right first (LIFO)\n    if (node.left) stack.push(node.left);\n  }\n  return result;\n}\n\n// Path sum - DFS application\nfunction hasPathSum(root, target) {\n  if (!root) return false;\n  if (!root.left && !root.right) return root.val === target;\n  return hasPathSum(root.left, target - root.val) ||\n         hasPathSum(root.right, target - root.val);\n}\n\n// Validate BST - Inorder gives sorted order\nfunction isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n  if (root.val <= min || root.val >= max) return false;\n  return isValidBST(root.left, min, root.val) &&\n         isValidBST(root.right, root.val, max);\n}"
  },
  {
    "id": 6,
    "question": "What is Topological Sort and when do you use it?",
    "answer": "**Topological Sort** orders vertices of a DAG (Directed Acyclic Graph) such that for every edge u→v, u comes before v.\n\n**Use cases:**\n- Task scheduling with dependencies\n- Course prerequisites\n- Build systems (makefile)\n- Package dependency resolution\n\n**Two algorithms:**\n\n**1. Kahn's Algorithm (BFS)**\n- Track in-degree of each node\n- Start with nodes having in-degree 0\n- Remove node, decrease neighbors' in-degree\n- Repeat until all processed\n\n**2. DFS-based**\n- Do DFS, add node to result after processing all descendants\n- Reverse the result\n\n**Cycle detection**: If topological sort doesn't include all nodes → cycle exists\n\n**Time**: O(V + E)\n**Space**: O(V)\n\n**Key insight**: A node can only be processed after all its prerequisites are processed.",
    "example": "// Kahn's Algorithm (BFS-based)\nfunction topologicalSortBFS(numCourses, prerequisites) {\n  const graph = new Map();\n  const inDegree = new Array(numCourses).fill(0);\n  \n  // Build graph and count in-degrees\n  for (let i = 0; i < numCourses; i++) graph.set(i, []);\n  for (const [course, prereq] of prerequisites) {\n    graph.get(prereq).push(course);\n    inDegree[course]++;\n  }\n  \n  // Start with nodes having no prerequisites\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  const result = [];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node);\n    \n    for (const neighbor of graph.get(node)) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n  \n  // If not all nodes included, there's a cycle\n  return result.length === numCourses ? result : [];\n}\n\n// DFS-based topological sort\nfunction topologicalSortDFS(numCourses, prerequisites) {\n  const graph = new Map();\n  for (let i = 0; i < numCourses; i++) graph.set(i, []);\n  for (const [course, prereq] of prerequisites) {\n    graph.get(prereq).push(course);\n  }\n  \n  const visited = new Set();\n  const inStack = new Set(); // For cycle detection\n  const result = [];\n  \n  function dfs(node) {\n    if (inStack.has(node)) return false; // Cycle!\n    if (visited.has(node)) return true;\n    \n    inStack.add(node);\n    for (const neighbor of graph.get(node)) {\n      if (!dfs(neighbor)) return false;\n    }\n    inStack.delete(node);\n    visited.add(node);\n    result.push(node); // Add after all descendants\n    return true;\n  }\n  \n  for (let i = 0; i < numCourses; i++) {\n    if (!dfs(i)) return [];\n  }\n  return result.reverse();\n}"
  },
  {
    "id": 7,
    "question": "What is the Top K Elements pattern using a Heap?",
    "answer": "**Top K Elements** pattern finds the K largest/smallest/most frequent elements efficiently using a heap.\n\n**Key insight**: Use a heap of size K instead of sorting entire array.\n\n**For K largest elements:**\n- Use min-heap of size K\n- If new element > heap min, replace min with new element\n- Heap always contains K largest seen so far\n\n**For K smallest elements:**\n- Use max-heap of size K\n- If new element < heap max, replace max with new element\n\n**Time complexity:**\n- Sorting approach: O(n log n)\n- Heap approach: O(n log k)\n- When k << n, heap is much faster\n\n**Common problems:**\n- Kth largest element\n- K closest points to origin\n- Top K frequent elements\n- Merge K sorted lists\n- Find median from data stream (use two heaps)",
    "example": "class MinHeap {\n  constructor() { this.heap = []; }\n  \n  push(val) {\n    this.heap.push(val);\n    this._bubbleUp(this.heap.length - 1);\n  }\n  \n  pop() {\n    if (this.heap.length === 0) return null;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    if (this.heap.length > 0) {\n      this.heap[0] = last;\n      this._bubbleDown(0);\n    }\n    return min;\n  }\n  \n  peek() { return this.heap[0]; }\n  size() { return this.heap.length; }\n  \n  _bubbleUp(i) {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent] <= this.heap[i]) break;\n      [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];\n      i = parent;\n    }\n  }\n  \n  _bubbleDown(i) {\n    while (true) {\n      let smallest = i;\n      const left = 2 * i + 1, right = 2 * i + 2;\n      if (left < this.heap.length && this.heap[left] < this.heap[smallest]) smallest = left;\n      if (right < this.heap.length && this.heap[right] < this.heap[smallest]) smallest = right;\n      if (smallest === i) break;\n      [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];\n      i = smallest;\n    }\n  }\n}\n\n// Kth largest element\nfunction findKthLargest(nums, k) {\n  const minHeap = new MinHeap();\n  for (const num of nums) {\n    minHeap.push(num);\n    if (minHeap.size() > k) minHeap.pop();\n  }\n  return minHeap.peek();\n}\n\n// Top K frequent elements\nfunction topKFrequent(nums, k) {\n  const freq = new Map();\n  for (const num of nums) freq.set(num, (freq.get(num) || 0) + 1);\n  \n  // Min-heap of [frequency, number]\n  const heap = new MinHeap();\n  for (const [num, count] of freq) {\n    heap.push([count, num]);\n    if (heap.size() > k) heap.pop();\n  }\n  \n  return heap.heap.map(([_, num]) => num);\n}"
  },
  {
    "id": 8,
    "question": "What is the Subsets/Backtracking pattern?",
    "answer": "**Backtracking** explores all potential solutions by building candidates incrementally and abandoning (backtracking) when a candidate cannot lead to a valid solution.\n\n**Template:**\n```\nfunction backtrack(path, choices):\n    if is_solution(path):\n        add to results\n        return\n    for choice in choices:\n        if is_valid(choice):\n            make choice (add to path)\n            backtrack(path, remaining_choices)\n            undo choice (remove from path)  // Backtrack!\n```\n\n**Common patterns:**\n\n**1. Subsets**: All possible subsets of a set\n- Include or exclude each element\n\n**2. Permutations**: All arrangements\n- Use each element exactly once\n\n**3. Combinations**: Select k elements\n- Order doesn't matter\n\n**Time complexity:**\n- Subsets: O(2^n)\n- Permutations: O(n!)\n- Combinations: O(C(n,k))\n\n**Pruning**: Skip invalid branches early to improve performance",
    "example": "// Subsets - Power set\nfunction subsets(nums) {\n  const result = [];\n  \n  function backtrack(start, path) {\n    result.push([...path]); // Every path is a valid subset\n    \n    for (let i = start; i < nums.length; i++) {\n      path.push(nums[i]);       // Choose\n      backtrack(i + 1, path);   // Explore\n      path.pop();               // Unchoose (backtrack)\n    }\n  }\n  \n  backtrack(0, []);\n  return result;\n}\n\n// Permutations\nfunction permutations(nums) {\n  const result = [];\n  const used = new Array(nums.length).fill(false);\n  \n  function backtrack(path) {\n    if (path.length === nums.length) {\n      result.push([...path]);\n      return;\n    }\n    \n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue;\n      used[i] = true;\n      path.push(nums[i]);\n      backtrack(path);\n      path.pop();\n      used[i] = false;\n    }\n  }\n  \n  backtrack([]);\n  return result;\n}\n\n// Combinations - Choose k from n\nfunction combinations(n, k) {\n  const result = [];\n  \n  function backtrack(start, path) {\n    if (path.length === k) {\n      result.push([...path]);\n      return;\n    }\n    \n    // Pruning: need k - path.length more elements\n    for (let i = start; i <= n - (k - path.length) + 1; i++) {\n      path.push(i);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  }\n  \n  backtrack(1, []);\n  return result;\n}\n\n// Combination Sum - can reuse elements\nfunction combinationSum(candidates, target) {\n  const result = [];\n  \n  function backtrack(start, path, remaining) {\n    if (remaining === 0) {\n      result.push([...path]);\n      return;\n    }\n    if (remaining < 0) return;\n    \n    for (let i = start; i < candidates.length; i++) {\n      path.push(candidates[i]);\n      backtrack(i, path, remaining - candidates[i]); // i not i+1, can reuse\n      path.pop();\n    }\n  }\n  \n  backtrack(0, [], target);\n  return result;\n}"
  },
  {
    "id": 9,
    "question": "What is Dynamic Programming and how do you identify DP problems?",
    "answer": "**Dynamic Programming (DP)** solves problems by breaking them into overlapping subproblems and storing solutions to avoid recomputation.\n\n**Two key properties:**\n1. **Optimal substructure**: Optimal solution contains optimal solutions to subproblems\n2. **Overlapping subproblems**: Same subproblems solved multiple times\n\n**Approaches:**\n- **Top-down (Memoization)**: Recursion + cache\n- **Bottom-up (Tabulation)**: Iterative, build from base cases\n\n**How to identify DP problems:**\n- \"Count ways to...\"\n- \"Minimum/maximum cost to...\"\n- \"Is it possible to...\"\n- \"Longest/shortest...\"\n- Can I make decisions that affect future decisions?\n\n**Steps to solve:**\n1. Define state: What changes between subproblems?\n2. Find recurrence: How does current state relate to previous?\n3. Identify base cases\n4. Determine iteration order (bottom-up) or add memoization (top-down)\n5. Optimize space if possible",
    "example": "// Fibonacci - Classic DP example\n// Top-down with memoization\nfunction fibMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n  return memo[n];\n}\n\n// Bottom-up with space optimization\nfunction fibOptimized(n) {\n  if (n <= 1) return n;\n  let prev2 = 0, prev1 = 1;\n  for (let i = 2; i <= n; i++) {\n    const curr = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = curr;\n  }\n  return prev1;\n}\n\n// Coin Change - Minimum coins to make amount\nfunction coinChange(coins, amount) {\n  // dp[i] = min coins to make amount i\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  \n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i && dp[i - coin] !== Infinity) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\n// Longest Common Subsequence\nfunction longestCommonSubsequence(text1, text2) {\n  const m = text1.length, n = text2.length;\n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i-1] === text2[j-1]) {\n        dp[i][j] = dp[i-1][j-1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n      }\n    }\n  }\n  return dp[m][n];\n}\n\n// 0/1 Knapsack\nfunction knapsack(weights, values, capacity) {\n  const n = weights.length;\n  const dp = Array(n + 1).fill(null).map(() => Array(capacity + 1).fill(0));\n  \n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (weights[i-1] <= w) {\n        dp[i][w] = Math.max(\n          dp[i-1][w],                           // Don't take item\n          dp[i-1][w - weights[i-1]] + values[i-1] // Take item\n        );\n      } else {\n        dp[i][w] = dp[i-1][w];\n      }\n    }\n  }\n  return dp[n][capacity];\n}"
  },
  {
    "id": 10,
    "question": "What are the key Linked List patterns and techniques?",
    "answer": "**Linked List** is a linear data structure where elements are connected via pointers.\n\n**Key techniques:**\n\n**1. Fast/Slow Pointers**\n- Find middle: slow moves 1, fast moves 2\n- Detect cycle: if they meet, cycle exists\n- Find cycle start: reset one to head, move both by 1\n\n**2. Dummy Node**\n- Simplifies edge cases (empty list, head changes)\n- Create dummy pointing to head, return dummy.next\n\n**3. Reverse Linked List**\n- Iterative: track prev, curr, next\n- Recursive: reverse rest, then fix pointers\n\n**4. Merge Lists**\n- Use dummy node, compare and link smaller\n\n**Common problems:**\n- Reverse (full or partial)\n- Detect/find cycle\n- Find middle/nth from end\n- Merge sorted lists\n- Remove duplicates\n- Palindrome check\n\n**Time**: Most operations O(n)\n**Space**: O(1) for iterative, O(n) for recursive",
    "example": "class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n// Reverse linked list - Iterative O(1) space\nfunction reverseList(head) {\n  let prev = null, curr = head;\n  while (curr) {\n    const next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n  }\n  return prev;\n}\n\n// Find middle node (slow/fast pointers)\nfunction findMiddle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n}\n\n// Merge two sorted lists (dummy node technique)\nfunction mergeTwoLists(l1, l2) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  \n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      curr.next = l1;\n      l1 = l1.next;\n    } else {\n      curr.next = l2;\n      l2 = l2.next;\n    }\n    curr = curr.next;\n  }\n  curr.next = l1 || l2;\n  return dummy.next;\n}\n\n// Remove nth node from end (two pointers)\nfunction removeNthFromEnd(head, n) {\n  const dummy = new ListNode(0, head);\n  let fast = dummy, slow = dummy;\n  \n  // Move fast n+1 steps ahead\n  for (let i = 0; i <= n; i++) fast = fast.next;\n  \n  // Move both until fast reaches end\n  while (fast) {\n    fast = fast.next;\n    slow = slow.next;\n  }\n  \n  slow.next = slow.next.next; // Skip the nth node\n  return dummy.next;\n}\n\n// Check if palindrome (reverse second half)\nfunction isPalindrome(head) {\n  const mid = findMiddle(head);\n  let secondHalf = reverseList(mid);\n  \n  let p1 = head, p2 = secondHalf;\n  while (p2) {\n    if (p1.val !== p2.val) return false;\n    p1 = p1.next;\n    p2 = p2.next;\n  }\n  return true;\n}"
  }
]
