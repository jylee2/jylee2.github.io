[
  {
    "id": 1,
    "question": "What is the difference between an Array and a Linked List?",
    "answer": "**Array:**\n- Contiguous memory allocation\n- Fixed size (in most languages) or dynamic with reallocation\n- O(1) random access by index\n- O(n) insertion/deletion in middle (shifting required)\n- Cache-friendly due to locality\n\n**Linked List:**\n- Non-contiguous memory (nodes with pointers)\n- Dynamic size, grows easily\n- O(n) access (must traverse)\n- O(1) insertion/deletion if you have the node reference\n- Extra memory for pointers\n\n**When to use:**\n- Array: Frequent access by index, known size, cache performance matters\n- Linked List: Frequent insertions/deletions, unknown size, no random access needed",
    "example": "// Array - O(1) access, O(n) insert at beginning\nlet arr = [1, 2, 3, 4, 5];\narr[2];           // O(1) - returns 3\narr.unshift(0);   // O(n) - shifts all elements\n\n// Linked List - O(n) access, O(1) insert at beginning\nclass Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n  \n  // O(1) insert at head\n  prepend(val) {\n    const node = new Node(val);\n    node.next = this.head;\n    this.head = node;\n  }\n  \n  // O(n) access by index\n  get(index) {\n    let current = this.head;\n    for (let i = 0; i < index && current; i++) {\n      current = current.next;\n    }\n    return current?.val;\n  }\n}"
  },
  {
    "id": 2,
    "question": "What is Big O notation and what are common time complexities?",
    "answer": "**Big O notation** describes the upper bound of an algorithm's time or space complexity as input size grows.\n\n**Common complexities (fastest to slowest):**\n\n- **O(1)** - Constant: Hash table lookup, array access\n- **O(log n)** - Logarithmic: Binary search, balanced BST operations\n- **O(n)** - Linear: Linear search, single loop\n- **O(n log n)** - Linearithmic: Merge sort, heap sort, efficient sorting\n- **O(n²)** - Quadratic: Nested loops, bubble sort, insertion sort\n- **O(2ⁿ)** - Exponential: Recursive fibonacci, subset generation\n- **O(n!)** - Factorial: Permutations, traveling salesman brute force\n\n**Rules:**\n- Drop constants: O(2n) → O(n)\n- Drop lower terms: O(n² + n) → O(n²)\n- Consider worst case unless specified",
    "example": "// O(1) - Constant\nfunction getFirst(arr) {\n  return arr[0];\n}\n\n// O(log n) - Logarithmic\nfunction binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}\n\n// O(n) - Linear\nfunction sum(arr) {\n  return arr.reduce((a, b) => a + b, 0);\n}\n\n// O(n²) - Quadratic\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n}"
  },
  {
    "id": 3,
    "question": "What is a Hash Table and how does it handle collisions?",
    "answer": "A **Hash Table** (hash map) stores key-value pairs using a hash function to compute an index into an array of buckets.\n\n**Operations:** Average O(1) for insert, delete, lookup\n\n**Hash function**: Converts key → array index\n- Good hash: uniform distribution, deterministic, fast\n\n**Collision handling methods:**\n\n**1. Chaining (Separate Chaining)**\n- Each bucket contains a linked list\n- Collisions add to the list\n- Simple but uses extra memory\n\n**2. Open Addressing**\n- Find another empty slot in the array\n- Linear probing: check next slot\n- Quadratic probing: check i² slots away\n- Double hashing: use second hash function\n\n**Load factor** = n/k (items/buckets)\n- Resize when load factor exceeds threshold (typically 0.75)",
    "example": "// Simple hash table with chaining\nclass HashTable {\n  constructor(size = 53) {\n    this.buckets = new Array(size);\n    this.size = size;\n  }\n\n  _hash(key) {\n    let hash = 0;\n    for (let char of key) {\n      hash = (hash * 31 + char.charCodeAt(0)) % this.size;\n    }\n    return hash;\n  }\n\n  set(key, value) {\n    const index = this._hash(key);\n    if (!this.buckets[index]) {\n      this.buckets[index] = [];\n    }\n    // Check if key exists, update if so\n    const existing = this.buckets[index].find(([k]) => k === key);\n    if (existing) existing[1] = value;\n    else this.buckets[index].push([key, value]);\n  }\n\n  get(key) {\n    const index = this._hash(key);\n    const bucket = this.buckets[index];\n    if (!bucket) return undefined;\n    const pair = bucket.find(([k]) => k === key);\n    return pair ? pair[1] : undefined;\n  }\n}\n\nconst ht = new HashTable();\nht.set('name', 'Alice');  // O(1) average\nht.get('name');           // O(1) average → 'Alice'"
  },
  {
    "id": 4,
    "question": "What is a Binary Search Tree (BST) and what are its properties?",
    "answer": "A **Binary Search Tree** is a binary tree where each node follows the BST property:\n- Left subtree contains only nodes with keys less than the node's key\n- Right subtree contains only nodes with keys greater than the node's key\n- Both subtrees are also BSTs\n\n**Operations:**\n- Search: O(log n) average, O(n) worst (unbalanced)\n- Insert: O(log n) average, O(n) worst\n- Delete: O(log n) average, O(n) worst\n- In-order traversal: Gives sorted order\n\n**Balanced BSTs** maintain O(log n) height:\n- AVL Tree: Strict balance (height diff ≤ 1)\n- Red-Black Tree: Relaxed balance, faster insertions\n- B-Tree: Used in databases, multiple keys per node\n\n**Worst case**: Inserting sorted data creates a linked list (O(n) operations)",
    "example": "class TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BST {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(val) {\n    const node = new TreeNode(val);\n    if (!this.root) {\n      this.root = node;\n      return;\n    }\n    let current = this.root;\n    while (true) {\n      if (val < current.val) {\n        if (!current.left) { current.left = node; return; }\n        current = current.left;\n      } else {\n        if (!current.right) { current.right = node; return; }\n        current = current.right;\n      }\n    }\n  }\n\n  search(val) {\n    let current = this.root;\n    while (current) {\n      if (val === current.val) return current;\n      current = val < current.val ? current.left : current.right;\n    }\n    return null;\n  }\n\n  // In-order: Left, Root, Right → Sorted order\n  inOrder(node = this.root, result = []) {\n    if (node) {\n      this.inOrder(node.left, result);\n      result.push(node.val);\n      this.inOrder(node.right, result);\n    }\n    return result;\n  }\n}"
  },
  {
    "id": 5,
    "question": "What is the difference between a Stack and a Queue?",
    "answer": "**Stack (LIFO - Last In, First Out)**\n- Think: stack of plates\n- Operations: push (top), pop (top), peek (top)\n- All operations O(1)\n- Use cases: function calls, undo/redo, expression evaluation, DFS\n\n**Queue (FIFO - First In, First Out)**\n- Think: line at a store\n- Operations: enqueue (back), dequeue (front), peek (front)\n- All operations O(1) with proper implementation\n- Use cases: BFS, task scheduling, buffers, print queue\n\n**Variants:**\n- **Deque**: Double-ended queue, insert/remove both ends\n- **Priority Queue**: Elements have priority, highest priority out first (heap-based)\n- **Circular Queue**: Fixed size, wraps around",
    "example": "// Stack implementation\nclass Stack {\n  constructor() {\n    this.items = [];\n  }\n  push(val) { this.items.push(val); }\n  pop() { return this.items.pop(); }\n  peek() { return this.items[this.items.length - 1]; }\n  isEmpty() { return this.items.length === 0; }\n}\n\n// Queue implementation (using array - dequeue is O(n))\n// For O(1) dequeue, use linked list or circular buffer\nclass Queue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(val) { this.items.push(val); }\n  dequeue() { return this.items.shift(); } // O(n) with array\n  peek() { return this.items[0]; }\n  isEmpty() { return this.items.length === 0; }\n}\n\n// Usage - Stack for DFS, Queue for BFS\nconst stack = new Stack();\nstack.push(1); stack.push(2); stack.push(3);\nstack.pop(); // 3 (last in, first out)\n\nconst queue = new Queue();\nqueue.enqueue(1); queue.enqueue(2); queue.enqueue(3);\nqueue.dequeue(); // 1 (first in, first out)"
  },
  {
    "id": 6,
    "question": "Explain Depth-First Search (DFS) and Breadth-First Search (BFS).",
    "answer": "**DFS (Depth-First Search)**\n- Explores as deep as possible before backtracking\n- Uses: Stack (or recursion)\n- Time: O(V + E) for graphs, O(n) for trees\n- Space: O(h) where h is height (recursion stack)\n- Use cases: Path finding, cycle detection, topological sort, maze solving\n\n**BFS (Breadth-First Search)**\n- Explores all neighbors at current depth before going deeper\n- Uses: Queue\n- Time: O(V + E) for graphs, O(n) for trees\n- Space: O(w) where w is max width\n- Use cases: Shortest path (unweighted), level-order traversal, nearest neighbor\n\n**Key difference**: DFS goes deep first, BFS goes wide first.\n\n**Shortest path**: BFS finds shortest path in unweighted graphs; DFS does not guarantee shortest path.",
    "example": "// DFS - Using recursion (implicit stack)\nfunction dfs(node, visited = new Set()) {\n  if (!node || visited.has(node)) return;\n  console.log(node.val);\n  visited.add(node);\n  for (const neighbor of node.neighbors) {\n    dfs(neighbor, visited);\n  }\n}\n\n// DFS - Using explicit stack\nfunction dfsIterative(root) {\n  const stack = [root];\n  const visited = new Set();\n  while (stack.length) {\n    const node = stack.pop();\n    if (visited.has(node)) continue;\n    visited.add(node);\n    console.log(node.val);\n    for (const neighbor of node.neighbors) {\n      stack.push(neighbor);\n    }\n  }\n}\n\n// BFS - Using queue\nfunction bfs(root) {\n  const queue = [root];\n  const visited = new Set([root]);\n  while (queue.length) {\n    const node = queue.shift();\n    console.log(node.val);\n    for (const neighbor of node.neighbors) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n}"
  },
  {
    "id": 7,
    "question": "What is Dynamic Programming and when should you use it?",
    "answer": "**Dynamic Programming (DP)** is an optimization technique that solves complex problems by breaking them into overlapping subproblems and storing their solutions.\n\n**Two key properties for DP:**\n1. **Optimal substructure**: Optimal solution contains optimal solutions to subproblems\n2. **Overlapping subproblems**: Same subproblems are solved multiple times\n\n**Approaches:**\n- **Top-down (Memoization)**: Recursion + cache results\n- **Bottom-up (Tabulation)**: Build solution iteratively from base cases\n\n**Common patterns:**\n- Fibonacci-style: Current depends on previous values\n- Grid traversal: Paths, min cost\n- String problems: LCS, edit distance\n- Knapsack: Subset selection with constraints\n\n**Steps to solve:**\n1. Define state (what changes between subproblems)\n2. Find recurrence relation\n3. Identify base cases\n4. Decide iteration order or use memoization",
    "example": "// Fibonacci - Shows DP transformation\n\n// Naive recursion - O(2^n) - overlapping subproblems!\nfunction fibNaive(n) {\n  if (n <= 1) return n;\n  return fibNaive(n - 1) + fibNaive(n - 2);\n}\n\n// Top-down with memoization - O(n)\nfunction fibMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n  return memo[n];\n}\n\n// Bottom-up tabulation - O(n) time, O(n) space\nfunction fibTab(n) {\n  if (n <= 1) return n;\n  const dp = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n}\n\n// Bottom-up optimized - O(n) time, O(1) space\nfunction fibOptimized(n) {\n  if (n <= 1) return n;\n  let prev2 = 0, prev1 = 1;\n  for (let i = 2; i <= n; i++) {\n    const curr = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = curr;\n  }\n  return prev1;\n}"
  },
  {
    "id": 8,
    "question": "What is a Heap and how is it used for a Priority Queue?",
    "answer": "A **Heap** is a complete binary tree satisfying the heap property:\n- **Max-Heap**: Parent ≥ children (max at root)\n- **Min-Heap**: Parent ≤ children (min at root)\n\n**Properties:**\n- Complete binary tree (filled level by level)\n- Efficiently stored in array: parent at i, children at 2i+1, 2i+2\n- Height: O(log n)\n\n**Operations:**\n- **Insert**: Add at end, bubble up - O(log n)\n- **Extract max/min**: Remove root, replace with last, bubble down - O(log n)\n- **Peek**: O(1)\n- **Heapify array**: O(n)\n\n**Priority Queue**: Abstract data type where elements have priorities\n- Implemented efficiently with a heap\n- Use cases: Dijkstra's algorithm, task scheduling, median finding, K largest/smallest",
    "example": "class MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  parent(i) { return Math.floor((i - 1) / 2); }\n  leftChild(i) { return 2 * i + 1; }\n  rightChild(i) { return 2 * i + 2; }\n\n  swap(i, j) {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n  }\n\n  insert(val) {\n    this.heap.push(val);\n    this.bubbleUp(this.heap.length - 1);\n  }\n\n  bubbleUp(i) {\n    while (i > 0 && this.heap[i] < this.heap[this.parent(i)]) {\n      this.swap(i, this.parent(i));\n      i = this.parent(i);\n    }\n  }\n\n  extractMin() {\n    if (this.heap.length === 0) return null;\n    const min = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.bubbleDown(0);\n    return min;\n  }\n\n  bubbleDown(i) {\n    const n = this.heap.length;\n    while (this.leftChild(i) < n) {\n      let smallest = this.leftChild(i);\n      const right = this.rightChild(i);\n      if (right < n && this.heap[right] < this.heap[smallest]) {\n        smallest = right;\n      }\n      if (this.heap[i] <= this.heap[smallest]) break;\n      this.swap(i, smallest);\n      i = smallest;\n    }\n  }\n}"
  },
  {
    "id": 9,
    "question": "What are the common sorting algorithms and their complexities?",
    "answer": "**Comparison-based sorts:**\n\n| Algorithm | Best | Average | Worst | Space | Stable |\n|-----------|------|---------|-------|-------|--------|\n| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | Yes |\n| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | Yes |\n| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | No |\n| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | Yes |\n| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | No |\n| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | No |\n\n**Non-comparison sorts** (special cases, can beat O(n log n)):\n- Counting Sort: O(n + k), when range k is small\n- Radix Sort: O(d × n), d = digits\n- Bucket Sort: O(n + k), uniform distribution\n\n**Stable sort**: Equal elements maintain relative order",
    "example": "// Quick Sort - O(n log n) average, in-place\nfunction quickSort(arr, lo = 0, hi = arr.length - 1) {\n  if (lo < hi) {\n    const pivot = partition(arr, lo, hi);\n    quickSort(arr, lo, pivot - 1);\n    quickSort(arr, pivot + 1, hi);\n  }\n  return arr;\n}\n\nfunction partition(arr, lo, hi) {\n  const pivot = arr[hi];\n  let i = lo;\n  for (let j = lo; j < hi; j++) {\n    if (arr[j] < pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n  [arr[i], arr[hi]] = [arr[hi], arr[i]];\n  return i;\n}\n\n// Merge Sort - O(n log n) guaranteed, stable\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    result.push(left[i] <= right[j] ? left[i++] : right[j++]);\n  }\n  return result.concat(left.slice(i)).concat(right.slice(j));\n}"
  },
  {
    "id": 10,
    "question": "What is a Graph and how do you represent it?",
    "answer": "A **Graph** G = (V, E) consists of vertices (nodes) and edges (connections).\n\n**Types:**\n- **Directed vs Undirected**: Edges have direction or not\n- **Weighted vs Unweighted**: Edges have costs or not\n- **Cyclic vs Acyclic**: Contains cycles or not (DAG = Directed Acyclic Graph)\n- **Connected vs Disconnected**: All vertices reachable or not\n\n**Representations:**\n\n**1. Adjacency Matrix**\n- 2D array, matrix[i][j] = 1 if edge exists\n- Space: O(V²)\n- Edge lookup: O(1)\n- Best for: Dense graphs, frequent edge queries\n\n**2. Adjacency List**\n- Array of lists, each vertex stores its neighbors\n- Space: O(V + E)\n- Edge lookup: O(degree)\n- Best for: Sparse graphs, traversals\n\n**3. Edge List**\n- List of (u, v, weight) tuples\n- Space: O(E)\n- Best for: Edge-centric algorithms (Kruskal's)",
    "example": "// Adjacency List representation\nclass Graph {\n  constructor() {\n    this.adjacencyList = new Map();\n  }\n\n  addVertex(vertex) {\n    if (!this.adjacencyList.has(vertex)) {\n      this.adjacencyList.set(vertex, []);\n    }\n  }\n\n  addEdge(v1, v2, weight = 1) {\n    // For undirected graph\n    this.adjacencyList.get(v1).push({ node: v2, weight });\n    this.adjacencyList.get(v2).push({ node: v1, weight });\n  }\n\n  getNeighbors(vertex) {\n    return this.adjacencyList.get(vertex) || [];\n  }\n}\n\n// Adjacency Matrix for dense graph\nclass GraphMatrix {\n  constructor(numVertices) {\n    this.matrix = Array(numVertices).fill(null)\n      .map(() => Array(numVertices).fill(0));\n  }\n\n  addEdge(v1, v2, weight = 1) {\n    this.matrix[v1][v2] = weight;\n    this.matrix[v2][v1] = weight; // undirected\n  }\n\n  hasEdge(v1, v2) {\n    return this.matrix[v1][v2] !== 0;\n  }\n}\n\n// Usage\nconst g = new Graph();\n['A', 'B', 'C', 'D'].forEach(v => g.addVertex(v));\ng.addEdge('A', 'B');\ng.addEdge('A', 'C');\ng.addEdge('B', 'D');"
  },
  {
    "id": 11,
    "question": "What is the Two Pointer technique?",
    "answer": "**Two Pointers** is a technique using two indices to traverse a data structure, often from opposite ends or at different speeds.\n\n**Common patterns:**\n\n**1. Opposite ends (converging)**\n- Start at beginning and end, move toward middle\n- Use: Pair sum, palindrome check, container problems\n\n**2. Same direction (fast/slow)**\n- Both start at beginning, move at different speeds\n- Use: Cycle detection, remove duplicates, linked list middle\n\n**3. Sliding window variant**\n- Left and right define a window\n- Use: Subarray problems, longest substring\n\n**Benefits:**\n- Reduces O(n²) brute force to O(n)\n- Constant extra space\n- Works on sorted arrays or when order doesn't matter\n\n**Requirements:**\n- Usually sorted array or specific structure\n- Some monotonic property to guide pointer movement",
    "example": "// Two Sum (sorted array) - Opposite ends\nfunction twoSum(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left < right) {\n    const sum = arr[left] + arr[right];\n    if (sum === target) return [left, right];\n    if (sum < target) left++;\n    else right--;\n  }\n  return [-1, -1];\n}\n\n// Remove duplicates in-place - Same direction\nfunction removeDuplicates(arr) {\n  if (arr.length === 0) return 0;\n  let slow = 0;\n  for (let fast = 1; fast < arr.length; fast++) {\n    if (arr[fast] !== arr[slow]) {\n      slow++;\n      arr[slow] = arr[fast];\n    }\n  }\n  return slow + 1; // length of unique elements\n}\n\n// Cycle detection (Floyd's) - Fast/Slow\nfunction hasCycle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}\n\n// Container with most water - Opposite ends\nfunction maxArea(heights) {\n  let left = 0, right = heights.length - 1, max = 0;\n  while (left < right) {\n    const area = Math.min(heights[left], heights[right]) * (right - left);\n    max = Math.max(max, area);\n    if (heights[left] < heights[right]) left++;\n    else right--;\n  }\n  return max;\n}"
  },
  {
    "id": 12,
    "question": "What is the Sliding Window technique?",
    "answer": "**Sliding Window** maintains a subset (window) of elements and slides it across the data structure to solve problems efficiently.\n\n**Types:**\n\n**1. Fixed-size window**\n- Window size is constant\n- Slide by adding right, removing left\n- Use: Max sum of k elements, averages\n\n**2. Variable-size window**\n- Expand right to include, shrink left when constraint violated\n- Use: Longest substring with k distinct chars, minimum window substring\n\n**Pattern:**\n1. Initialize window (often empty)\n2. Expand: Add right element\n3. Contract: Remove left elements while invalid\n4. Update answer\n5. Repeat until right reaches end\n\n**Benefits:**\n- O(n) instead of O(n²) brute force\n- Avoid recalculating entire window each time\n\n**Key insight**: Reuse computation from previous window",
    "example": "// Fixed window - Max sum of k consecutive elements\nfunction maxSumSubarray(arr, k) {\n  let windowSum = 0, maxSum = -Infinity;\n  \n  for (let i = 0; i < arr.length; i++) {\n    windowSum += arr[i];           // Add right\n    if (i >= k - 1) {\n      maxSum = Math.max(maxSum, windowSum);\n      windowSum -= arr[i - k + 1]; // Remove left\n    }\n  }\n  return maxSum;\n}\n\n// Variable window - Longest substring with k distinct chars\nfunction longestWithKDistinct(s, k) {\n  const charCount = new Map();\n  let left = 0, maxLen = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    // Expand window\n    charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n    // Shrink while invalid (more than k distinct)\n    while (charCount.size > k) {\n      charCount.set(s[left], charCount.get(s[left]) - 1);\n      if (charCount.get(s[left]) === 0) charCount.delete(s[left]);\n      left++;\n    }\n\n    // Update answer\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}\n\n// Example: longestWithKDistinct(\"araaci\", 2) → 4 (\"araa\")"
  },
  {
    "id": 13,
    "question": "How do you detect a cycle in a Linked List?",
    "answer": "**Floyd's Cycle Detection (Tortoise and Hare)**\n\nUse two pointers moving at different speeds:\n- Slow pointer: moves 1 step\n- Fast pointer: moves 2 steps\n\n**If cycle exists**: Fast will eventually meet slow inside the cycle\n**If no cycle**: Fast reaches end (null)\n\n**Why it works:**\n- If there's a cycle, fast enters first\n- Fast gains 1 step per iteration on slow\n- Eventually fast catches slow (like runners on a track)\n\n**Finding cycle start:**\n1. Detect cycle (fast meets slow)\n2. Reset one pointer to head\n3. Move both at same speed (1 step)\n4. They meet at cycle start\n\n**Mathematical proof**: Distance from head to cycle start equals distance from meeting point to cycle start (going around cycle)",
    "example": "// Detect if cycle exists - O(n) time, O(1) space\nfunction hasCycle(head) {\n  if (!head || !head.next) return false;\n  \n  let slow = head;\n  let fast = head;\n  \n  while (fast && fast.next) {\n    slow = slow.next;        // 1 step\n    fast = fast.next.next;   // 2 steps\n    if (slow === fast) return true;\n  }\n  return false;\n}\n\n// Find cycle start node\nfunction detectCycleStart(head) {\n  if (!head || !head.next) return null;\n  \n  let slow = head, fast = head;\n  \n  // Phase 1: Detect cycle\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) break;\n  }\n  \n  if (!fast || !fast.next) return null; // No cycle\n  \n  // Phase 2: Find cycle start\n  slow = head;\n  while (slow !== fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  return slow; // Cycle start\n}\n\n// Alternative: HashSet - O(n) time, O(n) space\nfunction hasCycleHashSet(head) {\n  const visited = new Set();\n  while (head) {\n    if (visited.has(head)) return true;\n    visited.add(head);\n    head = head.next;\n  }\n  return false;\n}"
  },
  {
    "id": 14,
    "question": "What is a Trie and when would you use it?",
    "answer": "A **Trie** (prefix tree) is a tree data structure for storing strings where each node represents a character.\n\n**Properties:**\n- Root is empty\n- Each path from root represents a prefix\n- Nodes can be marked as word endings\n- Common prefixes share nodes\n\n**Operations:**\n- Insert: O(m) where m = word length\n- Search: O(m)\n- Prefix search: O(m)\n- Delete: O(m)\n\n**Use cases:**\n- Autocomplete / typeahead\n- Spell checkers\n- IP routing (longest prefix match)\n- Word games (Boggle, Scrabble)\n- Dictionary implementation\n\n**Space**: O(ALPHABET_SIZE × m × n) worst case, but prefix sharing reduces this\n\n**Alternatives:**\n- Hash table: O(1) lookup but no prefix operations\n- BST: O(m log n) operations",
    "example": "class TrieNode {\n  constructor() {\n    this.children = new Map();\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  insert(word) {\n    let node = this.root;\n    for (const char of word) {\n      if (!node.children.has(char)) {\n        node.children.set(char, new TrieNode());\n      }\n      node = node.children.get(char);\n    }\n    node.isEndOfWord = true;\n  }\n\n  search(word) {\n    const node = this._traverse(word);\n    return node !== null && node.isEndOfWord;\n  }\n\n  startsWith(prefix) {\n    return this._traverse(prefix) !== null;\n  }\n\n  _traverse(str) {\n    let node = this.root;\n    for (const char of str) {\n      if (!node.children.has(char)) return null;\n      node = node.children.get(char);\n    }\n    return node;\n  }\n\n  // Autocomplete - find all words with prefix\n  autocomplete(prefix) {\n    const node = this._traverse(prefix);\n    if (!node) return [];\n    const results = [];\n    this._collectWords(node, prefix, results);\n    return results;\n  }\n\n  _collectWords(node, prefix, results) {\n    if (node.isEndOfWord) results.push(prefix);\n    for (const [char, child] of node.children) {\n      this._collectWords(child, prefix + char, results);\n    }\n  }\n}"
  },
  {
    "id": 15,
    "question": "Explain Dijkstra's Algorithm for shortest path.",
    "answer": "**Dijkstra's Algorithm** finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edges.\n\n**Algorithm:**\n1. Initialize distances: source = 0, all others = ∞\n2. Add source to priority queue (min-heap)\n3. While queue not empty:\n   - Extract vertex with minimum distance\n   - For each neighbor, if new path is shorter, update distance and add to queue\n4. Return distances array\n\n**Time Complexity:**\n- With min-heap: O((V + E) log V)\n- With array (no heap): O(V²)\n\n**Limitations:**\n- Doesn't work with negative edge weights (use Bellman-Ford)\n- Greedy approach assumes shortest path to current node is final\n\n**Applications:**\n- GPS navigation\n- Network routing\n- Social network connections",
    "example": "function dijkstra(graph, start) {\n  const distances = new Map();\n  const previous = new Map();\n  const pq = new MinPriorityQueue(); // [distance, vertex]\n  \n  // Initialize\n  for (const vertex of graph.vertices) {\n    distances.set(vertex, vertex === start ? 0 : Infinity);\n    previous.set(vertex, null);\n  }\n  pq.enqueue([0, start]);\n\n  while (!pq.isEmpty()) {\n    const [dist, current] = pq.dequeue();\n    \n    // Skip if we've found a better path\n    if (dist > distances.get(current)) continue;\n\n    for (const { node: neighbor, weight } of graph.getNeighbors(current)) {\n      const newDist = distances.get(current) + weight;\n      \n      if (newDist < distances.get(neighbor)) {\n        distances.set(neighbor, newDist);\n        previous.set(neighbor, current);\n        pq.enqueue([newDist, neighbor]);\n      }\n    }\n  }\n\n  return { distances, previous };\n}\n\n// Reconstruct path from start to end\nfunction getPath(previous, end) {\n  const path = [];\n  let current = end;\n  while (current !== null) {\n    path.unshift(current);\n    current = previous.get(current);\n  }\n  return path;\n}\n\n// Usage:\n// const { distances, previous } = dijkstra(graph, 'A');\n// console.log(distances.get('D')); // Shortest distance to D\n// console.log(getPath(previous, 'D')); // Path from A to D"
  },
  {
    "id": 16,
    "question": "What is Recursion and how do you analyze recursive algorithms?",
    "answer": "**Recursion** is when a function calls itself to solve smaller instances of the same problem.\n\n**Components:**\n1. **Base case**: Terminating condition (stops recursion)\n2. **Recursive case**: Function calls itself with smaller input\n3. **Progress**: Each call moves toward base case\n\n**Analyzing recursion:**\n\n**Time complexity** - Use recurrence relations:\n- T(n) = T(n-1) + O(1) → O(n) (linear)\n- T(n) = T(n/2) + O(1) → O(log n) (binary search)\n- T(n) = 2T(n/2) + O(n) → O(n log n) (merge sort)\n- T(n) = 2T(n-1) + O(1) → O(2ⁿ) (naive fibonacci)\n\n**Space complexity**: O(depth of recursion) for call stack\n\n**Master Theorem** for T(n) = aT(n/b) + f(n):\n- Compare f(n) with n^(log_b(a))\n\n**Tail recursion**: Recursive call is last operation; can be optimized to iteration",
    "example": "// Factorial - Linear recursion O(n)\nfunction factorial(n) {\n  if (n <= 1) return 1;           // Base case\n  return n * factorial(n - 1);    // Recursive case\n}\n// T(n) = T(n-1) + O(1) → O(n)\n// Space: O(n) call stack\n\n// Binary Search - O(log n)\nfunction binarySearch(arr, target, lo = 0, hi = arr.length - 1) {\n  if (lo > hi) return -1;                    // Base case\n  const mid = Math.floor((lo + hi) / 2);\n  if (arr[mid] === target) return mid;       // Base case\n  if (arr[mid] < target)\n    return binarySearch(arr, target, mid + 1, hi);\n  return binarySearch(arr, target, lo, mid - 1);\n}\n// T(n) = T(n/2) + O(1) → O(log n)\n\n// Tree recursion (branching) - O(2^n)\nfunction fibNaive(n) {\n  if (n <= 1) return n;\n  return fibNaive(n - 1) + fibNaive(n - 2);  // Two recursive calls!\n}\n// T(n) = T(n-1) + T(n-2) + O(1) → O(2^n)\n\n// Tail recursion (optimizable)\nfunction factorialTail(n, acc = 1) {\n  if (n <= 1) return acc;\n  return factorialTail(n - 1, n * acc);  // Last operation is call\n}"
  },
  {
    "id": 17,
    "question": "What is Backtracking and when do you use it?",
    "answer": "**Backtracking** is a systematic way to search through all possible configurations by building solutions incrementally and abandoning (backtracking from) partial solutions that cannot lead to valid complete solutions.\n\n**Pattern:**\n1. Choose: Make a choice\n2. Explore: Recursively explore with that choice\n3. Unchoose: Undo the choice (backtrack)\n\n**When to use:**\n- Constraint satisfaction problems\n- Finding all solutions (or any solution)\n- Combinatorial problems\n- When brute force is too slow but pruning helps\n\n**Common problems:**\n- N-Queens\n- Sudoku solver\n- Permutations/Combinations\n- Word search in grid\n- Subset sum\n\n**Optimization**: Add constraints to prune branches early (pruning)\n\n**Time complexity**: Often O(n!) or O(2^n) worst case, but pruning reduces actual runtime",
    "example": "// Permutations - Generate all arrangements\nfunction permute(nums) {\n  const result = [];\n  \n  function backtrack(current, remaining) {\n    if (remaining.length === 0) {\n      result.push([...current]);  // Found a solution\n      return;\n    }\n    \n    for (let i = 0; i < remaining.length; i++) {\n      current.push(remaining[i]);           // Choose\n      const newRemaining = [...remaining.slice(0, i), ...remaining.slice(i + 1)];\n      backtrack(current, newRemaining);     // Explore\n      current.pop();                        // Unchoose (backtrack)\n    }\n  }\n  \n  backtrack([], nums);\n  return result;\n}\n\n// N-Queens - Place N queens on NxN board\nfunction solveNQueens(n) {\n  const result = [];\n  const board = Array(n).fill().map(() => Array(n).fill('.'));\n  \n  function isValid(row, col) {\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === 'Q') return false;  // Same column\n      if (col - (row - i) >= 0 && board[i][col - (row - i)] === 'Q') return false;\n      if (col + (row - i) < n && board[i][col + (row - i)] === 'Q') return false;\n    }\n    return true;\n  }\n  \n  function backtrack(row) {\n    if (row === n) {\n      result.push(board.map(r => r.join('')));\n      return;\n    }\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        board[row][col] = 'Q';    // Choose\n        backtrack(row + 1);       // Explore\n        board[row][col] = '.';    // Unchoose\n      }\n    }\n  }\n  \n  backtrack(0);\n  return result;\n}"
  },
  {
    "id": 18,
    "question": "What is the difference between a Tree and a Graph?",
    "answer": "**Tree:**\n- Connected, acyclic graph\n- Exactly one path between any two nodes\n- N nodes → N-1 edges\n- Has a root (in rooted trees)\n- Hierarchical structure\n- No need to track visited (no cycles)\n\n**Graph:**\n- Can have cycles\n- Can be disconnected\n- Multiple paths between nodes possible\n- No inherent root or hierarchy\n- Must track visited nodes in traversal\n- Can be directed or undirected\n\n**Key insight**: A tree is a special case of a graph (connected, acyclic)\n\n**Traversal differences:**\n- Tree: No visited tracking needed, natural recursive structure\n- Graph: Must track visited to avoid infinite loops in cycles\n\n**Common tree types:**\n- Binary tree, BST, AVL, Red-Black\n- N-ary tree, Trie\n- B-tree, B+ tree (databases)",
    "example": "// Tree traversal - No visited tracking needed\nfunction treeTraversal(root) {\n  if (!root) return;\n  console.log(root.val);           // Process node\n  treeTraversal(root.left);        // Left subtree\n  treeTraversal(root.right);       // Right subtree\n}\n\n// Graph DFS - MUST track visited\nfunction graphDFS(node, visited = new Set()) {\n  if (!node || visited.has(node)) return;\n  visited.add(node);               // Mark visited!\n  console.log(node.val);\n  for (const neighbor of node.neighbors) {\n    graphDFS(neighbor, visited);\n  }\n}\n\n// Tree has N-1 edges\n// Valid tree check: N nodes, N-1 edges, connected, no cycles\nfunction isValidTree(n, edges) {\n  if (edges.length !== n - 1) return false;  // Must have N-1 edges\n  \n  // Check if connected using Union-Find or DFS\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n  \n  const visited = new Set();\n  function dfs(node) {\n    visited.add(node);\n    for (const neighbor of adj[node]) {\n      if (!visited.has(neighbor)) dfs(neighbor);\n    }\n  }\n  \n  dfs(0);\n  return visited.size === n;  // All nodes reachable = connected\n}"
  },
  {
    "id": 19,
    "question": "What is Union-Find (Disjoint Set Union)?",
    "answer": "**Union-Find** is a data structure that tracks elements partitioned into disjoint (non-overlapping) sets.\n\n**Operations:**\n- **Find(x)**: Return the representative (root) of x's set\n- **Union(x, y)**: Merge the sets containing x and y\n\n**Optimizations:**\n1. **Path compression**: During Find, make nodes point directly to root\n2. **Union by rank/size**: Attach smaller tree under larger tree's root\n\n**With both optimizations:**\n- Nearly O(1) amortized per operation\n- Technically O(α(n)) where α is inverse Ackermann function\n\n**Use cases:**\n- Detect cycles in undirected graph\n- Kruskal's MST algorithm\n- Connected components\n- Network connectivity\n- Percolation problems",
    "example": "class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i);\n    this.rank = Array(n).fill(0);\n    this.count = n;  // Number of components\n  }\n\n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]);  // Path compression\n    }\n    return this.parent[x];\n  }\n\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n    \n    if (rootX === rootY) return false;  // Already in same set\n    \n    // Union by rank\n    if (this.rank[rootX] < this.rank[rootY]) {\n      this.parent[rootX] = rootY;\n    } else if (this.rank[rootX] > this.rank[rootY]) {\n      this.parent[rootY] = rootX;\n    } else {\n      this.parent[rootY] = rootX;\n      this.rank[rootX]++;\n    }\n    this.count--;\n    return true;\n  }\n\n  connected(x, y) {\n    return this.find(x) === this.find(y);\n  }\n}\n\n// Detect cycle in undirected graph\nfunction hasCycle(n, edges) {\n  const uf = new UnionFind(n);\n  for (const [u, v] of edges) {\n    if (uf.connected(u, v)) return true;  // Already connected = cycle\n    uf.union(u, v);\n  }\n  return false;\n}\n\n// Count connected components\nfunction countComponents(n, edges) {\n  const uf = new UnionFind(n);\n  for (const [u, v] of edges) uf.union(u, v);\n  return uf.count;\n}"
  },
  {
    "id": 20,
    "question": "What is the difference between Greedy algorithms and Dynamic Programming?",
    "answer": "**Greedy Algorithm:**\n- Makes locally optimal choice at each step\n- Never reconsiders choices (no backtracking)\n- Faster and simpler when applicable\n- Doesn't always give optimal solution\n- Must prove greedy choice property\n\n**Dynamic Programming:**\n- Considers all possible choices\n- Stores results of subproblems (memoization/tabulation)\n- Guarantees optimal solution (if applicable)\n- More complex, uses more memory\n- Requires optimal substructure + overlapping subproblems\n\n**Key difference:**\n- Greedy: \"Take the best option now\"\n- DP: \"Consider all options, combine optimal sub-solutions\"\n\n**When greedy works:**\n- Interval scheduling\n- Huffman coding\n- Dijkstra (non-negative weights)\n- Minimum spanning tree (Prim's, Kruskal's)\n\n**When you need DP:**\n- 0/1 Knapsack\n- Longest common subsequence\n- Edit distance\n- Coin change (minimum coins)",
    "example": "// COIN CHANGE - Greedy vs DP\n\n// Greedy approach - Doesn't always work!\nfunction coinChangeGreedy(coins, amount) {\n  coins.sort((a, b) => b - a);  // Largest first\n  let count = 0;\n  for (const coin of coins) {\n    count += Math.floor(amount / coin);\n    amount %= coin;\n  }\n  return amount === 0 ? count : -1;\n}\n// Fails: coins=[1,3,4], amount=6\n// Greedy: 4+1+1=3 coins\n// Optimal: 3+3=2 coins\n\n// DP approach - Always optimal\nfunction coinChangeDP(coins, amount) {\n  const dp = Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  \n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\n\n// INTERVAL SCHEDULING - Greedy works!\nfunction maxMeetings(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);  // Sort by end time\n  let count = 0, lastEnd = -Infinity;\n  \n  for (const [start, end] of intervals) {\n    if (start >= lastEnd) {  // Greedy: take earliest ending\n      count++;\n      lastEnd = end;\n    }\n  }\n  return count;\n}\n// Greedy works because taking earliest ending maximizes room for future"
  },
  {
    "id": 21,
    "question": "How do you reverse a Linked List?",
    "answer": "**Reversing a linked list** changes the direction of all pointers so the last node becomes the head.\n\n**Iterative approach:**\n1. Keep track of previous, current, and next nodes\n2. For each node, point it to previous instead of next\n3. Move all pointers forward\n4. Return previous (new head)\n\n**Recursive approach:**\n1. Base case: empty or single node\n2. Recursively reverse rest of list\n3. Point next node back to current\n4. Set current's next to null\n\n**Time:** O(n) - visit each node once\n**Space:** O(1) iterative, O(n) recursive (call stack)\n\n**Variations:**\n- Reverse between positions m and n\n- Reverse in groups of k\n- Reverse alternating k nodes",
    "example": "// Iterative - O(n) time, O(1) space\nfunction reverseList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current) {\n    const next = current.next;  // Save next\n    current.next = prev;        // Reverse pointer\n    prev = current;             // Move prev forward\n    current = next;             // Move current forward\n  }\n  \n  return prev;  // New head\n}\n\n// Recursive - O(n) time, O(n) space\nfunction reverseListRecursive(head) {\n  // Base case: empty or single node\n  if (!head || !head.next) return head;\n  \n  // Reverse the rest of the list\n  const newHead = reverseListRecursive(head.next);\n  \n  // Point next node back to current\n  head.next.next = head;\n  head.next = null;\n  \n  return newHead;\n}\n\n// Reverse between positions m and n (1-indexed)\nfunction reverseBetween(head, m, n) {\n  if (!head || m === n) return head;\n  \n  const dummy = { next: head };\n  let prev = dummy;\n  \n  // Move to position before m\n  for (let i = 1; i < m; i++) prev = prev.next;\n  \n  // Reverse from m to n\n  let current = prev.next;\n  for (let i = 0; i < n - m; i++) {\n    const next = current.next;\n    current.next = next.next;\n    next.next = prev.next;\n    prev.next = next;\n  }\n  \n  return dummy.next;\n}"
  },
  {
    "id": 22,
    "question": "What is Topological Sort and when is it used?",
    "answer": "**Topological Sort** produces a linear ordering of vertices in a Directed Acyclic Graph (DAG) such that for every edge (u, v), u comes before v.\n\n**Key requirements:**\n- Graph must be directed\n- Graph must be acyclic (no cycles)\n- Multiple valid orderings may exist\n\n**Algorithms:**\n\n**1. Kahn's Algorithm (BFS-based)**\n- Use in-degree array\n- Process nodes with in-degree 0\n- Remove edges, update in-degrees\n\n**2. DFS-based**\n- Do DFS, add node to result after visiting all descendants\n- Reverse the result\n\n**Time:** O(V + E)\n**Space:** O(V)\n\n**Use cases:**\n- Build systems (dependency resolution)\n- Course scheduling with prerequisites\n- Task scheduling\n- Package managers",
    "example": "// Kahn's Algorithm (BFS) - O(V + E)\nfunction topologicalSort(numCourses, prerequisites) {\n  const inDegree = Array(numCourses).fill(0);\n  const adj = Array.from({ length: numCourses }, () => []);\n  \n  // Build graph and compute in-degrees\n  for (const [course, prereq] of prerequisites) {\n    adj[prereq].push(course);\n    inDegree[course]++;\n  }\n  \n  // Start with nodes having no prerequisites\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  const result = [];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node);\n    \n    for (const neighbor of adj[node]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n  \n  // If not all nodes processed, there's a cycle\n  return result.length === numCourses ? result : [];\n}\n\n// DFS-based approach\nfunction topologicalSortDFS(numCourses, prerequisites) {\n  const adj = Array.from({ length: numCourses }, () => []);\n  for (const [course, prereq] of prerequisites) {\n    adj[prereq].push(course);\n  }\n  \n  const visited = new Set();\n  const visiting = new Set();  // For cycle detection\n  const result = [];\n  \n  function dfs(node) {\n    if (visiting.has(node)) return false;  // Cycle!\n    if (visited.has(node)) return true;\n    \n    visiting.add(node);\n    for (const neighbor of adj[node]) {\n      if (!dfs(neighbor)) return false;\n    }\n    visiting.delete(node);\n    visited.add(node);\n    result.push(node);\n    return true;\n  }\n  \n  for (let i = 0; i < numCourses; i++) {\n    if (!dfs(i)) return [];\n  }\n  \n  return result.reverse();\n}"
  },
  {
    "id": 23,
    "question": "What is Kadane's Algorithm?",
    "answer": "**Kadane's Algorithm** finds the maximum sum contiguous subarray in O(n) time.\n\n**Core idea:**\n- At each position, decide: extend current subarray or start new one\n- Track current sum and maximum seen so far\n- If current sum goes negative, reset to 0 (start fresh)\n\n**Algorithm:**\n1. Initialize maxSum = arr[0], currentSum = arr[0]\n2. For each element from index 1:\n   - currentSum = max(arr[i], currentSum + arr[i])\n   - maxSum = max(maxSum, currentSum)\n3. Return maxSum\n\n**Time:** O(n)\n**Space:** O(1)\n\n**Variations:**\n- Return the subarray itself (track start/end indices)\n- Maximum product subarray\n- Maximum circular subarray",
    "example": "// Basic Kadane's - O(n) time, O(1) space\nfunction maxSubArray(nums) {\n  let maxSum = nums[0];\n  let currentSum = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    // Either extend current subarray or start new\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  \n  return maxSum;\n}\n\n// Return the actual subarray\nfunction maxSubArrayWithIndices(nums) {\n  let maxSum = nums[0], currentSum = nums[0];\n  let start = 0, end = 0, tempStart = 0;\n  \n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > currentSum + nums[i]) {\n      currentSum = nums[i];\n      tempStart = i;\n    } else {\n      currentSum += nums[i];\n    }\n    \n    if (currentSum > maxSum) {\n      maxSum = currentSum;\n      start = tempStart;\n      end = i;\n    }\n  }\n  \n  return { maxSum, subarray: nums.slice(start, end + 1) };\n}\n\n// Maximum Product Subarray\nfunction maxProduct(nums) {\n  let maxProd = nums[0];\n  let currMax = nums[0], currMin = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    // Negative can flip min/max\n    const temp = currMax;\n    currMax = Math.max(nums[i], currMax * nums[i], currMin * nums[i]);\n    currMin = Math.min(nums[i], temp * nums[i], currMin * nums[i]);\n    maxProd = Math.max(maxProd, currMax);\n  }\n  \n  return maxProd;\n}"
  },
  {
    "id": 24,
    "question": "How do you implement an LRU Cache?",
    "answer": "**LRU Cache** (Least Recently Used) evicts the least recently accessed item when capacity is reached.\n\n**Requirements:**\n- get(key): Return value, mark as recently used - O(1)\n- put(key, value): Insert/update, evict LRU if full - O(1)\n\n**Implementation: Hash Map + Doubly Linked List**\n- Hash map: O(1) lookup by key\n- Doubly linked list: O(1) removal and insertion at ends\n- Most recent at head, least recent at tail\n\n**On access (get/put):**\n1. If exists: move to head (most recent)\n2. If new: add to head, evict tail if over capacity\n\n**Use cases:**\n- Browser cache\n- Database query cache\n- Memory management\n- CDN caching",
    "example": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();  // key -> node\n    // Dummy head and tail for easier operations\n    this.head = { key: null, val: null };\n    this.tail = { key: null, val: null };\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  // Add node right after head (most recent)\n  _addToHead(node) {\n    node.prev = this.head;\n    node.next = this.head.next;\n    this.head.next.prev = node;\n    this.head.next = node;\n  }\n\n  // Remove node from its current position\n  _removeNode(node) {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n  }\n\n  // Move existing node to head\n  _moveToHead(node) {\n    this._removeNode(node);\n    this._addToHead(node);\n  }\n\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    const node = this.cache.get(key);\n    this._moveToHead(node);  // Mark as recently used\n    return node.val;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      const node = this.cache.get(key);\n      node.val = value;\n      this._moveToHead(node);\n    } else {\n      const newNode = { key, val: value };\n      this.cache.set(key, newNode);\n      this._addToHead(newNode);\n\n      if (this.cache.size > this.capacity) {\n        // Remove LRU (node before tail)\n        const lru = this.tail.prev;\n        this._removeNode(lru);\n        this.cache.delete(lru.key);\n      }\n    }\n  }\n}\n\n// Usage\nconst cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);     // returns 1, moves to front\ncache.put(3, 3);  // evicts key 2\ncache.get(2);     // returns -1 (not found)"
  },
  {
    "id": 25,
    "question": "What are common Binary Search variations?",
    "answer": "**Binary Search** halves the search space each iteration. Beyond basic search, there are important variations.\n\n**Common variations:**\n\n**1. Find first/last occurrence**\n- Don't stop when found; continue searching left/right\n- Useful for duplicates\n\n**2. Find insertion position**\n- Where would target go to maintain sorted order?\n- Lower bound / upper bound\n\n**3. Search in rotated sorted array**\n- One half is always sorted\n- Determine which half, then search\n\n**4. Search for minimum/maximum**\n- Peak element, minimum in rotated array\n- Compare mid with neighbors\n\n**5. Search answer space**\n- When answer is in a range, binary search the answer\n- Koko eating bananas, ship capacity\n\n**Key insight**: Binary search works whenever you can eliminate half based on a condition",
    "example": "// Find first occurrence of target\nfunction findFirst(arr, target) {\n  let left = 0, right = arr.length - 1, result = -1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      result = mid;      // Found, but keep searching left\n      right = mid - 1;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return result;\n}\n\n// Find last occurrence of target\nfunction findLast(arr, target) {\n  let left = 0, right = arr.length - 1, result = -1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      result = mid;      // Found, but keep searching right\n      left = mid + 1;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return result;\n}\n\n// Search in rotated sorted array [4,5,6,7,0,1,2]\nfunction searchRotated(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    \n    // Left half is sorted\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      // Right half is sorted\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}\n\n// Find minimum in rotated sorted array\nfunction findMin(nums) {\n  let left = 0, right = nums.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] > nums[right]) {\n      left = mid + 1;  // Min is in right half\n    } else {\n      right = mid;     // Min is in left half (including mid)\n    }\n  }\n  return nums[left];\n}"
  },
  {
    "id": 26,
    "question": "What is a Monotonic Stack?",
    "answer": "A **Monotonic Stack** maintains elements in sorted order (either increasing or decreasing) from bottom to top.\n\n**Types:**\n- **Monotonic Increasing**: Each element is greater than the one below\n- **Monotonic Decreasing**: Each element is smaller than the one below\n\n**Key operations:**\n- Before pushing, pop elements that violate the monotonic property\n- When an element is popped, we've found a \"boundary\" for it\n\n**Common problems:**\n- Next Greater Element\n- Next Smaller Element\n- Largest Rectangle in Histogram\n- Daily Temperatures\n- Stock Span\n\n**Time:** O(n) - each element pushed and popped at most once\n**Space:** O(n)\n\n**Key insight**: When popping, the current element is the answer for the popped element",
    "example": "// Next Greater Element - O(n)\n// For each element, find the next element that is greater\nfunction nextGreaterElement(nums) {\n  const result = Array(nums.length).fill(-1);\n  const stack = [];  // Store indices, monotonic decreasing values\n  \n  for (let i = 0; i < nums.length; i++) {\n    // Pop elements smaller than current (found their next greater)\n    while (stack.length && nums[stack[stack.length - 1]] < nums[i]) {\n      const idx = stack.pop();\n      result[idx] = nums[i];\n    }\n    stack.push(i);\n  }\n  \n  return result;\n}\n// [2,1,2,4,3] → [4,2,4,-1,-1]\n\n// Daily Temperatures - days until warmer temperature\nfunction dailyTemperatures(temps) {\n  const result = Array(temps.length).fill(0);\n  const stack = [];  // Monotonic decreasing\n  \n  for (let i = 0; i < temps.length; i++) {\n    while (stack.length && temps[stack[stack.length - 1]] < temps[i]) {\n      const idx = stack.pop();\n      result[idx] = i - idx;  // Days until warmer\n    }\n    stack.push(i);\n  }\n  \n  return result;\n}\n\n// Largest Rectangle in Histogram\nfunction largestRectangleArea(heights) {\n  const stack = [];  // Monotonic increasing\n  let maxArea = 0;\n  \n  for (let i = 0; i <= heights.length; i++) {\n    const h = i === heights.length ? 0 : heights[i];\n    \n    while (stack.length && heights[stack[stack.length - 1]] > h) {\n      const height = heights[stack.pop()];\n      const width = stack.length ? i - stack[stack.length - 1] - 1 : i;\n      maxArea = Math.max(maxArea, height * width);\n    }\n    stack.push(i);\n  }\n  \n  return maxArea;\n}"
  },
  {
    "id": 27,
    "question": "What is the Longest Common Subsequence (LCS) problem?",
    "answer": "**LCS** finds the longest subsequence common to two sequences. A subsequence maintains relative order but doesn't need to be contiguous.\n\n**Example:**\n- text1 = \"abcde\", text2 = \"ace\"\n- LCS = \"ace\" (length 3)\n\n**Recurrence relation:**\n- If chars match: LCS(i,j) = 1 + LCS(i-1, j-1)\n- If not: LCS(i,j) = max(LCS(i-1,j), LCS(i,j-1))\n\n**DP approach:**\n- 2D table where dp[i][j] = LCS length of first i chars and first j chars\n- Build bottom-up\n\n**Time:** O(m × n)\n**Space:** O(m × n), can optimize to O(min(m,n))\n\n**Applications:**\n- Diff tools (file comparison)\n- DNA sequence alignment\n- Version control systems\n- Plagiarism detection",
    "example": "// LCS with DP - O(m*n) time and space\nfunction longestCommonSubsequence(text1, text2) {\n  const m = text1.length, n = text2.length;\n  // dp[i][j] = LCS length of text1[0..i-1] and text2[0..j-1]\n  const dp = Array(m + 1).fill(null)\n    .map(() => Array(n + 1).fill(0));\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;  // Match: extend\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);  // No match: take best\n      }\n    }\n  }\n  \n  return dp[m][n];\n}\n\n// Reconstruct the actual LCS string\nfunction getLCS(text1, text2) {\n  const m = text1.length, n = text2.length;\n  const dp = Array(m + 1).fill(null)\n    .map(() => Array(n + 1).fill(0));\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n  \n  // Backtrack to find the string\n  let i = m, j = n;\n  const lcs = [];\n  while (i > 0 && j > 0) {\n    if (text1[i - 1] === text2[j - 1]) {\n      lcs.unshift(text1[i - 1]);\n      i--; j--;\n    } else if (dp[i - 1][j] > dp[i][j - 1]) {\n      i--;\n    } else {\n      j--;\n    }\n  }\n  \n  return lcs.join('');\n}\n\n// Space-optimized O(n) - only need previous row\nfunction lcsOptimized(text1, text2) {\n  const m = text1.length, n = text2.length;\n  let prev = Array(n + 1).fill(0);\n  \n  for (let i = 1; i <= m; i++) {\n    const curr = Array(n + 1).fill(0);\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        curr[j] = prev[j - 1] + 1;\n      } else {\n        curr[j] = Math.max(prev[j], curr[j - 1]);\n      }\n    }\n    prev = curr;\n  }\n  \n  return prev[n];\n}"
  },
  {
    "id": 28,
    "question": "What is the Longest Increasing Subsequence (LIS) problem?",
    "answer": "**LIS** finds the longest subsequence where each element is strictly greater than the previous.\n\n**Example:**\n- nums = [10, 9, 2, 5, 3, 7, 101, 18]\n- LIS = [2, 3, 7, 101] or [2, 5, 7, 101] (length 4)\n\n**Approaches:**\n\n**1. DP - O(n²)**\n- dp[i] = LIS ending at index i\n- For each i, check all j < i where nums[j] < nums[i]\n\n**2. Binary Search - O(n log n)**\n- Maintain array of smallest tail for each length\n- For each num, find position using binary search\n- This doesn't give actual LIS, just length\n\n**Variations:**\n- Longest Non-Decreasing (allow equal)\n- Number of LIS sequences\n- Longest Bitonic Subsequence (increasing then decreasing)",
    "example": "// O(n²) DP solution\nfunction lengthOfLIS(nums) {\n  const n = nums.length;\n  if (n === 0) return 0;\n  \n  // dp[i] = length of LIS ending at index i\n  const dp = Array(n).fill(1);\n  \n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n  \n  return Math.max(...dp);\n}\n\n// O(n log n) Binary Search solution\nfunction lengthOfLISOptimal(nums) {\n  // tails[i] = smallest tail of all LIS of length i+1\n  const tails = [];\n  \n  for (const num of nums) {\n    // Binary search for position\n    let left = 0, right = tails.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    \n    // Replace or append\n    if (left === tails.length) {\n      tails.push(num);\n    } else {\n      tails[left] = num;\n    }\n  }\n  \n  return tails.length;\n}\n\n// Get actual LIS (one of them)\nfunction getActualLIS(nums) {\n  const n = nums.length;\n  const dp = Array(n).fill(1);\n  const parent = Array(n).fill(-1);\n  let maxLen = 1, maxIdx = 0;\n  \n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {\n        dp[i] = dp[j] + 1;\n        parent[i] = j;\n      }\n    }\n    if (dp[i] > maxLen) {\n      maxLen = dp[i];\n      maxIdx = i;\n    }\n  }\n  \n  // Reconstruct\n  const lis = [];\n  while (maxIdx !== -1) {\n    lis.unshift(nums[maxIdx]);\n    maxIdx = parent[maxIdx];\n  }\n  return lis;\n}"
  },
  {
    "id": 29,
    "question": "What is the 0/1 Knapsack problem?",
    "answer": "**0/1 Knapsack**: Given items with weights and values, and a knapsack capacity, maximize total value without exceeding capacity. Each item can be taken once (0 or 1).\n\n**Recurrence:**\n- For item i with weight w and value v:\n- dp[i][c] = max(dp[i-1][c], dp[i-1][c-w] + v)\n- Either skip item or include it (if it fits)\n\n**Variations:**\n- **Unbounded Knapsack**: Can take items multiple times\n- **Bounded Knapsack**: Limited quantity of each item\n- **Subset Sum**: Can we make exact sum? (values = weights)\n- **Partition Equal Subset**: Can we split into two equal sums?\n\n**Time:** O(n × W) where n = items, W = capacity\n**Space:** O(n × W), can optimize to O(W)",
    "example": "// 0/1 Knapsack - O(n*W) time and space\nfunction knapsack(weights, values, capacity) {\n  const n = weights.length;\n  // dp[i][w] = max value using first i items with capacity w\n  const dp = Array(n + 1).fill(null)\n    .map(() => Array(capacity + 1).fill(0));\n  \n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      // Option 1: Don't take item i\n      dp[i][w] = dp[i - 1][w];\n      \n      // Option 2: Take item i (if it fits)\n      if (weights[i - 1] <= w) {\n        dp[i][w] = Math.max(\n          dp[i][w],\n          dp[i - 1][w - weights[i - 1]] + values[i - 1]\n        );\n      }\n    }\n  }\n  \n  return dp[n][capacity];\n}\n\n// Space-optimized O(W)\nfunction knapsackOptimized(weights, values, capacity) {\n  const dp = Array(capacity + 1).fill(0);\n  \n  for (let i = 0; i < weights.length; i++) {\n    // Must go backwards to avoid using item twice!\n    for (let w = capacity; w >= weights[i]; w--) {\n      dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n    }\n  }\n  \n  return dp[capacity];\n}\n\n// Subset Sum - Can we make target sum?\nfunction canPartition(nums) {\n  const total = nums.reduce((a, b) => a + b, 0);\n  if (total % 2 !== 0) return false;\n  \n  const target = total / 2;\n  const dp = Array(target + 1).fill(false);\n  dp[0] = true;\n  \n  for (const num of nums) {\n    for (let j = target; j >= num; j--) {\n      dp[j] = dp[j] || dp[j - num];\n    }\n  }\n  \n  return dp[target];\n}\n\n// Unbounded Knapsack (can take items multiple times)\nfunction unboundedKnapsack(weights, values, capacity) {\n  const dp = Array(capacity + 1).fill(0);\n  \n  for (let w = 0; w <= capacity; w++) {\n    for (let i = 0; i < weights.length; i++) {\n      if (weights[i] <= w) {\n        dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n      }\n    }\n  }\n  \n  return dp[capacity];\n}"
  },
  {
    "id": 30,
    "question": "How do you perform Level Order Traversal of a Binary Tree?",
    "answer": "**Level Order Traversal** (BFS) visits nodes level by level, left to right.\n\n**Algorithm:**\n1. Use a queue (FIFO)\n2. Start with root in queue\n3. While queue not empty:\n   - Process all nodes at current level\n   - Add their children to queue\n\n**Key insight**: Process queue in batches (by level size) to track levels\n\n**Time:** O(n)\n**Space:** O(w) where w = max width of tree\n\n**Variations:**\n- Zigzag level order (alternate left/right)\n- Bottom-up level order\n- Right side view (last node of each level)\n- Average of levels",
    "example": "// Level Order Traversal - Returns array of arrays\nfunction levelOrder(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      currentLevel.push(node.val);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(currentLevel);\n  }\n  \n  return result;\n}\n\n// Zigzag Level Order (alternate direction each level)\nfunction zigzagLevelOrder(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];\n  let leftToRight = true;\n  \n  while (queue.length) {\n    const levelSize = queue.length;\n    const currentLevel = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      \n      if (leftToRight) {\n        currentLevel.push(node.val);\n      } else {\n        currentLevel.unshift(node.val);\n      }\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(currentLevel);\n    leftToRight = !leftToRight;\n  }\n  \n  return result;\n}\n\n// Right Side View (rightmost node at each level)\nfunction rightSideView(root) {\n  if (!root) return [];\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length) {\n    const levelSize = queue.length;\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      \n      // Last node in level\n      if (i === levelSize - 1) result.push(node.val);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 31,
    "question": "How do you find the Lowest Common Ancestor (LCA)?",
    "answer": "**LCA** of two nodes p and q is the deepest node that has both p and q as descendants (a node can be a descendant of itself).\n\n**For Binary Tree (general):**\n- Recursively search left and right subtrees\n- If both sides return non-null, current node is LCA\n- If only one side returns non-null, propagate it up\n\n**For BST:**\n- Use BST property to guide search\n- If both values < current, go left\n- If both values > current, go right\n- Otherwise, current is LCA (split point)\n\n**Time:** O(n) for binary tree, O(h) for BST\n**Space:** O(h) for recursion stack",
    "example": "// LCA for Binary Tree - O(n)\nfunction lowestCommonAncestor(root, p, q) {\n  if (!root || root === p || root === q) return root;\n  \n  const left = lowestCommonAncestor(root.left, p, q);\n  const right = lowestCommonAncestor(root.right, p, q);\n  \n  // If both sides found something, root is LCA\n  if (left && right) return root;\n  \n  // Otherwise return whichever side found something\n  return left || right;\n}\n\n// LCA for BST - O(h)\nfunction lcaBST(root, p, q) {\n  while (root) {\n    if (p.val < root.val && q.val < root.val) {\n      root = root.left;   // Both in left subtree\n    } else if (p.val > root.val && q.val > root.val) {\n      root = root.right;  // Both in right subtree\n    } else {\n      return root;        // Split point = LCA\n    }\n  }\n  return null;\n}\n\n// LCA with parent pointers (like finding intersection of linked lists)\nfunction lcaWithParent(p, q) {\n  const ancestors = new Set();\n  \n  // Add all ancestors of p\n  while (p) {\n    ancestors.add(p);\n    p = p.parent;\n  }\n  \n  // Find first common ancestor in q's path\n  while (q) {\n    if (ancestors.has(q)) return q;\n    q = q.parent;\n  }\n  \n  return null;\n}\n\n// LCA for multiple nodes\nfunction lcaMultiple(root, nodes) {\n  const nodeSet = new Set(nodes);\n  \n  function dfs(node) {\n    if (!node || nodeSet.has(node)) return node;\n    \n    const left = dfs(node.left);\n    const right = dfs(node.right);\n    \n    if (left && right) return node;\n    return left || right;\n  }\n  \n  return dfs(root);\n}"
  },
  {
    "id": 32,
    "question": "What is the Edit Distance (Levenshtein Distance) problem?",
    "answer": "**Edit Distance** finds the minimum number of operations to convert string A to string B.\n\n**Operations (each costs 1):**\n- Insert a character\n- Delete a character\n- Replace a character\n\n**Recurrence:**\n- If chars match: dp[i][j] = dp[i-1][j-1] (no cost)\n- If not: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n  - dp[i-1][j]: delete from A\n  - dp[i][j-1]: insert into A\n  - dp[i-1][j-1]: replace\n\n**Time:** O(m × n)\n**Space:** O(m × n), can optimize to O(n)\n\n**Applications:**\n- Spell checkers\n- DNA sequence alignment\n- Fuzzy string matching\n- Plagiarism detection",
    "example": "// Edit Distance - O(m*n)\nfunction minDistance(word1, word2) {\n  const m = word1.length, n = word2.length;\n  \n  // dp[i][j] = min ops to convert word1[0..i-1] to word2[0..j-1]\n  const dp = Array(m + 1).fill(null)\n    .map(() => Array(n + 1).fill(0));\n  \n  // Base cases: converting to/from empty string\n  for (let i = 0; i <= m; i++) dp[i][0] = i;  // Delete all\n  for (let j = 0; j <= n; j++) dp[0][j] = j;  // Insert all\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];  // Chars match, no op needed\n      } else {\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],     // Delete from word1\n          dp[i][j - 1],     // Insert into word1\n          dp[i - 1][j - 1]  // Replace\n        );\n      }\n    }\n  }\n  \n  return dp[m][n];\n}\n\n// Space-optimized O(n)\nfunction minDistanceOptimized(word1, word2) {\n  const m = word1.length, n = word2.length;\n  let prev = Array.from({ length: n + 1 }, (_, i) => i);\n  \n  for (let i = 1; i <= m; i++) {\n    const curr = [i];\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        curr[j] = prev[j - 1];\n      } else {\n        curr[j] = 1 + Math.min(prev[j], curr[j - 1], prev[j - 1]);\n      }\n    }\n    prev = curr;\n  }\n  \n  return prev[n];\n}\n\n// Get the actual edit operations\nfunction getEditOps(word1, word2) {\n  const m = word1.length, n = word2.length;\n  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) dp[i][0] = i;\n  for (let j = 0; j <= n; j++) dp[0][j] = j;\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n      }\n    }\n  }\n  \n  // Backtrack to find operations\n  const ops = [];\n  let i = m, j = n;\n  while (i > 0 || j > 0) {\n    if (i > 0 && j > 0 && word1[i - 1] === word2[j - 1]) {\n      i--; j--;\n    } else if (j > 0 && (i === 0 || dp[i][j - 1] <= dp[i - 1][j] && dp[i][j - 1] <= dp[i - 1][j - 1])) {\n      ops.unshift(`Insert ${word2[j - 1]}`);\n      j--;\n    } else if (i > 0 && (j === 0 || dp[i - 1][j] <= dp[i - 1][j - 1])) {\n      ops.unshift(`Delete ${word1[i - 1]}`);\n      i--;\n    } else {\n      ops.unshift(`Replace ${word1[i - 1]} with ${word2[j - 1]}`);\n      i--; j--;\n    }\n  }\n  return ops;\n}"
  },
  {
    "id": 33,
    "question": "How do you solve Interval problems (Merge, Insert)?",
    "answer": "**Interval problems** deal with ranges [start, end] and their relationships.\n\n**Key concepts:**\n- **Overlap**: Two intervals overlap if start1 <= end2 AND start2 <= end1\n- **Merge**: Combine overlapping intervals into one\n\n**Common problems:**\n\n**1. Merge Overlapping Intervals**\n- Sort by start time\n- Merge consecutive overlapping intervals\n\n**2. Insert Interval**\n- Find position, merge if overlapping\n\n**3. Non-overlapping Intervals**\n- Minimum removals to make all non-overlapping\n- Greedy: keep interval ending earliest\n\n**Time:** O(n log n) for sorting\n**Space:** O(n) for result",
    "example": "// Merge Overlapping Intervals\nfunction merge(intervals) {\n  if (intervals.length <= 1) return intervals;\n  \n  // Sort by start time\n  intervals.sort((a, b) => a[0] - b[0]);\n  \n  const result = [intervals[0]];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    const prev = result[result.length - 1];\n    const curr = intervals[i];\n    \n    if (curr[0] <= prev[1]) {\n      // Overlapping - merge by extending end\n      prev[1] = Math.max(prev[1], curr[1]);\n    } else {\n      // Non-overlapping - add new interval\n      result.push(curr);\n    }\n  }\n  \n  return result;\n}\n\n// Insert Interval\nfunction insert(intervals, newInterval) {\n  const result = [];\n  let i = 0;\n  const n = intervals.length;\n  \n  // Add all intervals before newInterval\n  while (i < n && intervals[i][1] < newInterval[0]) {\n    result.push(intervals[i]);\n    i++;\n  }\n  \n  // Merge overlapping intervals\n  while (i < n && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  result.push(newInterval);\n  \n  // Add remaining intervals\n  while (i < n) {\n    result.push(intervals[i]);\n    i++;\n  }\n  \n  return result;\n}\n\n// Minimum Removals for Non-overlapping\nfunction eraseOverlapIntervals(intervals) {\n  if (intervals.length <= 1) return 0;\n  \n  // Sort by end time (greedy: keep earliest ending)\n  intervals.sort((a, b) => a[1] - b[1]);\n  \n  let count = 0;\n  let prevEnd = intervals[0][1];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < prevEnd) {\n      count++;  // Overlaps - remove this one\n    } else {\n      prevEnd = intervals[i][1];  // No overlap - update end\n    }\n  }\n  \n  return count;\n}\n\n// Meeting Rooms II - Minimum meeting rooms needed\nfunction minMeetingRooms(intervals) {\n  const starts = intervals.map(i => i[0]).sort((a, b) => a - b);\n  const ends = intervals.map(i => i[1]).sort((a, b) => a - b);\n  \n  let rooms = 0, maxRooms = 0;\n  let s = 0, e = 0;\n  \n  while (s < intervals.length) {\n    if (starts[s] < ends[e]) {\n      rooms++;  // New meeting starts\n      s++;\n    } else {\n      rooms--;  // A meeting ends\n      e++;\n    }\n    maxRooms = Math.max(maxRooms, rooms);\n  }\n  \n  return maxRooms;\n}"
  },
  {
    "id": 34,
    "question": "What are common Bit Manipulation techniques?",
    "answer": "**Bit manipulation** operates directly on binary representations for efficiency.\n\n**Basic operations:**\n- **AND (&)**: Both bits 1 → 1\n- **OR (|)**: Either bit 1 → 1\n- **XOR (^)**: Different bits → 1\n- **NOT (~)**: Flip all bits\n- **Left shift (<<)**: Multiply by 2\n- **Right shift (>>)**: Divide by 2\n\n**Common tricks:**\n- Check if power of 2: `n & (n-1) === 0`\n- Get rightmost set bit: `n & (-n)`\n- Clear rightmost set bit: `n & (n-1)`\n- Check if bit set: `(n >> i) & 1`\n- Set bit: `n | (1 << i)`\n- Clear bit: `n & ~(1 << i)`\n\n**XOR properties:**\n- a ^ a = 0\n- a ^ 0 = a\n- XOR is commutative and associative",
    "example": "// Count set bits (1s) - Brian Kernighan's algorithm\nfunction countBits(n) {\n  let count = 0;\n  while (n) {\n    n &= (n - 1);  // Clear rightmost set bit\n    count++;\n  }\n  return count;\n}\n\n// Single Number - Find element that appears once (others twice)\nfunction singleNumber(nums) {\n  return nums.reduce((a, b) => a ^ b, 0);\n}\n// Works because a ^ a = 0 and a ^ 0 = a\n\n// Check if power of 2\nfunction isPowerOfTwo(n) {\n  return n > 0 && (n & (n - 1)) === 0;\n}\n\n// Reverse bits of a 32-bit integer\nfunction reverseBits(n) {\n  let result = 0;\n  for (let i = 0; i < 32; i++) {\n    result = (result << 1) | (n & 1);\n    n >>>= 1;\n  }\n  return result >>> 0;  // Convert to unsigned\n}\n\n// Missing Number - Find missing in [0, n]\nfunction missingNumber(nums) {\n  let xor = nums.length;\n  for (let i = 0; i < nums.length; i++) {\n    xor ^= i ^ nums[i];\n  }\n  return xor;\n}\n\n// Two numbers appearing once (others twice)\nfunction singleNumberIII(nums) {\n  // XOR all to get a ^ b (the two single numbers)\n  let xor = nums.reduce((a, b) => a ^ b, 0);\n  \n  // Find rightmost set bit (where a and b differ)\n  const rightmostBit = xor & (-xor);\n  \n  // Separate into two groups and XOR each\n  let a = 0, b = 0;\n  for (const num of nums) {\n    if (num & rightmostBit) {\n      a ^= num;\n    } else {\n      b ^= num;\n    }\n  }\n  \n  return [a, b];\n}\n\n// Generate all subsets using bitmask\nfunction subsets(nums) {\n  const result = [];\n  const n = nums.length;\n  \n  for (let mask = 0; mask < (1 << n); mask++) {\n    const subset = [];\n    for (let i = 0; i < n; i++) {\n      if (mask & (1 << i)) subset.push(nums[i]);\n    }\n    result.push(subset);\n  }\n  \n  return result;\n}"
  },
  {
    "id": 35,
    "question": "What is Quick Select for finding Kth largest/smallest?",
    "answer": "**Quick Select** finds the kth smallest (or largest) element without fully sorting the array.\n\n**Algorithm (based on Quick Sort partition):**\n1. Pick a pivot and partition\n2. Pivot ends up at its final sorted position\n3. If pivot position = k, found it!\n4. Otherwise, recurse on the relevant half only\n\n**Time Complexity:**\n- Average: O(n)\n- Worst: O(n²) - bad pivot choices\n- Can improve with random pivot\n\n**Space:** O(1) if iterative\n\n**Compared to:**\n- Sorting: O(n log n)\n- Heap: O(n log k)\n- Quick Select: O(n) average\n\n**Use cases:**\n- Kth largest element\n- Median finding\n- Top K elements",
    "example": "// Quick Select - O(n) average\nfunction findKthLargest(nums, k) {\n  // Convert to kth smallest index\n  const targetIdx = nums.length - k;\n  \n  function quickSelect(left, right) {\n    const pivotIdx = partition(left, right);\n    \n    if (pivotIdx === targetIdx) return nums[pivotIdx];\n    if (pivotIdx < targetIdx) return quickSelect(pivotIdx + 1, right);\n    return quickSelect(left, pivotIdx - 1);\n  }\n  \n  function partition(left, right) {\n    // Random pivot for better average case\n    const randomIdx = left + Math.floor(Math.random() * (right - left + 1));\n    [nums[randomIdx], nums[right]] = [nums[right], nums[randomIdx]];\n    \n    const pivot = nums[right];\n    let i = left;\n    \n    for (let j = left; j < right; j++) {\n      if (nums[j] < pivot) {\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n        i++;\n      }\n    }\n    \n    [nums[i], nums[right]] = [nums[right], nums[i]];\n    return i;\n  }\n  \n  return quickSelect(0, nums.length - 1);\n}\n\n// Top K Frequent Elements using Quick Select\nfunction topKFrequent(nums, k) {\n  // Count frequencies\n  const freq = new Map();\n  for (const num of nums) {\n    freq.set(num, (freq.get(num) || 0) + 1);\n  }\n  \n  const unique = [...freq.keys()];\n  const n = unique.length;\n  \n  function partition(left, right) {\n    const pivotFreq = freq.get(unique[right]);\n    let i = left;\n    \n    for (let j = left; j < right; j++) {\n      if (freq.get(unique[j]) < pivotFreq) {\n        [unique[i], unique[j]] = [unique[j], unique[i]];\n        i++;\n      }\n    }\n    \n    [unique[i], unique[right]] = [unique[right], unique[i]];\n    return i;\n  }\n  \n  function quickSelect(left, right) {\n    const pivotIdx = partition(left, right);\n    if (pivotIdx === n - k) return;\n    if (pivotIdx < n - k) quickSelect(pivotIdx + 1, right);\n    else quickSelect(left, pivotIdx - 1);\n  }\n  \n  quickSelect(0, n - 1);\n  return unique.slice(n - k);\n}\n\n// Alternative: Use Min Heap for K largest - O(n log k)\nfunction findKthLargestHeap(nums, k) {\n  const minHeap = new MinHeap();\n  \n  for (const num of nums) {\n    minHeap.insert(num);\n    if (minHeap.size() > k) {\n      minHeap.extractMin();  // Remove smallest\n    }\n  }\n  \n  return minHeap.peek();  // Kth largest is min of top k\n}"
  },
  {
    "id": 36,
    "question": "How do you Clone a Graph (Deep Copy)?",
    "answer": "**Clone Graph** creates a deep copy of a graph where all nodes are new objects with the same structure.\n\n**Challenge:**\n- Nodes may be visited multiple times (cycles)\n- Must not create duplicate clones\n\n**Solution:**\n- Use a hash map to track original → clone mapping\n- If already cloned, return existing clone\n- Clone node, then recursively clone neighbors\n\n**Approaches:**\n- DFS: Recursive cloning\n- BFS: Level-by-level cloning\n\n**Time:** O(V + E)\n**Space:** O(V) for hash map\n\n**Similar problems:**\n- Copy List with Random Pointer\n- Clone Binary Tree with Random Pointer",
    "example": "// Clone Graph using DFS\nfunction cloneGraph(node) {\n  if (!node) return null;\n  \n  const visited = new Map();  // original -> clone\n  \n  function dfs(node) {\n    if (visited.has(node)) return visited.get(node);\n    \n    // Create clone\n    const clone = { val: node.val, neighbors: [] };\n    visited.set(node, clone);\n    \n    // Clone neighbors\n    for (const neighbor of node.neighbors) {\n      clone.neighbors.push(dfs(neighbor));\n    }\n    \n    return clone;\n  }\n  \n  return dfs(node);\n}\n\n// Clone Graph using BFS\nfunction cloneGraphBFS(node) {\n  if (!node) return null;\n  \n  const visited = new Map();\n  const queue = [node];\n  visited.set(node, { val: node.val, neighbors: [] });\n  \n  while (queue.length) {\n    const curr = queue.shift();\n    \n    for (const neighbor of curr.neighbors) {\n      if (!visited.has(neighbor)) {\n        visited.set(neighbor, { val: neighbor.val, neighbors: [] });\n        queue.push(neighbor);\n      }\n      // Connect clone to cloned neighbor\n      visited.get(curr).neighbors.push(visited.get(neighbor));\n    }\n  }\n  \n  return visited.get(node);\n}\n\n// Copy List with Random Pointer\nfunction copyRandomList(head) {\n  if (!head) return null;\n  \n  const map = new Map();\n  \n  // First pass: create all nodes\n  let curr = head;\n  while (curr) {\n    map.set(curr, { val: curr.val, next: null, random: null });\n    curr = curr.next;\n  }\n  \n  // Second pass: connect pointers\n  curr = head;\n  while (curr) {\n    const clone = map.get(curr);\n    clone.next = map.get(curr.next) || null;\n    clone.random = map.get(curr.random) || null;\n    curr = curr.next;\n  }\n  \n  return map.get(head);\n}\n\n// Clone Binary Tree with Random Pointer\nfunction cloneTree(root) {\n  if (!root) return null;\n  \n  const map = new Map();\n  \n  function cloneNode(node) {\n    if (!node) return null;\n    if (map.has(node)) return map.get(node);\n    \n    const clone = { val: node.val };\n    map.set(node, clone);\n    \n    clone.left = cloneNode(node.left);\n    clone.right = cloneNode(node.right);\n    clone.random = cloneNode(node.random);\n    \n    return clone;\n  }\n  \n  return cloneNode(root);\n}"
  },
  {
    "id": 37,
    "question": "How do you rotate a matrix 90 degrees?",
    "answer": "**Matrix Rotation** transforms a matrix by rotating elements 90° clockwise or counter-clockwise.\n\n**90° Clockwise:**\n- Method 1: Transpose + Reverse rows\n- Method 2: Layer-by-layer rotation\n\n**90° Counter-clockwise:**\n- Transpose + Reverse columns\n- Or: Reverse rows + Transpose\n\n**180°:**\n- Reverse rows + Reverse each row\n- Or: Two 90° rotations\n\n**In-place transformation:**\n- Transpose: Swap matrix[i][j] with matrix[j][i]\n- Reverse row: Two pointers from ends\n\n**Time:** O(n²)\n**Space:** O(1) in-place",
    "example": "// Rotate 90° Clockwise - In place\n// Step 1: Transpose (swap across diagonal)\n// Step 2: Reverse each row\nfunction rotate(matrix) {\n  const n = matrix.length;\n  \n  // Transpose\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  \n  // Reverse each row\n  for (let i = 0; i < n; i++) {\n    matrix[i].reverse();\n  }\n}\n\n// Rotate 90° Counter-clockwise\nfunction rotateCounterClockwise(matrix) {\n  const n = matrix.length;\n  \n  // Transpose\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  \n  // Reverse each column\n  for (let j = 0; j < n; j++) {\n    let top = 0, bottom = n - 1;\n    while (top < bottom) {\n      [matrix[top][j], matrix[bottom][j]] = [matrix[bottom][j], matrix[top][j]];\n      top++;\n      bottom--;\n    }\n  }\n}\n\n// Layer-by-layer rotation (4-way swap)\nfunction rotateLayerByLayer(matrix) {\n  const n = matrix.length;\n  \n  for (let layer = 0; layer < Math.floor(n / 2); layer++) {\n    const first = layer;\n    const last = n - 1 - layer;\n    \n    for (let i = first; i < last; i++) {\n      const offset = i - first;\n      \n      // Save top\n      const top = matrix[first][i];\n      \n      // Left -> Top\n      matrix[first][i] = matrix[last - offset][first];\n      \n      // Bottom -> Left\n      matrix[last - offset][first] = matrix[last][last - offset];\n      \n      // Right -> Bottom\n      matrix[last][last - offset] = matrix[i][last];\n      \n      // Top -> Right\n      matrix[i][last] = top;\n    }\n  }\n}\n\n// Spiral Matrix - Return elements in spiral order\nfunction spiralOrder(matrix) {\n  const result = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    // Right\n    for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n    top++;\n    // Down\n    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n    right--;\n    // Left\n    if (top <= bottom) {\n      for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n      bottom--;\n    }\n    // Up\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n      left++;\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 38,
    "question": "How do you Serialize and Deserialize a Binary Tree?",
    "answer": "**Serialization** converts a tree to a string; **Deserialization** reconstructs the tree from that string.\n\n**Challenges:**\n- Must handle null nodes to preserve structure\n- Must be able to uniquely reconstruct the tree\n\n**Approaches:**\n\n**1. Preorder with null markers**\n- Visit: root, left, right\n- Use special marker for null (e.g., \"#\")\n- Simple to implement\n\n**2. Level-order (BFS)**\n- Level by level\n- Include nulls to preserve positions\n- More intuitive visualization\n\n**Time:** O(n)\n**Space:** O(n)\n\n**Note:** For BST, preorder without null markers is sufficient (can reconstruct using BST property)",
    "example": "// Preorder DFS approach\nclass Codec {\n  // Serialize tree to string\n  serialize(root) {\n    const result = [];\n    \n    function preorder(node) {\n      if (!node) {\n        result.push('#');\n        return;\n      }\n      result.push(node.val);\n      preorder(node.left);\n      preorder(node.right);\n    }\n    \n    preorder(root);\n    return result.join(',');\n  }\n  \n  // Deserialize string to tree\n  deserialize(data) {\n    const values = data.split(',');\n    let index = 0;\n    \n    function build() {\n      if (values[index] === '#') {\n        index++;\n        return null;\n      }\n      \n      const node = { val: parseInt(values[index]), left: null, right: null };\n      index++;\n      node.left = build();\n      node.right = build();\n      return node;\n    }\n    \n    return build();\n  }\n}\n\n// BFS Level-order approach\nclass CodecBFS {\n  serialize(root) {\n    if (!root) return '';\n    \n    const result = [];\n    const queue = [root];\n    \n    while (queue.length) {\n      const node = queue.shift();\n      if (node) {\n        result.push(node.val);\n        queue.push(node.left);\n        queue.push(node.right);\n      } else {\n        result.push('#');\n      }\n    }\n    \n    return result.join(',');\n  }\n  \n  deserialize(data) {\n    if (!data) return null;\n    \n    const values = data.split(',');\n    const root = { val: parseInt(values[0]), left: null, right: null };\n    const queue = [root];\n    let i = 1;\n    \n    while (queue.length && i < values.length) {\n      const node = queue.shift();\n      \n      if (values[i] !== '#') {\n        node.left = { val: parseInt(values[i]), left: null, right: null };\n        queue.push(node.left);\n      }\n      i++;\n      \n      if (values[i] !== '#') {\n        node.right = { val: parseInt(values[i]), left: null, right: null };\n        queue.push(node.right);\n      }\n      i++;\n    }\n    \n    return root;\n  }\n}\n\n// BST serialization (no nulls needed)\nclass CodecBST {\n  serialize(root) {\n    const result = [];\n    function preorder(node) {\n      if (!node) return;\n      result.push(node.val);\n      preorder(node.left);\n      preorder(node.right);\n    }\n    preorder(root);\n    return result.join(',');\n  }\n  \n  deserialize(data) {\n    if (!data) return null;\n    const values = data.split(',').map(Number);\n    let i = 0;\n    \n    function build(min, max) {\n      if (i >= values.length || values[i] < min || values[i] > max) {\n        return null;\n      }\n      const val = values[i++];\n      return {\n        val,\n        left: build(min, val),\n        right: build(val, max)\n      };\n    }\n    \n    return build(-Infinity, Infinity);\n  }\n}"
  },
  {
    "id": 39,
    "question": "How do you generate Subsets and Combinations?",
    "answer": "**Subsets**: All possible subsets of a set (power set)\n- n elements → 2^n subsets\n\n**Combinations**: All ways to choose k elements from n\n- C(n,k) = n! / (k! × (n-k)!)\n\n**Approaches:**\n\n**1. Backtracking**\n- For each element, choose to include or exclude\n- Track current subset, add to result at each step\n\n**2. Iterative**\n- Start with empty set\n- For each element, add it to all existing subsets\n\n**3. Bitmask**\n- Each subset corresponds to a binary number\n- Bit i set = element i included\n\n**Time:** O(2^n) for subsets, O(C(n,k)) for combinations\n**Space:** O(n) for recursion depth",
    "example": "// Subsets - Backtracking\nfunction subsets(nums) {\n  const result = [];\n  \n  function backtrack(start, current) {\n    result.push([...current]);  // Add every subset\n    \n    for (let i = start; i < nums.length; i++) {\n      current.push(nums[i]);      // Include\n      backtrack(i + 1, current);  // Recurse\n      current.pop();              // Exclude (backtrack)\n    }\n  }\n  \n  backtrack(0, []);\n  return result;\n}\n\n// Subsets - Iterative\nfunction subsetsIterative(nums) {\n  const result = [[]];\n  \n  for (const num of nums) {\n    const newSubsets = result.map(subset => [...subset, num]);\n    result.push(...newSubsets);\n  }\n  \n  return result;\n}\n\n// Combinations - Choose k from n\nfunction combine(n, k) {\n  const result = [];\n  \n  function backtrack(start, current) {\n    if (current.length === k) {\n      result.push([...current]);\n      return;\n    }\n    \n    // Optimization: stop if not enough elements left\n    for (let i = start; i <= n - (k - current.length) + 1; i++) {\n      current.push(i);\n      backtrack(i + 1, current);\n      current.pop();\n    }\n  }\n  \n  backtrack(1, []);\n  return result;\n}\n\n// Combination Sum - Find combinations that sum to target\nfunction combinationSum(candidates, target) {\n  const result = [];\n  \n  function backtrack(start, current, remaining) {\n    if (remaining === 0) {\n      result.push([...current]);\n      return;\n    }\n    if (remaining < 0) return;\n    \n    for (let i = start; i < candidates.length; i++) {\n      current.push(candidates[i]);\n      backtrack(i, current, remaining - candidates[i]);  // Can reuse same element\n      current.pop();\n    }\n  }\n  \n  backtrack(0, [], target);\n  return result;\n}\n\n// Subsets with Duplicates\nfunction subsetsWithDup(nums) {\n  nums.sort((a, b) => a - b);  // Sort to handle duplicates\n  const result = [];\n  \n  function backtrack(start, current) {\n    result.push([...current]);\n    \n    for (let i = start; i < nums.length; i++) {\n      // Skip duplicates at same level\n      if (i > start && nums[i] === nums[i - 1]) continue;\n      \n      current.push(nums[i]);\n      backtrack(i + 1, current);\n      current.pop();\n    }\n  }\n  \n  backtrack(0, []);\n  return result;\n}"
  },
  {
    "id": 40,
    "question": "How do you solve Word Search in a Grid?",
    "answer": "**Word Search** finds if a word exists in a 2D grid by moving horizontally or vertically through adjacent cells.\n\n**Approach: Backtracking DFS**\n1. Start from each cell\n2. DFS in 4 directions (up, down, left, right)\n3. Mark visited cells to avoid reuse\n4. Backtrack by unmarking when returning\n\n**Key considerations:**\n- Can't reuse same cell in one word\n- Must mark/unmark visited cells\n- Early termination when word found\n\n**Time:** O(m × n × 4^L) where L = word length\n**Space:** O(L) for recursion stack\n\n**Optimization:**\n- Check if char exists before starting DFS\n- Use Trie for multiple word search",
    "example": "// Word Search - Single word\nfunction exist(board, word) {\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  function dfs(r, c, index) {\n    if (index === word.length) return true;  // Found entire word\n    \n    if (r < 0 || r >= rows || c < 0 || c >= cols) return false;\n    if (board[r][c] !== word[index]) return false;\n    \n    // Mark as visited\n    const temp = board[r][c];\n    board[r][c] = '#';\n    \n    // Explore 4 directions\n    const found = dfs(r + 1, c, index + 1) ||\n                  dfs(r - 1, c, index + 1) ||\n                  dfs(r, c + 1, index + 1) ||\n                  dfs(r, c - 1, index + 1);\n    \n    // Backtrack - restore cell\n    board[r][c] = temp;\n    \n    return found;\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n  \n  return false;\n}\n\n// Word Search II - Find all words from list (use Trie)\nfunction findWords(board, words) {\n  const result = [];\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  // Build Trie\n  const trie = {};\n  for (const word of words) {\n    let node = trie;\n    for (const char of word) {\n      if (!node[char]) node[char] = {};\n      node = node[char];\n    }\n    node.word = word;  // Mark end of word\n  }\n  \n  function dfs(r, c, node) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    \n    const char = board[r][c];\n    if (char === '#' || !node[char]) return;\n    \n    node = node[char];\n    if (node.word) {\n      result.push(node.word);\n      node.word = null;  // Avoid duplicates\n    }\n    \n    board[r][c] = '#';  // Mark visited\n    \n    dfs(r + 1, c, node);\n    dfs(r - 1, c, node);\n    dfs(r, c + 1, node);\n    dfs(r, c - 1, node);\n    \n    board[r][c] = char;  // Backtrack\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      dfs(r, c, trie);\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 41,
    "question": "What is a Minimum Spanning Tree (MST)?",
    "answer": "A **Minimum Spanning Tree** connects all vertices in a weighted undirected graph with minimum total edge weight.\n\n**Properties:**\n- Includes all V vertices\n- Has exactly V-1 edges\n- No cycles\n- Minimum total weight\n\n**Algorithms:**\n\n**1. Kruskal's (Greedy on edges)**\n- Sort edges by weight\n- Add edges if they don't form cycle (use Union-Find)\n- O(E log E)\n\n**2. Prim's (Greedy on vertices)**\n- Start from any vertex\n- Always add cheapest edge to unvisited vertex\n- O(E log V) with heap\n\n**Use cases:**\n- Network design (minimum cable)\n- Clustering\n- Approximation for NP-hard problems",
    "example": "// Kruskal's Algorithm - O(E log E)\nfunction kruskalMST(n, edges) {\n  // Sort edges by weight\n  edges.sort((a, b) => a[2] - b[2]);\n  \n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = Array(n).fill(0);\n  \n  function find(x) {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n  \n  function union(x, y) {\n    const px = find(x), py = find(y);\n    if (px === py) return false;\n    if (rank[px] < rank[py]) parent[px] = py;\n    else if (rank[px] > rank[py]) parent[py] = px;\n    else { parent[py] = px; rank[px]++; }\n    return true;\n  }\n  \n  const mst = [];\n  let totalWeight = 0;\n  \n  for (const [u, v, weight] of edges) {\n    if (union(u, v)) {\n      mst.push([u, v, weight]);\n      totalWeight += weight;\n      if (mst.length === n - 1) break;  // MST complete\n    }\n  }\n  \n  return { mst, totalWeight };\n}\n\n// Prim's Algorithm - O(E log V)\nfunction primMST(n, adjList) {\n  const visited = new Set();\n  const mst = [];\n  let totalWeight = 0;\n  \n  // Min-heap: [weight, vertex, parent]\n  const heap = [[0, 0, -1]];\n  \n  while (heap.length && visited.size < n) {\n    // Extract min (simplified - use proper heap in production)\n    heap.sort((a, b) => a[0] - b[0]);\n    const [weight, vertex, parent] = heap.shift();\n    \n    if (visited.has(vertex)) continue;\n    visited.add(vertex);\n    \n    if (parent !== -1) {\n      mst.push([parent, vertex, weight]);\n      totalWeight += weight;\n    }\n    \n    for (const { node, weight: w } of adjList[vertex]) {\n      if (!visited.has(node)) {\n        heap.push([w, node, vertex]);\n      }\n    }\n  }\n  \n  return { mst, totalWeight };\n}\n\n// Usage\nconst edges = [[0, 1, 4], [0, 2, 3], [1, 2, 1], [1, 3, 2], [2, 3, 4]];\nconst result = kruskalMST(4, edges);\n// MST edges: [1,2,1], [1,3,2], [0,2,3] - Total: 6"
  },
  {
    "id": 42,
    "question": "What is the Bellman-Ford Algorithm?",
    "answer": "**Bellman-Ford** finds shortest paths from a source vertex, handling negative edge weights.\n\n**Algorithm:**\n1. Initialize distances (source = 0, others = ∞)\n2. Relax all edges V-1 times\n3. Check for negative cycles (one more relaxation)\n\n**Why V-1 iterations?**\n- Shortest path has at most V-1 edges\n- Each iteration guarantees one more edge is correct\n\n**Compared to Dijkstra:**\n- Bellman-Ford: O(V × E), handles negative weights\n- Dijkstra: O((V + E) log V), no negative weights\n\n**Negative cycle detection:**\n- After V-1 iterations, if any edge can still be relaxed, negative cycle exists\n\n**Use cases:**\n- Currency exchange arbitrage\n- Network routing with variable costs",
    "example": "// Bellman-Ford Algorithm - O(V * E)\nfunction bellmanFord(n, edges, source) {\n  const dist = Array(n).fill(Infinity);\n  dist[source] = 0;\n  \n  // Relax all edges V-1 times\n  for (let i = 0; i < n - 1; i++) {\n    for (const [u, v, weight] of edges) {\n      if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {\n        dist[v] = dist[u] + weight;\n      }\n    }\n  }\n  \n  // Check for negative cycles\n  for (const [u, v, weight] of edges) {\n    if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {\n      return { hasNegativeCycle: true, dist: null };\n    }\n  }\n  \n  return { hasNegativeCycle: false, dist };\n}\n\n// Cheapest Flights Within K Stops (modified Bellman-Ford)\nfunction findCheapestPrice(n, flights, src, dst, k) {\n  let prices = Array(n).fill(Infinity);\n  prices[src] = 0;\n  \n  // K+1 iterations (K stops = K+1 edges)\n  for (let i = 0; i <= k; i++) {\n    const temp = [...prices];  // Use previous iteration's values\n    \n    for (const [from, to, price] of flights) {\n      if (prices[from] !== Infinity) {\n        temp[to] = Math.min(temp[to], prices[from] + price);\n      }\n    }\n    \n    prices = temp;\n  }\n  \n  return prices[dst] === Infinity ? -1 : prices[dst];\n}\n\n// SPFA - Optimized Bellman-Ford using queue\nfunction spfa(n, adjList, source) {\n  const dist = Array(n).fill(Infinity);\n  const inQueue = Array(n).fill(false);\n  const count = Array(n).fill(0);  // For cycle detection\n  \n  dist[source] = 0;\n  const queue = [source];\n  inQueue[source] = true;\n  \n  while (queue.length) {\n    const u = queue.shift();\n    inQueue[u] = false;\n    \n    for (const { node: v, weight } of adjList[u]) {\n      if (dist[u] + weight < dist[v]) {\n        dist[v] = dist[u] + weight;\n        count[v] = count[u] + 1;\n        \n        if (count[v] >= n) return null;  // Negative cycle\n        \n        if (!inQueue[v]) {\n          queue.push(v);\n          inQueue[v] = true;\n        }\n      }\n    }\n  }\n  \n  return dist;\n}"
  },
  {
    "id": 43,
    "question": "What are String Matching Algorithms (KMP, Rabin-Karp)?",
    "answer": "**String matching** finds occurrences of a pattern in a text.\n\n**Naive approach:** O(n × m) - compare at every position\n\n**KMP (Knuth-Morris-Pratt):** O(n + m)\n- Precompute failure/LPS array\n- On mismatch, use LPS to skip characters\n- Never re-examine text characters\n\n**Rabin-Karp:** O(n + m) average\n- Use rolling hash to compare substrings\n- Only compare characters when hashes match\n- Good for multiple pattern search\n\n**Other algorithms:**\n- Boyer-Moore: Skip based on bad character/good suffix\n- Z-algorithm: Build Z-array for pattern matching\n\n**Applications:**\n- Text editors (find/replace)\n- DNA sequence matching\n- Plagiarism detection",
    "example": "// KMP Algorithm - O(n + m)\nfunction kmpSearch(text, pattern) {\n  if (pattern.length === 0) return 0;\n  \n  // Build LPS (Longest Proper Prefix which is also Suffix)\n  const lps = buildLPS(pattern);\n  const results = [];\n  \n  let i = 0;  // text index\n  let j = 0;  // pattern index\n  \n  while (i < text.length) {\n    if (text[i] === pattern[j]) {\n      i++;\n      j++;\n      if (j === pattern.length) {\n        results.push(i - j);  // Found match\n        j = lps[j - 1];  // Continue searching\n      }\n    } else {\n      if (j !== 0) {\n        j = lps[j - 1];  // Use LPS to skip\n      } else {\n        i++;\n      }\n    }\n  }\n  \n  return results;\n}\n\nfunction buildLPS(pattern) {\n  const lps = [0];\n  let len = 0;\n  let i = 1;\n  \n  while (i < pattern.length) {\n    if (pattern[i] === pattern[len]) {\n      len++;\n      lps[i] = len;\n      i++;\n    } else {\n      if (len !== 0) {\n        len = lps[len - 1];\n      } else {\n        lps[i] = 0;\n        i++;\n      }\n    }\n  }\n  \n  return lps;\n}\n\n// Rabin-Karp Algorithm - O(n + m) average\nfunction rabinKarp(text, pattern) {\n  const BASE = 256;\n  const MOD = 101;\n  const m = pattern.length;\n  const n = text.length;\n  const results = [];\n  \n  if (m > n) return results;\n  \n  // Calculate hash of pattern and first window\n  let patternHash = 0;\n  let textHash = 0;\n  let h = 1;  // BASE^(m-1) % MOD\n  \n  for (let i = 0; i < m - 1; i++) h = (h * BASE) % MOD;\n  \n  for (let i = 0; i < m; i++) {\n    patternHash = (BASE * patternHash + pattern.charCodeAt(i)) % MOD;\n    textHash = (BASE * textHash + text.charCodeAt(i)) % MOD;\n  }\n  \n  // Slide window and compare\n  for (let i = 0; i <= n - m; i++) {\n    if (patternHash === textHash) {\n      // Verify character by character (avoid hash collision)\n      if (text.substring(i, i + m) === pattern) {\n        results.push(i);\n      }\n    }\n    \n    // Calculate hash for next window\n    if (i < n - m) {\n      textHash = (BASE * (textHash - text.charCodeAt(i) * h) + \n                  text.charCodeAt(i + m)) % MOD;\n      if (textHash < 0) textHash += MOD;\n    }\n  }\n  \n  return results;\n}"
  },
  {
    "id": 44,
    "question": "How do you solve the House Robber problem?",
    "answer": "**House Robber**: Maximize amount robbed from houses where you can't rob adjacent houses.\n\n**Recurrence:**\n- At each house, choose: rob it + skip previous, or skip it\n- dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n\n**Variations:**\n\n**House Robber II (circular):**\n- First and last houses are adjacent\n- Run twice: exclude first OR exclude last\n\n**House Robber III (binary tree):**\n- Can't rob parent and child\n- Return [rob, skip] for each node\n\n**Time:** O(n)\n**Space:** O(1) with optimization",
    "example": "// House Robber I - Linear houses\nfunction rob(nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return nums[0];\n  \n  let prev2 = 0;  // dp[i-2]\n  let prev1 = 0;  // dp[i-1]\n  \n  for (const num of nums) {\n    const curr = Math.max(prev1, prev2 + num);\n    prev2 = prev1;\n    prev1 = curr;\n  }\n  \n  return prev1;\n}\n\n// House Robber II - Circular houses\nfunction robCircular(nums) {\n  if (nums.length === 1) return nums[0];\n  \n  // Rob houses [0, n-2] or [1, n-1]\n  return Math.max(\n    robRange(nums, 0, nums.length - 2),\n    robRange(nums, 1, nums.length - 1)\n  );\n}\n\nfunction robRange(nums, start, end) {\n  let prev2 = 0, prev1 = 0;\n  \n  for (let i = start; i <= end; i++) {\n    const curr = Math.max(prev1, prev2 + nums[i]);\n    prev2 = prev1;\n    prev1 = curr;\n  }\n  \n  return prev1;\n}\n\n// House Robber III - Binary Tree\nfunction robTree(root) {\n  const result = dfs(root);\n  return Math.max(result[0], result[1]);\n}\n\nfunction dfs(node) {\n  if (!node) return [0, 0];  // [rob this node, skip this node]\n  \n  const left = dfs(node.left);\n  const right = dfs(node.right);\n  \n  // If we rob this node, we can't rob children\n  const robThis = node.val + left[1] + right[1];\n  \n  // If we skip this node, take max of each child\n  const skipThis = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n  \n  return [robThis, skipThis];\n}\n\n// Paint House - Minimum cost to paint n houses with k colors\n// Adjacent houses can't have same color\nfunction minCostPaint(costs) {\n  if (costs.length === 0) return 0;\n  \n  let prev = costs[0];\n  \n  for (let i = 1; i < costs.length; i++) {\n    const curr = [\n      costs[i][0] + Math.min(prev[1], prev[2]),\n      costs[i][1] + Math.min(prev[0], prev[2]),\n      costs[i][2] + Math.min(prev[0], prev[1])\n    ];\n    prev = curr;\n  }\n  \n  return Math.min(...prev);\n}"
  },
  {
    "id": 45,
    "question": "What are common Palindrome problems and techniques?",
    "answer": "A **Palindrome** reads the same forwards and backwards.\n\n**Common problems:**\n\n**1. Check if palindrome**\n- Two pointers from ends\n- O(n) time, O(1) space\n\n**2. Longest Palindromic Substring**\n- Expand from center (odd and even lengths)\n- O(n²) time\n\n**3. Longest Palindromic Subsequence**\n- DP: LCS of string and its reverse\n- O(n²) time\n\n**4. Palindrome Partitioning**\n- Backtracking to find all ways\n- DP to precompute palindrome checks\n\n**5. Valid Palindrome II**\n- Can it become palindrome by removing one char?\n\n**Manacher's Algorithm**: O(n) for longest palindromic substring",
    "example": "// Check if palindrome\nfunction isPalindrome(s) {\n  let left = 0, right = s.length - 1;\n  while (left < right) {\n    if (s[left] !== s[right]) return false;\n    left++;\n    right--;\n  }\n  return true;\n}\n\n// Longest Palindromic Substring - Expand from center\nfunction longestPalindrome(s) {\n  let start = 0, maxLen = 1;\n  \n  function expandFromCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      left--;\n      right++;\n    }\n    return right - left - 1;  // Length of palindrome\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    const len1 = expandFromCenter(i, i);      // Odd length\n    const len2 = expandFromCenter(i, i + 1);  // Even length\n    const len = Math.max(len1, len2);\n    \n    if (len > maxLen) {\n      maxLen = len;\n      start = i - Math.floor((len - 1) / 2);\n    }\n  }\n  \n  return s.substring(start, start + maxLen);\n}\n\n// Longest Palindromic Subsequence - DP\nfunction longestPalindromeSubseq(s) {\n  const n = s.length;\n  // dp[i][j] = longest palindromic subsequence in s[i..j]\n  const dp = Array(n).fill(null).map(() => Array(n).fill(0));\n  \n  for (let i = n - 1; i >= 0; i--) {\n    dp[i][i] = 1;  // Single char is palindrome\n    for (let j = i + 1; j < n; j++) {\n      if (s[i] === s[j]) {\n        dp[i][j] = dp[i + 1][j - 1] + 2;\n      } else {\n        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n  \n  return dp[0][n - 1];\n}\n\n// Palindrome Partitioning - All ways to partition into palindromes\nfunction partition(s) {\n  const result = [];\n  \n  function backtrack(start, current) {\n    if (start === s.length) {\n      result.push([...current]);\n      return;\n    }\n    \n    for (let end = start; end < s.length; end++) {\n      if (isPalin(s, start, end)) {\n        current.push(s.substring(start, end + 1));\n        backtrack(end + 1, current);\n        current.pop();\n      }\n    }\n  }\n  \n  function isPalin(str, left, right) {\n    while (left < right) {\n      if (str[left++] !== str[right--]) return false;\n    }\n    return true;\n  }\n  \n  backtrack(0, []);\n  return result;\n}\n\n// Valid Palindrome II - Remove at most one char\nfunction validPalindrome(s) {\n  let left = 0, right = s.length - 1;\n  \n  while (left < right) {\n    if (s[left] !== s[right]) {\n      // Try removing left or right char\n      return isPalinRange(s, left + 1, right) || \n             isPalinRange(s, left, right - 1);\n    }\n    left++;\n    right--;\n  }\n  return true;\n}\n\nfunction isPalinRange(s, left, right) {\n  while (left < right) {\n    if (s[left++] !== s[right--]) return false;\n  }\n  return true;\n}"
  },
  {
    "id": 46,
    "question": "How do you solve Stock Buy and Sell problems?",
    "answer": "**Stock problems** maximize profit from buying and selling stocks.\n\n**Variations:**\n\n**1. One transaction**\n- Track minimum price seen so far\n- Calculate profit at each day\n- O(n) time, O(1) space\n\n**2. Unlimited transactions**\n- Add all positive differences\n- Or use state machine: hold vs not hold\n\n**3. At most K transactions**\n- DP with states: day, transactions used, holding\n- O(n × k) time\n\n**4. With cooldown**\n- After selling, must wait one day\n- States: hold, sold, rest\n\n**5. With transaction fee**\n- Subtract fee from profit when selling",
    "example": "// Best Time to Buy and Sell Stock I - One transaction\nfunction maxProfitOne(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  \n  for (const price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n  \n  return maxProfit;\n}\n\n// Best Time II - Unlimited transactions\nfunction maxProfitUnlimited(prices) {\n  let profit = 0;\n  \n  for (let i = 1; i < prices.length; i++) {\n    if (prices[i] > prices[i - 1]) {\n      profit += prices[i] - prices[i - 1];\n    }\n  }\n  \n  return profit;\n}\n\n// Best Time III - At most 2 transactions\nfunction maxProfitTwo(prices) {\n  let buy1 = -Infinity, sell1 = 0;\n  let buy2 = -Infinity, sell2 = 0;\n  \n  for (const price of prices) {\n    buy1 = Math.max(buy1, -price);         // First buy\n    sell1 = Math.max(sell1, buy1 + price); // First sell\n    buy2 = Math.max(buy2, sell1 - price);  // Second buy\n    sell2 = Math.max(sell2, buy2 + price); // Second sell\n  }\n  \n  return sell2;\n}\n\n// Best Time IV - At most K transactions\nfunction maxProfitK(k, prices) {\n  const n = prices.length;\n  if (n === 0 || k === 0) return 0;\n  \n  // If k >= n/2, unlimited transactions\n  if (k >= Math.floor(n / 2)) return maxProfitUnlimited(prices);\n  \n  // dp[t][0] = max profit with t transactions, not holding\n  // dp[t][1] = max profit with t transactions, holding\n  const dp = Array(k + 1).fill(null)\n    .map(() => [-Infinity, -Infinity]);\n  dp[0][0] = 0;\n  \n  for (const price of prices) {\n    for (let t = k; t >= 1; t--) {\n      dp[t][0] = Math.max(dp[t][0], dp[t][1] + price);     // Sell\n      dp[t][1] = Math.max(dp[t][1], dp[t - 1][0] - price); // Buy\n    }\n  }\n  \n  return Math.max(...dp.map(x => x[0]));\n}\n\n// With Cooldown - Must wait after selling\nfunction maxProfitCooldown(prices) {\n  let hold = -Infinity;  // Holding stock\n  let sold = 0;          // Just sold (cooldown next)\n  let rest = 0;          // Not holding, can buy\n  \n  for (const price of prices) {\n    const prevHold = hold;\n    hold = Math.max(hold, rest - price);   // Buy\n    rest = Math.max(rest, sold);           // Continue resting\n    sold = prevHold + price;               // Sell\n  }\n  \n  return Math.max(sold, rest);\n}\n\n// With Transaction Fee\nfunction maxProfitWithFee(prices, fee) {\n  let hold = -prices[0];\n  let notHold = 0;\n  \n  for (let i = 1; i < prices.length; i++) {\n    hold = Math.max(hold, notHold - prices[i]);\n    notHold = Math.max(notHold, hold + prices[i] - fee);\n  }\n  \n  return notHold;\n}"
  },
  {
    "id": 47,
    "question": "How do you count Number of Islands?",
    "answer": "**Number of Islands** counts connected components of '1's in a grid where connections are horizontal/vertical.\n\n**Approaches:**\n\n**1. DFS Flood Fill**\n- For each unvisited '1', increment count and flood fill\n- Mark all connected '1's as visited\n- O(m × n) time\n\n**2. BFS**\n- Same idea, use queue instead\n- Better for very deep recursion cases\n\n**3. Union-Find**\n- Union adjacent '1's\n- Count unique parents\n- Good for dynamic connectivity\n\n**Related problems:**\n- Max area of island\n- Number of distinct islands\n- Surrounded regions",
    "example": "// Number of Islands - DFS\nfunction numIslands(grid) {\n  if (!grid.length) return 0;\n  \n  const rows = grid.length;\n  const cols = grid[0].length;\n  let count = 0;\n  \n  function dfs(r, c) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    if (grid[r][c] !== '1') return;\n    \n    grid[r][c] = '0';  // Mark visited\n    \n    dfs(r + 1, c);\n    dfs(r - 1, c);\n    dfs(r, c + 1);\n    dfs(r, c - 1);\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        count++;\n        dfs(r, c);\n      }\n    }\n  }\n  \n  return count;\n}\n\n// Max Area of Island\nfunction maxAreaOfIsland(grid) {\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let maxArea = 0;\n  \n  function dfs(r, c) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return 0;\n    if (grid[r][c] !== 1) return 0;\n    \n    grid[r][c] = 0;\n    return 1 + dfs(r + 1, c) + dfs(r - 1, c) + \n               dfs(r, c + 1) + dfs(r, c - 1);\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === 1) {\n        maxArea = Math.max(maxArea, dfs(r, c));\n      }\n    }\n  }\n  \n  return maxArea;\n}\n\n// Surrounded Regions - Capture 'O's not on border\nfunction solve(board) {\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  // Mark 'O's connected to border as safe\n  function markSafe(r, c) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    if (board[r][c] !== 'O') return;\n    \n    board[r][c] = 'S';  // Safe\n    markSafe(r + 1, c);\n    markSafe(r - 1, c);\n    markSafe(r, c + 1);\n    markSafe(r, c - 1);\n  }\n  \n  // Mark border-connected O's as safe\n  for (let r = 0; r < rows; r++) {\n    markSafe(r, 0);\n    markSafe(r, cols - 1);\n  }\n  for (let c = 0; c < cols; c++) {\n    markSafe(0, c);\n    markSafe(rows - 1, c);\n  }\n  \n  // Capture remaining O's, restore safe ones\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (board[r][c] === 'O') board[r][c] = 'X';\n      if (board[r][c] === 'S') board[r][c] = 'O';\n    }\n  }\n}\n\n// Number of Islands using Union-Find\nfunction numIslandsUF(grid) {\n  const rows = grid.length, cols = grid[0].length;\n  const parent = [];\n  let count = 0;\n  \n  const getIdx = (r, c) => r * cols + c;\n  \n  const find = (x) => {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  };\n  \n  const union = (x, y) => {\n    const px = find(x), py = find(y);\n    if (px !== py) {\n      parent[px] = py;\n      count--;\n    }\n  };\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      const idx = getIdx(r, c);\n      if (grid[r][c] === '1') {\n        parent[idx] = idx;\n        count++;\n      }\n    }\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        if (r + 1 < rows && grid[r + 1][c] === '1') union(getIdx(r, c), getIdx(r + 1, c));\n        if (c + 1 < cols && grid[r][c + 1] === '1') union(getIdx(r, c), getIdx(r, c + 1));\n      }\n    }\n  }\n  \n  return count;\n}"
  },
  {
    "id": 48,
    "question": "How do you validate a Binary Search Tree?",
    "answer": "**Validate BST** checks if a binary tree satisfies BST property: left < root < right for all nodes.\n\n**Approaches:**\n\n**1. Range validation (recursive)**\n- Pass valid range [min, max] to each node\n- Node must be within its range\n- Update range as we go down\n\n**2. In-order traversal**\n- In-order of BST is strictly increasing\n- Track previous value, ensure current > previous\n\n**Common mistake:**\n- Only checking node vs immediate children\n- Must check against all ancestors\n\n**Time:** O(n)\n**Space:** O(h) for recursion",
    "example": "// Validate BST - Range validation\nfunction isValidBST(root) {\n  function validate(node, min, max) {\n    if (!node) return true;\n    \n    if (node.val <= min || node.val >= max) return false;\n    \n    return validate(node.left, min, node.val) &&\n           validate(node.right, node.val, max);\n  }\n  \n  return validate(root, -Infinity, Infinity);\n}\n\n// Validate BST - In-order traversal\nfunction isValidBSTInorder(root) {\n  let prev = -Infinity;\n  \n  function inorder(node) {\n    if (!node) return true;\n    \n    if (!inorder(node.left)) return false;\n    \n    if (node.val <= prev) return false;\n    prev = node.val;\n    \n    return inorder(node.right);\n  }\n  \n  return inorder(root);\n}\n\n// Iterative in-order with stack\nfunction isValidBSTIterative(root) {\n  const stack = [];\n  let prev = -Infinity;\n  let curr = root;\n  \n  while (curr || stack.length) {\n    while (curr) {\n      stack.push(curr);\n      curr = curr.left;\n    }\n    \n    curr = stack.pop();\n    if (curr.val <= prev) return false;\n    prev = curr.val;\n    curr = curr.right;\n  }\n  \n  return true;\n}\n\n// Recover BST - Two nodes are swapped, fix it\nfunction recoverTree(root) {\n  let first = null, second = null;\n  let prev = null;\n  \n  function inorder(node) {\n    if (!node) return;\n    \n    inorder(node.left);\n    \n    if (prev && prev.val > node.val) {\n      if (!first) first = prev;  // First violation\n      second = node;             // Second is always current\n    }\n    prev = node;\n    \n    inorder(node.right);\n  }\n  \n  inorder(root);\n  \n  // Swap values\n  [first.val, second.val] = [second.val, first.val];\n}\n\n// Convert Sorted Array to Balanced BST\nfunction sortedArrayToBST(nums) {\n  function build(left, right) {\n    if (left > right) return null;\n    \n    const mid = Math.floor((left + right) / 2);\n    const node = { val: nums[mid], left: null, right: null };\n    \n    node.left = build(left, mid - 1);\n    node.right = build(mid + 1, right);\n    \n    return node;\n  }\n  \n  return build(0, nums.length - 1);\n}"
  },
  {
    "id": 49,
    "question": "How do you merge K Sorted Lists?",
    "answer": "**Merge K Sorted Lists** combines k sorted linked lists into one sorted list.\n\n**Approaches:**\n\n**1. Min-Heap (Priority Queue)**\n- Add first node of each list to heap\n- Extract min, add its next to heap\n- O(n log k) time, O(k) space\n\n**2. Divide and Conquer**\n- Pair up lists and merge\n- Like merge sort on lists\n- O(n log k) time, O(1) space\n\n**3. Merge one by one**\n- Merge list 1 with list 2, result with list 3, etc.\n- O(nk) time - less efficient\n\n**Key insight:**\n- Heap keeps track of k candidates\n- Always get minimum in O(log k)",
    "example": "// Merge K Sorted Lists - Min Heap approach\nfunction mergeKLists(lists) {\n  // Simple min-heap implementation for demo\n  class MinHeap {\n    constructor() { this.heap = []; }\n    \n    push(node) {\n      this.heap.push(node);\n      this.bubbleUp(this.heap.length - 1);\n    }\n    \n    pop() {\n      if (this.heap.length === 0) return null;\n      const min = this.heap[0];\n      const last = this.heap.pop();\n      if (this.heap.length > 0) {\n        this.heap[0] = last;\n        this.bubbleDown(0);\n      }\n      return min;\n    }\n    \n    bubbleUp(i) {\n      while (i > 0) {\n        const parent = Math.floor((i - 1) / 2);\n        if (this.heap[parent].val <= this.heap[i].val) break;\n        [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];\n        i = parent;\n      }\n    }\n    \n    bubbleDown(i) {\n      while (true) {\n        let smallest = i;\n        const left = 2 * i + 1, right = 2 * i + 2;\n        if (left < this.heap.length && this.heap[left].val < this.heap[smallest].val) smallest = left;\n        if (right < this.heap.length && this.heap[right].val < this.heap[smallest].val) smallest = right;\n        if (smallest === i) break;\n        [this.heap[smallest], this.heap[i]] = [this.heap[i], this.heap[smallest]];\n        i = smallest;\n      }\n    }\n    \n    isEmpty() { return this.heap.length === 0; }\n  }\n  \n  const heap = new MinHeap();\n  \n  // Add first node of each list\n  for (const list of lists) {\n    if (list) heap.push(list);\n  }\n  \n  const dummy = { next: null };\n  let curr = dummy;\n  \n  while (!heap.isEmpty()) {\n    const node = heap.pop();\n    curr.next = node;\n    curr = curr.next;\n    \n    if (node.next) heap.push(node.next);\n  }\n  \n  return dummy.next;\n}\n\n// Merge K Sorted Lists - Divide and Conquer\nfunction mergeKListsDC(lists) {\n  if (lists.length === 0) return null;\n  \n  function mergeTwoLists(l1, l2) {\n    const dummy = { next: null };\n    let curr = dummy;\n    \n    while (l1 && l2) {\n      if (l1.val < l2.val) {\n        curr.next = l1;\n        l1 = l1.next;\n      } else {\n        curr.next = l2;\n        l2 = l2.next;\n      }\n      curr = curr.next;\n    }\n    \n    curr.next = l1 || l2;\n    return dummy.next;\n  }\n  \n  // Divide and conquer\n  while (lists.length > 1) {\n    const merged = [];\n    for (let i = 0; i < lists.length; i += 2) {\n      const l1 = lists[i];\n      const l2 = i + 1 < lists.length ? lists[i + 1] : null;\n      merged.push(mergeTwoLists(l1, l2));\n    }\n    lists = merged;\n  }\n  \n  return lists[0];\n}"
  },
  {
    "id": 50,
    "question": "What is a Segment Tree?",
    "answer": "A **Segment Tree** is a binary tree for storing intervals/segments, enabling efficient range queries and updates.\n\n**Operations:**\n- **Build**: O(n)\n- **Query** (range sum/min/max): O(log n)\n- **Update** (point update): O(log n)\n- **Range update** (lazy propagation): O(log n)\n\n**Structure:**\n- Leaves store array elements\n- Internal nodes store aggregate of children\n- Usually stored in array: children of i at 2i+1, 2i+2\n\n**Use cases:**\n- Range sum queries\n- Range min/max queries\n- Range updates (lazy propagation)\n- Counting inversions\n\n**Space:** O(4n) ≈ O(n)",
    "example": "// Segment Tree for Range Sum Query with Point Update\nclass SegmentTree {\n  constructor(nums) {\n    this.n = nums.length;\n    this.tree = new Array(4 * this.n).fill(0);\n    if (this.n > 0) this.build(nums, 0, 0, this.n - 1);\n  }\n\n  // Build the tree\n  build(nums, node, start, end) {\n    if (start === end) {\n      this.tree[node] = nums[start];\n      return;\n    }\n    \n    const mid = Math.floor((start + end) / 2);\n    this.build(nums, 2 * node + 1, start, mid);\n    this.build(nums, 2 * node + 2, mid + 1, end);\n    this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n  }\n\n  // Point update\n  update(idx, val, node = 0, start = 0, end = this.n - 1) {\n    if (start === end) {\n      this.tree[node] = val;\n      return;\n    }\n    \n    const mid = Math.floor((start + end) / 2);\n    if (idx <= mid) {\n      this.update(idx, val, 2 * node + 1, start, mid);\n    } else {\n      this.update(idx, val, 2 * node + 2, mid + 1, end);\n    }\n    this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n  }\n\n  // Range query [l, r]\n  query(l, r, node = 0, start = 0, end = this.n - 1) {\n    if (r < start || l > end) return 0;  // Out of range\n    if (l <= start && end <= r) return this.tree[node];  // Fully in range\n    \n    const mid = Math.floor((start + end) / 2);\n    return this.query(l, r, 2 * node + 1, start, mid) +\n           this.query(l, r, 2 * node + 2, mid + 1, end);\n  }\n}\n\n// Segment Tree for Range Minimum Query\nclass MinSegmentTree {\n  constructor(nums) {\n    this.n = nums.length;\n    this.tree = new Array(4 * this.n).fill(Infinity);\n    if (this.n > 0) this.build(nums, 0, 0, this.n - 1);\n  }\n\n  build(nums, node, start, end) {\n    if (start === end) {\n      this.tree[node] = nums[start];\n      return;\n    }\n    const mid = Math.floor((start + end) / 2);\n    this.build(nums, 2 * node + 1, start, mid);\n    this.build(nums, 2 * node + 2, mid + 1, end);\n    this.tree[node] = Math.min(this.tree[2 * node + 1], this.tree[2 * node + 2]);\n  }\n\n  query(l, r, node = 0, start = 0, end = this.n - 1) {\n    if (r < start || l > end) return Infinity;\n    if (l <= start && end <= r) return this.tree[node];\n    const mid = Math.floor((start + end) / 2);\n    return Math.min(\n      this.query(l, r, 2 * node + 1, start, mid),\n      this.query(l, r, 2 * node + 2, mid + 1, end)\n    );\n  }\n}\n\n// Usage\nconst nums = [1, 3, 5, 7, 9, 11];\nconst st = new SegmentTree(nums);\nconsole.log(st.query(1, 3));  // Sum of [3, 5, 7] = 15\nst.update(1, 10);              // Change 3 to 10\nconsole.log(st.query(1, 3));  // Sum of [10, 5, 7] = 22"
  },
  {
    "id": 51,
    "question": "What is a Binary Indexed Tree (Fenwick Tree)?",
    "answer": "A **Binary Indexed Tree (BIT)** is a data structure for efficient prefix sum queries and point updates.\n\n**Operations:**\n- **Update** (add value at index): O(log n)\n- **Prefix Sum** (sum from 0 to i): O(log n)\n- **Range Sum**: Prefix(r) - Prefix(l-1)\n\n**Key insight:**\n- Uses binary representation of indices\n- Each index stores sum of a range based on lowest set bit\n- `i & (-i)` gives the lowest set bit\n\n**Compared to Segment Tree:**\n- Simpler to implement\n- Less memory (n vs 4n)\n- Only for associative operations with inverse (like sum)\n- Can't do range min/max directly\n\n**Space:** O(n)",
    "example": "// Binary Indexed Tree (Fenwick Tree)\nclass BIT {\n  constructor(n) {\n    this.n = n;\n    this.tree = new Array(n + 1).fill(0);  // 1-indexed\n  }\n\n  // Add delta to index i (1-indexed)\n  update(i, delta) {\n    while (i <= this.n) {\n      this.tree[i] += delta;\n      i += i & (-i);  // Add lowest set bit\n    }\n  }\n\n  // Get prefix sum [1, i] (1-indexed)\n  prefixSum(i) {\n    let sum = 0;\n    while (i > 0) {\n      sum += this.tree[i];\n      i -= i & (-i);  // Remove lowest set bit\n    }\n    return sum;\n  }\n\n  // Range sum [l, r] (1-indexed)\n  rangeSum(l, r) {\n    return this.prefixSum(r) - this.prefixSum(l - 1);\n  }\n}\n\n// Build from array\nfunction buildBIT(nums) {\n  const bit = new BIT(nums.length);\n  for (let i = 0; i < nums.length; i++) {\n    bit.update(i + 1, nums[i]);  // BIT is 1-indexed\n  }\n  return bit;\n}\n\n// Count Inversions using BIT\nfunction countInversions(nums) {\n  // Coordinate compression\n  const sorted = [...new Set(nums)].sort((a, b) => a - b);\n  const rank = new Map();\n  sorted.forEach((v, i) => rank.set(v, i + 1));\n  \n  const bit = new BIT(sorted.length);\n  let inversions = 0;\n  \n  // Process from right to left\n  for (let i = nums.length - 1; i >= 0; i--) {\n    const r = rank.get(nums[i]);\n    inversions += bit.prefixSum(r - 1);  // Count smaller elements to right\n    bit.update(r, 1);\n  }\n  \n  return inversions;\n}\n\n// Range Update, Point Query BIT\nclass BITRangeUpdate {\n  constructor(n) {\n    this.n = n;\n    this.tree = new Array(n + 1).fill(0);\n  }\n\n  // Add delta to range [l, r]\n  rangeUpdate(l, r, delta) {\n    this.update(l, delta);\n    this.update(r + 1, -delta);\n  }\n\n  update(i, delta) {\n    while (i <= this.n) {\n      this.tree[i] += delta;\n      i += i & (-i);\n    }\n  }\n\n  // Get value at index i\n  pointQuery(i) {\n    let sum = 0;\n    while (i > 0) {\n      sum += this.tree[i];\n      i -= i & (-i);\n    }\n    return sum;\n  }\n}"
  },
  {
    "id": 52,
    "question": "How do you solve the Decode Ways problem?",
    "answer": "**Decode Ways** counts how many ways to decode a digit string where A=1, B=2, ..., Z=26.\n\n**Approach: Dynamic Programming**\n- dp[i] = number of ways to decode first i characters\n- For each position, check:\n  - Single digit (1-9): Add dp[i-1]\n  - Two digits (10-26): Add dp[i-2]\n\n**Edge cases:**\n- '0' alone is invalid\n- '06' is invalid (leading zero)\n- Empty string returns 0\n\n**Time:** O(n)\n**Space:** O(1) with optimization\n\n**Similar problems:**\n- Climbing stairs\n- Fibonacci variations",
    "example": "// Decode Ways - O(n) time, O(1) space\nfunction numDecodings(s) {\n  if (!s || s[0] === '0') return 0;\n  \n  let prev2 = 1;  // dp[i-2] - empty string\n  let prev1 = 1;  // dp[i-1] - first character\n  \n  for (let i = 1; i < s.length; i++) {\n    let curr = 0;\n    \n    // Single digit (1-9)\n    if (s[i] !== '0') {\n      curr += prev1;\n    }\n    \n    // Two digits (10-26)\n    const twoDigit = parseInt(s.substring(i - 1, i + 1));\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      curr += prev2;\n    }\n    \n    prev2 = prev1;\n    prev1 = curr;\n  }\n  \n  return prev1;\n}\n\n// With explicit DP array for clarity\nfunction numDecodingsDP(s) {\n  if (!s || s[0] === '0') return 0;\n  \n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1;  // Empty string\n  dp[1] = 1;  // First character (already checked not '0')\n  \n  for (let i = 2; i <= n; i++) {\n    // Single digit\n    if (s[i - 1] !== '0') {\n      dp[i] += dp[i - 1];\n    }\n    \n    // Two digits\n    const twoDigit = parseInt(s.substring(i - 2, i));\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n  \n  return dp[n];\n}\n\n// Decode Ways II - With '*' wildcard\nfunction numDecodingsWildcard(s) {\n  const MOD = 1e9 + 7;\n  let prev2 = 1n;\n  let prev1 = s[0] === '*' ? 9n : s[0] === '0' ? 0n : 1n;\n  \n  for (let i = 1; i < s.length; i++) {\n    let curr = 0n;\n    \n    // Single digit\n    if (s[i] === '*') {\n      curr += prev1 * 9n;  // 1-9\n    } else if (s[i] !== '0') {\n      curr += prev1;\n    }\n    \n    // Two digits\n    if (s[i - 1] === '*') {\n      if (s[i] === '*') {\n        curr += prev2 * 15n;  // 11-19, 21-26\n      } else if (s[i] <= '6') {\n        curr += prev2 * 2n;   // 1X or 2X\n      } else {\n        curr += prev2;        // Only 1X\n      }\n    } else if (s[i - 1] === '1') {\n      curr += prev2 * (s[i] === '*' ? 9n : 1n);\n    } else if (s[i - 1] === '2') {\n      if (s[i] === '*') {\n        curr += prev2 * 6n;   // 21-26\n      } else if (s[i] <= '6') {\n        curr += prev2;\n      }\n    }\n    \n    prev2 = prev1;\n    prev1 = curr % BigInt(MOD);\n  }\n  \n  return Number(prev1);\n}"
  },
  {
    "id": 53,
    "question": "How do you solve the Word Break problem?",
    "answer": "**Word Break** determines if a string can be segmented into space-separated dictionary words.\n\n**Approach: Dynamic Programming**\n- dp[i] = true if s[0..i-1] can be segmented\n- For each position, check all possible word endings\n- dp[i] = dp[j] && s[j..i] is in dictionary (for any j)\n\n**Optimizations:**\n- Use Set for O(1) dictionary lookup\n- Only check words up to max word length\n- Use Trie for Word Break II\n\n**Time:** O(n² × k) where k = max word length\n**Space:** O(n)\n\n**Variations:**\n- Word Break II: Return all possible sentences",
    "example": "// Word Break - DP solution\nfunction wordBreak(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const n = s.length;\n  \n  // dp[i] = can we segment s[0..i-1]?\n  const dp = new Array(n + 1).fill(false);\n  dp[0] = true;  // Empty string\n  \n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  \n  return dp[n];\n}\n\n// Optimized with max word length\nfunction wordBreakOptimized(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const maxLen = Math.max(...wordDict.map(w => w.length));\n  const n = s.length;\n  const dp = new Array(n + 1).fill(false);\n  dp[0] = true;\n  \n  for (let i = 1; i <= n; i++) {\n    // Only check words up to maxLen\n    for (let j = Math.max(0, i - maxLen); j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  \n  return dp[n];\n}\n\n// Word Break II - Return all valid sentences\nfunction wordBreakII(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const memo = new Map();\n  \n  function backtrack(start) {\n    if (memo.has(start)) return memo.get(start);\n    if (start === s.length) return [''];\n    \n    const results = [];\n    \n    for (let end = start + 1; end <= s.length; end++) {\n      const word = s.substring(start, end);\n      if (wordSet.has(word)) {\n        const subResults = backtrack(end);\n        for (const sub of subResults) {\n          results.push(sub ? word + ' ' + sub : word);\n        }\n      }\n    }\n    \n    memo.set(start, results);\n    return results;\n  }\n  \n  return backtrack(0);\n}\n\n// BFS approach\nfunction wordBreakBFS(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const visited = new Set();\n  const queue = [0];\n  \n  while (queue.length) {\n    const start = queue.shift();\n    if (visited.has(start)) continue;\n    visited.add(start);\n    \n    for (let end = start + 1; end <= s.length; end++) {\n      if (wordSet.has(s.substring(start, end))) {\n        if (end === s.length) return true;\n        queue.push(end);\n      }\n    }\n  }\n  \n  return false;\n}"
  },
  {
    "id": 54,
    "question": "How do you solve Trapping Rain Water?",
    "answer": "**Trapping Rain Water** calculates how much water can be trapped after raining.\n\n**Key insight:**\n- Water at position i = min(maxLeft, maxRight) - height[i]\n- Water level is determined by the shorter of two sides\n\n**Approaches:**\n\n**1. Precompute arrays**\n- Calculate maxLeft and maxRight for each position\n- O(n) time, O(n) space\n\n**2. Two pointers**\n- Process from both ends\n- Move pointer with smaller max height\n- O(n) time, O(1) space\n\n**3. Monotonic stack**\n- Track decreasing heights\n- Calculate water when we find a taller bar\n- O(n) time, O(n) space",
    "example": "// Trapping Rain Water - Two Pointers (Optimal)\nfunction trap(height) {\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0;\n  let water = 0;\n  \n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        water += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        water += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  \n  return water;\n}\n\n// Precompute approach - O(n) time, O(n) space\nfunction trapPrecompute(height) {\n  const n = height.length;\n  if (n === 0) return 0;\n  \n  // Precompute max heights\n  const leftMax = new Array(n);\n  const rightMax = new Array(n);\n  \n  leftMax[0] = height[0];\n  for (let i = 1; i < n; i++) {\n    leftMax[i] = Math.max(leftMax[i - 1], height[i]);\n  }\n  \n  rightMax[n - 1] = height[n - 1];\n  for (let i = n - 2; i >= 0; i--) {\n    rightMax[i] = Math.max(rightMax[i + 1], height[i]);\n  }\n  \n  let water = 0;\n  for (let i = 0; i < n; i++) {\n    water += Math.min(leftMax[i], rightMax[i]) - height[i];\n  }\n  \n  return water;\n}\n\n// Monotonic Stack approach\nfunction trapStack(height) {\n  const stack = [];  // Indices of decreasing heights\n  let water = 0;\n  \n  for (let i = 0; i < height.length; i++) {\n    while (stack.length && height[i] > height[stack[stack.length - 1]]) {\n      const bottom = stack.pop();\n      \n      if (stack.length === 0) break;\n      \n      const left = stack[stack.length - 1];\n      const width = i - left - 1;\n      const boundedHeight = Math.min(height[left], height[i]) - height[bottom];\n      \n      water += width * boundedHeight;\n    }\n    stack.push(i);\n  }\n  \n  return water;\n}\n\n// Trapping Rain Water II (3D) - Min Heap approach\nfunction trapRainWater3D(heightMap) {\n  const rows = heightMap.length, cols = heightMap[0].length;\n  const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));\n  const heap = [];  // [height, row, col]\n  \n  // Add border cells\n  for (let r = 0; r < rows; r++) {\n    heap.push([heightMap[r][0], r, 0]);\n    heap.push([heightMap[r][cols - 1], r, cols - 1]);\n    visited[r][0] = visited[r][cols - 1] = true;\n  }\n  for (let c = 1; c < cols - 1; c++) {\n    heap.push([heightMap[0][c], 0, c]);\n    heap.push([heightMap[rows - 1][c], rows - 1, c]);\n    visited[0][c] = visited[rows - 1][c] = true;\n  }\n  \n  // Min-heapify (simplified - use proper heap in production)\n  heap.sort((a, b) => a[0] - b[0]);\n  \n  let water = 0;\n  const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  \n  while (heap.length) {\n    const [h, r, c] = heap.shift();\n    \n    for (const [dr, dc] of dirs) {\n      const nr = r + dr, nc = c + dc;\n      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\n        visited[nr][nc] = true;\n        water += Math.max(0, h - heightMap[nr][nc]);\n        heap.push([Math.max(h, heightMap[nr][nc]), nr, nc]);\n        heap.sort((a, b) => a[0] - b[0]);\n      }\n    }\n  }\n  \n  return water;\n}"
  },
  {
    "id": 55,
    "question": "How do you find the Median in a Data Stream?",
    "answer": "**Find Median** from a continuously growing data stream.\n\n**Approach: Two Heaps**\n- Max-heap for lower half\n- Min-heap for upper half\n- Keep heaps balanced (size difference ≤ 1)\n\n**Operations:**\n- **Add number**: O(log n)\n- **Get median**: O(1)\n\n**Balancing rules:**\n- If sizes equal, median = average of both tops\n- If unequal, median = top of larger heap\n\n**Alternative approaches:**\n- Sorted array: O(n) insert, O(1) median\n- BST: O(log n) operations but complex\n- Bucket sort: For limited range",
    "example": "// MedianFinder using Two Heaps\nclass MedianFinder {\n  constructor() {\n    this.maxHeap = [];  // Lower half (stores negatives for max behavior)\n    this.minHeap = [];  // Upper half\n  }\n\n  // Helper for max-heap (using negative values)\n  addToMaxHeap(val) {\n    this.maxHeap.push(-val);\n    this.bubbleUp(this.maxHeap);\n  }\n\n  addToMinHeap(val) {\n    this.minHeap.push(val);\n    this.bubbleUp(this.minHeap);\n  }\n\n  bubbleUp(heap) {\n    let i = heap.length - 1;\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (heap[parent] <= heap[i]) break;\n      [heap[parent], heap[i]] = [heap[i], heap[parent]];\n      i = parent;\n    }\n  }\n\n  extractMin(heap) {\n    const min = heap[0];\n    const last = heap.pop();\n    if (heap.length > 0) {\n      heap[0] = last;\n      let i = 0;\n      while (true) {\n        let smallest = i;\n        const left = 2 * i + 1, right = 2 * i + 2;\n        if (left < heap.length && heap[left] < heap[smallest]) smallest = left;\n        if (right < heap.length && heap[right] < heap[smallest]) smallest = right;\n        if (smallest === i) break;\n        [heap[smallest], heap[i]] = [heap[i], heap[smallest]];\n        i = smallest;\n      }\n    }\n    return min;\n  }\n\n  addNum(num) {\n    // Add to appropriate heap\n    if (this.maxHeap.length === 0 || num <= -this.maxHeap[0]) {\n      this.addToMaxHeap(num);\n    } else {\n      this.addToMinHeap(num);\n    }\n\n    // Balance heaps (maxHeap can have at most 1 more)\n    if (this.maxHeap.length > this.minHeap.length + 1) {\n      const val = -this.extractMin(this.maxHeap);\n      this.addToMinHeap(val);\n    } else if (this.minHeap.length > this.maxHeap.length) {\n      const val = this.extractMin(this.minHeap);\n      this.addToMaxHeap(val);\n    }\n  }\n\n  findMedian() {\n    if (this.maxHeap.length > this.minHeap.length) {\n      return -this.maxHeap[0];\n    }\n    return (-this.maxHeap[0] + this.minHeap[0]) / 2;\n  }\n}\n\n// Usage\nconst mf = new MedianFinder();\nmf.addNum(1);  // [1]\nmf.addNum(2);  // [1, 2]\nconsole.log(mf.findMedian());  // 1.5\nmf.addNum(3);  // [1, 2, 3]\nconsole.log(mf.findMedian());  // 2\n\n// Sliding Window Median (harder variation)\nfunction medianSlidingWindow(nums, k) {\n  // Would use two balanced BSTs or sorted arrays\n  // Simplified version using sorted insertion\n  const result = [];\n  const window = [];\n  \n  const insert = (arr, val) => {\n    let lo = 0, hi = arr.length;\n    while (lo < hi) {\n      const mid = Math.floor((lo + hi) / 2);\n      if (arr[mid] < val) lo = mid + 1;\n      else hi = mid;\n    }\n    arr.splice(lo, 0, val);\n  };\n  \n  const remove = (arr, val) => {\n    const idx = arr.indexOf(val);\n    arr.splice(idx, 1);\n  };\n  \n  for (let i = 0; i < nums.length; i++) {\n    insert(window, nums[i]);\n    if (i >= k) remove(window, nums[i - k]);\n    if (i >= k - 1) {\n      const mid = Math.floor(k / 2);\n      result.push(k % 2 ? window[mid] : (window[mid - 1] + window[mid]) / 2);\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 56,
    "question": "How do you solve the Alien Dictionary problem?",
    "answer": "**Alien Dictionary** derives the character order from sorted alien words.\n\n**Approach: Topological Sort**\n1. Build a graph from adjacent word pairs\n2. Compare adjacent words, first differing char gives an edge\n3. Topological sort the graph\n\n**Edge cases:**\n- Invalid input: longer word before shorter prefix (e.g., \"abc\" before \"ab\")\n- Cycle in graph: no valid ordering\n- Characters not appearing in any edge\n\n**Time:** O(total chars)\n**Space:** O(unique chars)",
    "example": "// Alien Dictionary - Topological Sort\nfunction alienOrder(words) {\n  // Build adjacency list and in-degree count\n  const adj = new Map();\n  const inDegree = new Map();\n  \n  // Initialize all characters\n  for (const word of words) {\n    for (const char of word) {\n      if (!adj.has(char)) {\n        adj.set(char, new Set());\n        inDegree.set(char, 0);\n      }\n    }\n  }\n  \n  // Build edges from adjacent word pairs\n  for (let i = 0; i < words.length - 1; i++) {\n    const word1 = words[i];\n    const word2 = words[i + 1];\n    \n    // Invalid: longer word comes before its prefix\n    if (word1.length > word2.length && word1.startsWith(word2)) {\n      return '';\n    }\n    \n    // Find first differing character\n    for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n      if (word1[j] !== word2[j]) {\n        if (!adj.get(word1[j]).has(word2[j])) {\n          adj.get(word1[j]).add(word2[j]);\n          inDegree.set(word2[j], inDegree.get(word2[j]) + 1);\n        }\n        break;\n      }\n    }\n  }\n  \n  // Topological sort using BFS (Kahn's algorithm)\n  const queue = [];\n  for (const [char, degree] of inDegree) {\n    if (degree === 0) queue.push(char);\n  }\n  \n  const result = [];\n  while (queue.length) {\n    const char = queue.shift();\n    result.push(char);\n    \n    for (const neighbor of adj.get(char)) {\n      inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n      if (inDegree.get(neighbor) === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n  \n  // Check for cycle\n  if (result.length !== adj.size) return '';\n  \n  return result.join('');\n}\n\n// Verify Alien Dictionary - Check if words are sorted\nfunction isAlienSorted(words, order) {\n  const orderMap = new Map();\n  for (let i = 0; i < order.length; i++) {\n    orderMap.set(order[i], i);\n  }\n  \n  for (let i = 0; i < words.length - 1; i++) {\n    const word1 = words[i];\n    const word2 = words[i + 1];\n    \n    let found = false;\n    for (let j = 0; j < Math.min(word1.length, word2.length); j++) {\n      if (word1[j] !== word2[j]) {\n        if (orderMap.get(word1[j]) > orderMap.get(word2[j])) {\n          return false;\n        }\n        found = true;\n        break;\n      }\n    }\n    \n    // word1 is prefix of word2 but longer\n    if (!found && word1.length > word2.length) {\n      return false;\n    }\n  }\n  \n  return true;\n}"
  },
  {
    "id": 57,
    "question": "How do you implement a Basic Calculator?",
    "answer": "**Basic Calculator** evaluates mathematical expressions with +, -, (, ).\n\n**Approach: Stack**\n- Track current number, result, and sign\n- Use stack to handle parentheses\n- Push result and sign when opening paren\n- Pop and combine when closing paren\n\n**Variations:**\n- Calculator II: +, -, *, / (no parens)\n- Calculator III: All operations with parens\n\n**Time:** O(n)\n**Space:** O(n) for nested parentheses",
    "example": "// Basic Calculator I: +, -, (, )\nfunction calculate(s) {\n  const stack = [];\n  let result = 0;\n  let num = 0;\n  let sign = 1;  // 1 for +, -1 for -\n  \n  for (const char of s) {\n    if (char >= '0' && char <= '9') {\n      num = num * 10 + parseInt(char);\n    } else if (char === '+') {\n      result += sign * num;\n      num = 0;\n      sign = 1;\n    } else if (char === '-') {\n      result += sign * num;\n      num = 0;\n      sign = -1;\n    } else if (char === '(') {\n      // Push current result and sign\n      stack.push(result);\n      stack.push(sign);\n      result = 0;\n      sign = 1;\n    } else if (char === ')') {\n      result += sign * num;\n      num = 0;\n      // Pop sign and previous result\n      result *= stack.pop();  // sign\n      result += stack.pop();  // previous result\n    }\n  }\n  \n  return result + sign * num;\n}\n\n// Basic Calculator II: +, -, *, / (no parens)\nfunction calculateII(s) {\n  const stack = [];\n  let num = 0;\n  let prevOp = '+';\n  \n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    \n    if (char >= '0' && char <= '9') {\n      num = num * 10 + parseInt(char);\n    }\n    \n    if ((char !== ' ' && isNaN(char)) || i === s.length - 1) {\n      if (prevOp === '+') stack.push(num);\n      else if (prevOp === '-') stack.push(-num);\n      else if (prevOp === '*') stack.push(stack.pop() * num);\n      else if (prevOp === '/') stack.push(Math.trunc(stack.pop() / num));\n      \n      prevOp = char;\n      num = 0;\n    }\n  }\n  \n  return stack.reduce((a, b) => a + b, 0);\n}\n\n// Basic Calculator III: All operations with parens\nfunction calculateIII(s) {\n  let i = 0;\n  \n  function parse() {\n    const stack = [];\n    let num = 0;\n    let prevOp = '+';\n    \n    while (i < s.length) {\n      const char = s[i];\n      \n      if (char >= '0' && char <= '9') {\n        num = num * 10 + parseInt(char);\n      } else if (char === '(') {\n        i++;  // Skip '('\n        num = parse();  // Recursively parse\n      }\n      \n      if ('+-*/'.includes(char) || char === ')' || i === s.length - 1) {\n        if (prevOp === '+') stack.push(num);\n        else if (prevOp === '-') stack.push(-num);\n        else if (prevOp === '*') stack.push(stack.pop() * num);\n        else if (prevOp === '/') stack.push(Math.trunc(stack.pop() / num));\n        \n        if (char === ')') {\n          i++;  // Skip ')'\n          return stack.reduce((a, b) => a + b, 0);\n        }\n        \n        prevOp = char;\n        num = 0;\n      }\n      \n      i++;\n    }\n    \n    return stack.reduce((a, b) => a + b, 0);\n  }\n  \n  return parse();\n}"
  },
  {
    "id": 58,
    "question": "How do you validate Parentheses / Balanced Brackets?",
    "answer": "**Valid Parentheses** checks if brackets are properly opened and closed.\n\n**Approach: Stack**\n- Push opening brackets\n- Pop and match for closing brackets\n- Valid if stack empty at end\n\n**Variations:**\n- Minimum add to make valid\n- Longest valid parentheses\n- Remove invalid parentheses\n- Generate all valid combinations\n\n**Time:** O(n)\n**Space:** O(n) worst case",
    "example": "// Valid Parentheses - Basic\nfunction isValid(s) {\n  const stack = [];\n  const pairs = { ')': '(', ']': '[', '}': '{' };\n  \n  for (const char of s) {\n    if (char === '(' || char === '[' || char === '{') {\n      stack.push(char);\n    } else {\n      if (stack.pop() !== pairs[char]) return false;\n    }\n  }\n  \n  return stack.length === 0;\n}\n\n// Minimum Add to Make Valid\nfunction minAddToMakeValid(s) {\n  let open = 0;   // Unmatched '('\n  let close = 0;  // Unmatched ')'\n  \n  for (const char of s) {\n    if (char === '(') {\n      open++;\n    } else {\n      if (open > 0) open--;\n      else close++;\n    }\n  }\n  \n  return open + close;\n}\n\n// Longest Valid Parentheses\nfunction longestValidParentheses(s) {\n  const stack = [-1];  // Base index\n  let maxLen = 0;\n  \n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === '(') {\n      stack.push(i);\n    } else {\n      stack.pop();\n      if (stack.length === 0) {\n        stack.push(i);  // New base\n      } else {\n        maxLen = Math.max(maxLen, i - stack[stack.length - 1]);\n      }\n    }\n  }\n  \n  return maxLen;\n}\n\n// Generate All Valid Parentheses\nfunction generateParenthesis(n) {\n  const result = [];\n  \n  function backtrack(current, open, close) {\n    if (current.length === 2 * n) {\n      result.push(current);\n      return;\n    }\n    \n    if (open < n) {\n      backtrack(current + '(', open + 1, close);\n    }\n    if (close < open) {\n      backtrack(current + ')', open, close + 1);\n    }\n  }\n  \n  backtrack('', 0, 0);\n  return result;\n}\n\n// Remove Invalid Parentheses (BFS for minimum removals)\nfunction removeInvalidParentheses(s) {\n  const result = [];\n  const visited = new Set();\n  const queue = [s];\n  let found = false;\n  \n  while (queue.length) {\n    const curr = queue.shift();\n    \n    if (isValidParens(curr)) {\n      result.push(curr);\n      found = true;\n    }\n    \n    if (found) continue;  // Don't go shorter\n    \n    for (let i = 0; i < curr.length; i++) {\n      if (curr[i] !== '(' && curr[i] !== ')') continue;\n      const next = curr.slice(0, i) + curr.slice(i + 1);\n      if (!visited.has(next)) {\n        visited.add(next);\n        queue.push(next);\n      }\n    }\n  }\n  \n  return result.length ? result : [''];\n}\n\nfunction isValidParens(s) {\n  let count = 0;\n  for (const char of s) {\n    if (char === '(') count++;\n    else if (char === ')') count--;\n    if (count < 0) return false;\n  }\n  return count === 0;\n}"
  },
  {
    "id": 59,
    "question": "How do you detect cycles in a Directed Graph?",
    "answer": "**Cycle detection** in directed graphs determines if there's a path from a node back to itself.\n\n**Approaches:**\n\n**1. DFS with three colors**\n- White: unvisited\n- Gray: in current path (visiting)\n- Black: completely processed\n- Cycle exists if we visit a gray node\n\n**2. Topological Sort (Kahn's)**\n- If we can't process all nodes, there's a cycle\n- Not all nodes have in-degree 0 eventually\n\n**Time:** O(V + E)\n**Space:** O(V)\n\n**Common problems:**\n- Course Schedule\n- Deadlock detection\n- Dependency resolution",
    "example": "// Cycle Detection using DFS (three-color)\nfunction hasCycle(numNodes, edges) {\n  const adj = Array.from({ length: numNodes }, () => []);\n  for (const [from, to] of edges) {\n    adj[from].push(to);\n  }\n  \n  const WHITE = 0, GRAY = 1, BLACK = 2;\n  const color = Array(numNodes).fill(WHITE);\n  \n  function dfs(node) {\n    color[node] = GRAY;  // Start visiting\n    \n    for (const neighbor of adj[node]) {\n      if (color[neighbor] === GRAY) return true;  // Back edge = cycle\n      if (color[neighbor] === WHITE && dfs(neighbor)) return true;\n    }\n    \n    color[node] = BLACK;  // Done visiting\n    return false;\n  }\n  \n  for (let i = 0; i < numNodes; i++) {\n    if (color[i] === WHITE && dfs(i)) return true;\n  }\n  \n  return false;\n}\n\n// Course Schedule - Can finish all courses?\nfunction canFinish(numCourses, prerequisites) {\n  const adj = Array.from({ length: numCourses }, () => []);\n  const inDegree = Array(numCourses).fill(0);\n  \n  for (const [course, prereq] of prerequisites) {\n    adj[prereq].push(course);\n    inDegree[course]++;\n  }\n  \n  // Kahn's algorithm (BFS topological sort)\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  let count = 0;\n  while (queue.length) {\n    const node = queue.shift();\n    count++;\n    \n    for (const neighbor of adj[node]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n  \n  return count === numCourses;  // Processed all = no cycle\n}\n\n// Course Schedule II - Return valid order\nfunction findOrder(numCourses, prerequisites) {\n  const adj = Array.from({ length: numCourses }, () => []);\n  const inDegree = Array(numCourses).fill(0);\n  \n  for (const [course, prereq] of prerequisites) {\n    adj[prereq].push(course);\n    inDegree[course]++;\n  }\n  \n  const queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  const order = [];\n  while (queue.length) {\n    const node = queue.shift();\n    order.push(node);\n    \n    for (const neighbor of adj[node]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n  \n  return order.length === numCourses ? order : [];\n}\n\n// Find all cycles in directed graph\nfunction findAllCycles(numNodes, edges) {\n  const adj = Array.from({ length: numNodes }, () => []);\n  for (const [from, to] of edges) {\n    adj[from].push(to);\n  }\n  \n  const cycles = [];\n  const visited = Array(numNodes).fill(false);\n  const path = [];\n  const inPath = new Set();\n  \n  function dfs(node) {\n    visited[node] = true;\n    path.push(node);\n    inPath.add(node);\n    \n    for (const neighbor of adj[node]) {\n      if (inPath.has(neighbor)) {\n        // Found cycle, extract it\n        const cycleStart = path.indexOf(neighbor);\n        cycles.push(path.slice(cycleStart));\n      } else if (!visited[neighbor]) {\n        dfs(neighbor);\n      }\n    }\n    \n    path.pop();\n    inPath.delete(node);\n  }\n  \n  for (let i = 0; i < numNodes; i++) {\n    if (!visited[i]) dfs(i);\n  }\n  \n  return cycles;\n}"
  },
  {
    "id": 60,
    "question": "How do you solve Product of Array Except Self?",
    "answer": "**Product of Array Except Self** returns array where each element is product of all other elements, without using division.\n\n**Key insight:**\n- result[i] = product of left side × product of right side\n- Build left products, then multiply by right products\n\n**Approaches:**\n\n**1. Two arrays**\n- leftProducts[i] = product of elements before i\n- rightProducts[i] = product of elements after i\n- O(n) time, O(n) space\n\n**2. Single pass with output array**\n- Build left products in result\n- Multiply by right products in second pass\n- O(n) time, O(1) extra space\n\n**Handle zeros:**\n- One zero: Only that position has non-zero result\n- Multiple zeros: All results are 0",
    "example": "// Product Except Self - O(n) time, O(1) extra space\nfunction productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n);\n  \n  // Build left products in result\n  result[0] = 1;\n  for (let i = 1; i < n; i++) {\n    result[i] = result[i - 1] * nums[i - 1];\n  }\n  \n  // Multiply by right products\n  let rightProduct = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= rightProduct;\n    rightProduct *= nums[i];\n  }\n  \n  return result;\n}\n\n// Two arrays approach (clearer to understand)\nfunction productExceptSelfTwoArrays(nums) {\n  const n = nums.length;\n  const left = new Array(n);\n  const right = new Array(n);\n  \n  // Left products\n  left[0] = 1;\n  for (let i = 1; i < n; i++) {\n    left[i] = left[i - 1] * nums[i - 1];\n  }\n  \n  // Right products\n  right[n - 1] = 1;\n  for (let i = n - 2; i >= 0; i--) {\n    right[i] = right[i + 1] * nums[i + 1];\n  }\n  \n  // Combine\n  return nums.map((_, i) => left[i] * right[i]);\n}\n\n// With division (if allowed, handles zeros)\nfunction productWithDivision(nums) {\n  let product = 1;\n  let zeroCount = 0;\n  \n  for (const num of nums) {\n    if (num === 0) zeroCount++;\n    else product *= num;\n  }\n  \n  return nums.map(num => {\n    if (zeroCount > 1) return 0;\n    if (zeroCount === 1) return num === 0 ? product : 0;\n    return product / num;\n  });\n}\n\n// Maximum Product Subarray (related problem)\nfunction maxProduct(nums) {\n  let maxProd = nums[0];\n  let currMax = nums[0];\n  let currMin = nums[0];  // Track min for negative flips\n  \n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < 0) {\n      [currMax, currMin] = [currMin, currMax];\n    }\n    \n    currMax = Math.max(nums[i], currMax * nums[i]);\n    currMin = Math.min(nums[i], currMin * nums[i]);\n    maxProd = Math.max(maxProd, currMax);\n  }\n  \n  return maxProd;\n}"
  },
  {
    "id": 61,
    "question": "What is the Prefix Sum technique?",
    "answer": "**Prefix Sum** preprocesses an array to answer range sum queries in O(1).\n\n**Build:**\n- prefix[i] = sum of elements from 0 to i-1\n- prefix[0] = 0\n- prefix[i] = prefix[i-1] + arr[i-1]\n\n**Query:**\n- Sum of [l, r] = prefix[r+1] - prefix[l]\n\n**Time:** O(n) preprocessing, O(1) query\n**Space:** O(n)\n\n**Applications:**\n- Range sum queries\n- Subarray sum equals k\n- 2D range queries\n- Difference arrays for range updates",
    "example": "// Prefix Sum - Basic\nfunction buildPrefixSum(arr) {\n  const prefix = [0];\n  for (const num of arr) {\n    prefix.push(prefix[prefix.length - 1] + num);\n  }\n  return prefix;\n}\n\nfunction rangeSum(prefix, l, r) {\n  return prefix[r + 1] - prefix[l];\n}\n\n// Subarray Sum Equals K - Count subarrays with sum k\nfunction subarraySum(nums, k) {\n  const prefixCount = new Map([[0, 1]]);  // prefix sum -> count\n  let sum = 0;\n  let count = 0;\n  \n  for (const num of nums) {\n    sum += num;\n    // If (sum - k) exists, we found subarrays summing to k\n    if (prefixCount.has(sum - k)) {\n      count += prefixCount.get(sum - k);\n    }\n    prefixCount.set(sum, (prefixCount.get(sum) || 0) + 1);\n  }\n  \n  return count;\n}\n\n// Contiguous Array - Longest subarray with equal 0s and 1s\nfunction findMaxLength(nums) {\n  const firstOccurrence = new Map([[0, -1]]);\n  let sum = 0;  // Treat 0 as -1, 1 as 1\n  let maxLen = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i] === 0 ? -1 : 1;\n    \n    if (firstOccurrence.has(sum)) {\n      maxLen = Math.max(maxLen, i - firstOccurrence.get(sum));\n    } else {\n      firstOccurrence.set(sum, i);\n    }\n  }\n  \n  return maxLen;\n}\n\n// 2D Prefix Sum\nclass NumMatrix {\n  constructor(matrix) {\n    const m = matrix.length, n = matrix[0].length;\n    this.prefix = Array(m + 1).fill(null)\n      .map(() => Array(n + 1).fill(0));\n    \n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        this.prefix[i][j] = matrix[i - 1][j - 1] +\n          this.prefix[i - 1][j] + this.prefix[i][j - 1] -\n          this.prefix[i - 1][j - 1];\n      }\n    }\n  }\n\n  sumRegion(r1, c1, r2, c2) {\n    return this.prefix[r2 + 1][c2 + 1] -\n           this.prefix[r1][c2 + 1] -\n           this.prefix[r2 + 1][c1] +\n           this.prefix[r1][c1];\n  }\n}\n\n// Difference Array - Range increment in O(1)\nclass DifferenceArray {\n  constructor(n) {\n    this.diff = Array(n + 1).fill(0);\n  }\n\n  // Add val to range [l, r]\n  rangeAdd(l, r, val) {\n    this.diff[l] += val;\n    this.diff[r + 1] -= val;\n  }\n\n  // Get final array\n  getResult() {\n    const result = [];\n    let sum = 0;\n    for (let i = 0; i < this.diff.length - 1; i++) {\n      sum += this.diff[i];\n      result.push(sum);\n    }\n    return result;\n  }\n}"
  },
  {
    "id": 62,
    "question": "How do you solve Grid Path problems (Unique Paths)?",
    "answer": "**Grid Path** problems count or find paths from top-left to bottom-right.\n\n**Unique Paths:**\n- Can only move right or down\n- dp[i][j] = dp[i-1][j] + dp[i][j-1]\n- Total paths = C(m+n-2, m-1)\n\n**Variations:**\n- With obstacles: Skip blocked cells\n- Minimum path sum: Take min instead of sum\n- Maximum path sum: Take max\n\n**Time:** O(m × n)\n**Space:** O(n) with optimization",
    "example": "// Unique Paths - DP\nfunction uniquePaths(m, n) {\n  const dp = Array(m).fill(null).map(() => Array(n).fill(1));\n  \n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n    }\n  }\n  \n  return dp[m - 1][n - 1];\n}\n\n// Space optimized O(n)\nfunction uniquePathsOptimized(m, n) {\n  const dp = Array(n).fill(1);\n  \n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[j] += dp[j - 1];\n    }\n  }\n  \n  return dp[n - 1];\n}\n\n// Unique Paths with Obstacles\nfunction uniquePathsWithObstacles(grid) {\n  const m = grid.length, n = grid[0].length;\n  if (grid[0][0] === 1) return 0;\n  \n  const dp = Array(n).fill(0);\n  dp[0] = 1;\n  \n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 1) {\n        dp[j] = 0;\n      } else if (j > 0) {\n        dp[j] += dp[j - 1];\n      }\n    }\n  }\n  \n  return dp[n - 1];\n}\n\n// Minimum Path Sum\nfunction minPathSum(grid) {\n  const m = grid.length, n = grid[0].length;\n  const dp = Array(n).fill(Infinity);\n  dp[0] = 0;\n  \n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (j === 0) {\n        dp[j] += grid[i][j];\n      } else {\n        dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j];\n      }\n    }\n  }\n  \n  return dp[n - 1];\n}\n\n// Triangle - Minimum path sum (can go down or down-right)\nfunction minimumTotal(triangle) {\n  const n = triangle.length;\n  const dp = [...triangle[n - 1]];  // Start from bottom\n  \n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = 0; j <= i; j++) {\n      dp[j] = triangle[i][j] + Math.min(dp[j], dp[j + 1]);\n    }\n  }\n  \n  return dp[0];\n}\n\n// Dungeon Game - Minimum health to reach princess\nfunction calculateMinimumHP(dungeon) {\n  const m = dungeon.length, n = dungeon[0].length;\n  const dp = Array(m + 1).fill(null)\n    .map(() => Array(n + 1).fill(Infinity));\n  \n  dp[m][n - 1] = dp[m - 1][n] = 1;  // Need at least 1 health\n  \n  for (let i = m - 1; i >= 0; i--) {\n    for (let j = n - 1; j >= 0; j--) {\n      const minHealth = Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];\n      dp[i][j] = Math.max(1, minHealth);\n    }\n  }\n  \n  return dp[0][0];\n}"
  },
  {
    "id": 63,
    "question": "How do you find the Diameter of a Binary Tree?",
    "answer": "**Diameter** is the longest path between any two nodes (measured in edges).\n\n**Key insight:**\n- Path passes through some node as the highest point\n- For each node: diameter through it = leftHeight + rightHeight\n- Track max diameter while computing heights\n\n**Note:**\n- Path may not pass through root\n- Path can go left-subtree → node → right-subtree\n\n**Time:** O(n)\n**Space:** O(h) for recursion\n\n**Related problems:**\n- Binary Tree Maximum Path Sum\n- Longest Path with Same Value",
    "example": "// Diameter of Binary Tree\nfunction diameterOfBinaryTree(root) {\n  let diameter = 0;\n  \n  function height(node) {\n    if (!node) return 0;\n    \n    const leftHeight = height(node.left);\n    const rightHeight = height(node.right);\n    \n    // Update diameter (path through this node)\n    diameter = Math.max(diameter, leftHeight + rightHeight);\n    \n    // Return height for parent\n    return 1 + Math.max(leftHeight, rightHeight);\n  }\n  \n  height(root);\n  return diameter;\n}\n\n// Binary Tree Maximum Path Sum\nfunction maxPathSum(root) {\n  let maxSum = -Infinity;\n  \n  function dfs(node) {\n    if (!node) return 0;\n    \n    // Only take positive contributions\n    const leftMax = Math.max(0, dfs(node.left));\n    const rightMax = Math.max(0, dfs(node.right));\n    \n    // Path through this node\n    maxSum = Math.max(maxSum, leftMax + node.val + rightMax);\n    \n    // Return best single path for parent\n    return node.val + Math.max(leftMax, rightMax);\n  }\n  \n  dfs(root);\n  return maxSum;\n}\n\n// Maximum Depth of Binary Tree\nfunction maxDepth(root) {\n  if (!root) return 0;\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n\n// Minimum Depth of Binary Tree\nfunction minDepth(root) {\n  if (!root) return 0;\n  if (!root.left) return 1 + minDepth(root.right);\n  if (!root.right) return 1 + minDepth(root.left);\n  return 1 + Math.min(minDepth(root.left), minDepth(root.right));\n}\n\n// Check if Balanced Binary Tree\nfunction isBalanced(root) {\n  function check(node) {\n    if (!node) return 0;\n    \n    const left = check(node.left);\n    if (left === -1) return -1;\n    \n    const right = check(node.right);\n    if (right === -1) return -1;\n    \n    if (Math.abs(left - right) > 1) return -1;\n    \n    return 1 + Math.max(left, right);\n  }\n  \n  return check(root) !== -1;\n}\n\n// Longest Path with Same Value\nfunction longestUnivaluePath(root) {\n  let longest = 0;\n  \n  function dfs(node) {\n    if (!node) return 0;\n    \n    const left = dfs(node.left);\n    const right = dfs(node.right);\n    \n    let leftPath = 0, rightPath = 0;\n    \n    if (node.left && node.left.val === node.val) {\n      leftPath = left + 1;\n    }\n    if (node.right && node.right.val === node.val) {\n      rightPath = right + 1;\n    }\n    \n    longest = Math.max(longest, leftPath + rightPath);\n    \n    return Math.max(leftPath, rightPath);\n  }\n  \n  dfs(root);\n  return longest;\n}"
  },
  {
    "id": 64,
    "question": "How do you implement Regular Expression Matching?",
    "answer": "**Regular Expression Matching** checks if pattern matches entire string with '.' and '*'.\n\n**Operators:**\n- '.' matches any single character\n- '*' matches zero or more of the preceding element\n\n**Approach: Dynamic Programming**\n- dp[i][j] = does s[0..i-1] match p[0..j-1]?\n- Handle '*' by matching zero times or one+ times\n\n**Time:** O(m × n)\n**Space:** O(m × n)\n\n**Related:**\n- Wildcard Matching ('?' and '*')",
    "example": "// Regular Expression Matching - DP\nfunction isMatch(s, p) {\n  const m = s.length, n = p.length;\n  // dp[i][j] = s[0..i-1] matches p[0..j-1]\n  const dp = Array(m + 1).fill(null)\n    .map(() => Array(n + 1).fill(false));\n  \n  dp[0][0] = true;  // Empty matches empty\n  \n  // Handle patterns like a*, a*b*, etc. matching empty string\n  for (let j = 1; j <= n; j++) {\n    if (p[j - 1] === '*') {\n      dp[0][j] = dp[0][j - 2];  // * matches zero of preceding\n    }\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '*') {\n        // Zero occurrences: dp[i][j-2]\n        // One+ occurrences: dp[i-1][j] if s[i-1] matches p[j-2]\n        dp[i][j] = dp[i][j - 2] ||  // Zero times\n          (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n      } else if (p[j - 1] === '.' || s[i - 1] === p[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      }\n    }\n  }\n  \n  return dp[m][n];\n}\n\n// Wildcard Matching - '?' and '*'\n// '?' matches exactly one character\n// '*' matches any sequence (including empty)\nfunction isMatchWildcard(s, p) {\n  const m = s.length, n = p.length;\n  const dp = Array(m + 1).fill(null)\n    .map(() => Array(n + 1).fill(false));\n  \n  dp[0][0] = true;\n  \n  // Handle leading *'s matching empty string\n  for (let j = 1; j <= n; j++) {\n    if (p[j - 1] === '*') dp[0][j] = dp[0][j - 1];\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '*') {\n        // Match zero chars or one+ chars\n        dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\n      } else if (p[j - 1] === '?' || s[i - 1] === p[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      }\n    }\n  }\n  \n  return dp[m][n];\n}\n\n// Space optimized for Wildcard\nfunction isMatchWildcardOptimized(s, p) {\n  const m = s.length, n = p.length;\n  let prev = Array(n + 1).fill(false);\n  prev[0] = true;\n  \n  for (let j = 1; j <= n; j++) {\n    if (p[j - 1] === '*') prev[j] = prev[j - 1];\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    const curr = Array(n + 1).fill(false);\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '*') {\n        curr[j] = curr[j - 1] || prev[j];\n      } else if (p[j - 1] === '?' || s[i - 1] === p[j - 1]) {\n        curr[j] = prev[j - 1];\n      }\n    }\n    prev = curr;\n  }\n  \n  return prev[n];\n}"
  },
  {
    "id": 65,
    "question": "How do you find All Anagrams in a String?",
    "answer": "**Find Anagrams** locates all starting indices where pattern's anagram exists in string.\n\n**Approach: Sliding Window + Character Count**\n- Fixed window size = pattern length\n- Track character frequencies\n- When frequencies match, found an anagram\n\n**Optimization:**\n- Track number of matching characters instead of comparing full maps\n- Increment/decrement as window slides\n\n**Time:** O(n)\n**Space:** O(1) for fixed alphabet size\n\n**Related:**\n- Permutation in String\n- Minimum Window Substring",
    "example": "// Find All Anagrams - Sliding Window\nfunction findAnagrams(s, p) {\n  const result = [];\n  if (s.length < p.length) return result;\n  \n  const pCount = new Map();\n  const sCount = new Map();\n  \n  // Initialize pattern character count\n  for (const char of p) {\n    pCount.set(char, (pCount.get(char) || 0) + 1);\n  }\n  \n  // Process first window\n  for (let i = 0; i < p.length; i++) {\n    sCount.set(s[i], (sCount.get(s[i]) || 0) + 1);\n  }\n  \n  if (mapsEqual(sCount, pCount)) result.push(0);\n  \n  // Slide window\n  for (let i = p.length; i < s.length; i++) {\n    // Add new character\n    sCount.set(s[i], (sCount.get(s[i]) || 0) + 1);\n    \n    // Remove old character\n    const oldChar = s[i - p.length];\n    if (sCount.get(oldChar) === 1) sCount.delete(oldChar);\n    else sCount.set(oldChar, sCount.get(oldChar) - 1);\n    \n    if (mapsEqual(sCount, pCount)) {\n      result.push(i - p.length + 1);\n    }\n  }\n  \n  return result;\n}\n\nfunction mapsEqual(map1, map2) {\n  if (map1.size !== map2.size) return false;\n  for (const [key, val] of map1) {\n    if (map2.get(key) !== val) return false;\n  }\n  return true;\n}\n\n// Optimized - Track matching count\nfunction findAnagramsOptimized(s, p) {\n  const result = [];\n  if (s.length < p.length) return result;\n  \n  const count = new Array(26).fill(0);\n  let matches = 0;\n  \n  // Build initial count from pattern\n  for (const char of p) {\n    count[char.charCodeAt(0) - 97]++;\n  }\n  \n  // Count zeros (characters not in pattern, already matching)\n  for (let i = 0; i < 26; i++) {\n    if (count[i] === 0) matches++;\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    const idx = s.charCodeAt(i) - 97;\n    \n    // Add character to window\n    count[idx]--;\n    if (count[idx] === 0) matches++;\n    else if (count[idx] === -1) matches--;\n    \n    // Remove character from window\n    if (i >= p.length) {\n      const leftIdx = s.charCodeAt(i - p.length) - 97;\n      count[leftIdx]++;\n      if (count[leftIdx] === 0) matches++;\n      else if (count[leftIdx] === 1) matches--;\n    }\n    \n    if (matches === 26) result.push(i - p.length + 1);\n  }\n  \n  return result;\n}\n\n// Minimum Window Substring\nfunction minWindow(s, t) {\n  const need = new Map();\n  for (const char of t) need.set(char, (need.get(char) || 0) + 1);\n  \n  let have = 0, required = need.size;\n  let left = 0, minLen = Infinity, minStart = 0;\n  const window = new Map();\n  \n  for (let right = 0; right < s.length; right++) {\n    const char = s[right];\n    window.set(char, (window.get(char) || 0) + 1);\n    \n    if (need.has(char) && window.get(char) === need.get(char)) {\n      have++;\n    }\n    \n    while (have === required) {\n      if (right - left + 1 < minLen) {\n        minLen = right - left + 1;\n        minStart = left;\n      }\n      \n      const leftChar = s[left];\n      window.set(leftChar, window.get(leftChar) - 1);\n      if (need.has(leftChar) && window.get(leftChar) < need.get(leftChar)) {\n        have--;\n      }\n      left++;\n    }\n  }\n  \n  return minLen === Infinity ? '' : s.substring(minStart, minStart + minLen);\n}"
  },
  {
    "id": 66,
    "question": "How do you solve the Task Scheduler problem?",
    "answer": "**Task Scheduler** finds minimum intervals to execute all tasks with cooldown between same tasks.\n\n**Key insight:**\n- Focus on most frequent task\n- Create \"slots\" with cooldown periods\n- Fill slots with other tasks\n\n**Formula approach:**\n- (maxFreq - 1) × (n + 1) + countOfMaxFreq\n- But can't be less than total tasks\n\n**Heap approach:**\n- Greedy: always pick task with highest remaining count\n- Use heap + cooldown queue\n\n**Time:** O(total tasks)\n**Space:** O(26) for alphabet",
    "example": "// Task Scheduler - Formula approach\nfunction leastInterval(tasks, n) {\n  const freq = new Array(26).fill(0);\n  for (const task of tasks) {\n    freq[task.charCodeAt(0) - 65]++;\n  }\n  \n  const maxFreq = Math.max(...freq);\n  const maxCount = freq.filter(f => f === maxFreq).length;\n  \n  // Calculate minimum slots needed\n  // (maxFreq - 1) chunks with (n + 1) slots each\n  // Plus final chunk with maxCount tasks\n  const formulaResult = (maxFreq - 1) * (n + 1) + maxCount;\n  \n  // Result can't be less than total tasks\n  return Math.max(formulaResult, tasks.length);\n}\n\n// Heap approach - Returns actual schedule\nfunction leastIntervalWithSchedule(tasks, n) {\n  const freq = new Map();\n  for (const task of tasks) {\n    freq.set(task, (freq.get(task) || 0) + 1);\n  }\n  \n  // Max heap of frequencies (using negative for min heap)\n  const heap = [...freq.values()].map(f => -f);\n  heap.sort((a, b) => a - b);\n  \n  const cooldown = [];  // [frequency, availableTime]\n  let time = 0;\n  \n  while (heap.length || cooldown.length) {\n    time++;\n    \n    if (heap.length) {\n      // Pop highest frequency task\n      const count = -heap.shift() - 1;\n      if (count > 0) {\n        cooldown.push([count, time + n]);\n      }\n    }\n    \n    // Check if any task's cooldown has ended\n    if (cooldown.length && cooldown[0][1] === time) {\n      const [count] = cooldown.shift();\n      heap.push(-count);\n      heap.sort((a, b) => a - b);\n    }\n  }\n  \n  return time;\n}\n\n// Reorganize String - No same adjacent characters\nfunction reorganizeString(s) {\n  const freq = new Map();\n  for (const char of s) {\n    freq.set(char, (freq.get(char) || 0) + 1);\n  }\n  \n  // Check if possible\n  const maxFreq = Math.max(...freq.values());\n  if (maxFreq > Math.ceil(s.length / 2)) return '';\n  \n  // Sort by frequency descending\n  const sorted = [...freq.entries()].sort((a, b) => b[1] - a[1]);\n  \n  // Fill even indices first, then odd\n  const result = new Array(s.length);\n  let idx = 0;\n  \n  for (const [char, count] of sorted) {\n    for (let i = 0; i < count; i++) {\n      if (idx >= s.length) idx = 1;  // Switch to odd indices\n      result[idx] = char;\n      idx += 2;\n    }\n  }\n  \n  return result.join('');\n}"
  },
  {
    "id": 67,
    "question": "How do you solve Jump Game problems?",
    "answer": "**Jump Game** determines if you can reach the end or finds minimum jumps needed.\n\n**Jump Game I (can reach?):**\n- Track furthest reachable position\n- Greedy: update max reach at each step\n- Can't continue if current > maxReach\n\n**Jump Game II (min jumps):**\n- BFS/Greedy: track current jump's range\n- When reaching range end, increment jumps\n- Find furthest reach in current range\n\n**Time:** O(n)\n**Space:** O(1)",
    "example": "// Jump Game I - Can reach end?\nfunction canJump(nums) {\n  let maxReach = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;  // Can't reach this position\n    maxReach = Math.max(maxReach, i + nums[i]);\n    if (maxReach >= nums.length - 1) return true;\n  }\n  \n  return true;\n}\n\n// Jump Game II - Minimum jumps\nfunction jump(nums) {\n  if (nums.length <= 1) return 0;\n  \n  let jumps = 0;\n  let currentEnd = 0;   // End of current jump range\n  let furthest = 0;     // Furthest we can reach\n  \n  for (let i = 0; i < nums.length - 1; i++) {\n    furthest = Math.max(furthest, i + nums[i]);\n    \n    if (i === currentEnd) {\n      jumps++;\n      currentEnd = furthest;\n      \n      if (currentEnd >= nums.length - 1) break;\n    }\n  }\n  \n  return jumps;\n}\n\n// Jump Game III - Can reach value 0?\n// Can jump to i+arr[i] or i-arr[i]\nfunction canReach(arr, start) {\n  const visited = new Set();\n  const queue = [start];\n  \n  while (queue.length) {\n    const i = queue.shift();\n    \n    if (arr[i] === 0) return true;\n    if (visited.has(i)) continue;\n    visited.add(i);\n    \n    const forward = i + arr[i];\n    const backward = i - arr[i];\n    \n    if (forward < arr.length) queue.push(forward);\n    if (backward >= 0) queue.push(backward);\n  }\n  \n  return false;\n}\n\n// Jump Game IV - Minimum jumps with teleportation\n// Can jump to i-1, i+1, or any j where arr[j] === arr[i]\nfunction minJumps(arr) {\n  const n = arr.length;\n  if (n === 1) return 0;\n  \n  // Group indices by value\n  const graph = new Map();\n  for (let i = 0; i < n; i++) {\n    if (!graph.has(arr[i])) graph.set(arr[i], []);\n    graph.get(arr[i]).push(i);\n  }\n  \n  const visited = new Set([0]);\n  const queue = [0];\n  let jumps = 0;\n  \n  while (queue.length) {\n    jumps++;\n    const size = queue.length;\n    \n    for (let q = 0; q < size; q++) {\n      const i = queue.shift();\n      \n      // Check neighbors\n      const neighbors = [i - 1, i + 1];\n      if (graph.has(arr[i])) {\n        neighbors.push(...graph.get(arr[i]));\n        graph.delete(arr[i]);  // Optimization: don't revisit same value group\n      }\n      \n      for (const j of neighbors) {\n        if (j === n - 1) return jumps;\n        if (j >= 0 && j < n && !visited.has(j)) {\n          visited.add(j);\n          queue.push(j);\n        }\n      }\n    }\n  }\n  \n  return -1;\n}"
  },
  {
    "id": 68,
    "question": "What is the Dutch National Flag problem (Sort Colors)?",
    "answer": "**Dutch National Flag** sorts an array with three distinct values in one pass.\n\n**Problem:**\n- Sort array containing only 0s, 1s, and 2s\n- Do it in-place with one pass\n\n**Three-pointer approach:**\n- low: boundary for 0s (next position for 0)\n- mid: current element\n- high: boundary for 2s (next position for 2)\n\n**Rules:**\n- If arr[mid] = 0: swap with low, increment both\n- If arr[mid] = 1: just increment mid\n- If arr[mid] = 2: swap with high, decrement high\n\n**Time:** O(n)\n**Space:** O(1)",
    "example": "// Sort Colors - Dutch National Flag\nfunction sortColors(nums) {\n  let low = 0;              // Next position for 0\n  let mid = 0;              // Current position\n  let high = nums.length - 1; // Next position for 2\n  \n  while (mid <= high) {\n    if (nums[mid] === 0) {\n      [nums[low], nums[mid]] = [nums[mid], nums[low]];\n      low++;\n      mid++;\n    } else if (nums[mid] === 1) {\n      mid++;\n    } else {  // nums[mid] === 2\n      [nums[mid], nums[high]] = [nums[high], nums[mid]];\n      high--;\n      // Don't increment mid - need to check swapped element\n    }\n  }\n}\n\n// Move Zeroes - Move all 0s to end\nfunction moveZeroes(nums) {\n  let insertPos = 0;\n  \n  // Move all non-zeros to front\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] !== 0) {\n      nums[insertPos++] = nums[i];\n    }\n  }\n  \n  // Fill rest with zeros\n  while (insertPos < nums.length) {\n    nums[insertPos++] = 0;\n  }\n}\n\n// Partition Array - Move elements by pivot\nfunction partition(nums, pivot) {\n  let low = 0, mid = 0, high = nums.length - 1;\n  \n  while (mid <= high) {\n    if (nums[mid] < pivot) {\n      [nums[low], nums[mid]] = [nums[mid], nums[low]];\n      low++;\n      mid++;\n    } else if (nums[mid] === pivot) {\n      mid++;\n    } else {\n      [nums[mid], nums[high]] = [nums[high], nums[mid]];\n      high--;\n    }\n  }\n}\n\n// Segregate Even and Odd\nfunction segregateEvenOdd(nums) {\n  let left = 0, right = nums.length - 1;\n  \n  while (left < right) {\n    while (left < right && nums[left] % 2 === 0) left++;\n    while (left < right && nums[right] % 2 === 1) right--;\n    \n    if (left < right) {\n      [nums[left], nums[right]] = [nums[right], nums[left]];\n      left++;\n      right--;\n    }\n  }\n}\n\n// Sort Array by Parity\nfunction sortArrayByParity(nums) {\n  let i = 0, j = nums.length - 1;\n  \n  while (i < j) {\n    if (nums[i] % 2 > nums[j] % 2) {\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n    if (nums[i] % 2 === 0) i++;\n    if (nums[j] % 2 === 1) j--;\n  }\n  \n  return nums;\n}"
  },
  {
    "id": 69,
    "question": "How do you rotate an Array?",
    "answer": "**Rotate Array** shifts elements by k positions (right rotation).\n\n**Approaches:**\n\n**1. Reverse method (optimal)**\n- Reverse entire array\n- Reverse first k elements\n- Reverse remaining elements\n- O(n) time, O(1) space\n\n**2. Cyclic replacement**\n- Move each element to final position\n- Track cycles for GCD(n,k) starts\n\n**3. Extra array**\n- Copy to temp with offset\n- O(n) time, O(n) space\n\n**Note:** k = k % n to handle k > n",
    "example": "// Rotate Array - Reverse method (optimal)\nfunction rotate(nums, k) {\n  k = k % nums.length;\n  if (k === 0) return;\n  \n  // Reverse helper\n  function reverse(start, end) {\n    while (start < end) {\n      [nums[start], nums[end]] = [nums[end], nums[start]];\n      start++;\n      end--;\n    }\n  }\n  \n  // [1,2,3,4,5,6,7], k=3\n  reverse(0, nums.length - 1);  // [7,6,5,4,3,2,1]\n  reverse(0, k - 1);            // [5,6,7,4,3,2,1]\n  reverse(k, nums.length - 1);  // [5,6,7,1,2,3,4]\n}\n\n// Cyclic replacement approach\nfunction rotateCyclic(nums, k) {\n  k = k % nums.length;\n  if (k === 0) return;\n  \n  let count = 0;  // Elements moved\n  let start = 0;\n  \n  while (count < nums.length) {\n    let current = start;\n    let prev = nums[start];\n    \n    do {\n      const next = (current + k) % nums.length;\n      const temp = nums[next];\n      nums[next] = prev;\n      prev = temp;\n      current = next;\n      count++;\n    } while (current !== start);\n    \n    start++;\n  }\n}\n\n// Left rotation\nfunction rotateLeft(nums, k) {\n  k = k % nums.length;\n  if (k === 0) return;\n  \n  function reverse(start, end) {\n    while (start < end) {\n      [nums[start], nums[end]] = [nums[end], nums[start]];\n      start++;\n      end--;\n    }\n  }\n  \n  // [1,2,3,4,5], k=2 → [3,4,5,1,2]\n  reverse(0, k - 1);            // Reverse first k\n  reverse(k, nums.length - 1);  // Reverse rest\n  reverse(0, nums.length - 1);  // Reverse all\n}\n\n// Rotate String - Check if s2 is rotation of s1\nfunction rotateString(s, goal) {\n  if (s.length !== goal.length) return false;\n  return (s + s).includes(goal);\n}\n\n// Find Rotation Count in Rotated Sorted Array\nfunction findRotationCount(nums) {\n  let left = 0, right = nums.length - 1;\n  \n  // Array not rotated\n  if (nums[left] <= nums[right]) return 0;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] > nums[mid + 1]) return mid + 1;\n    if (nums[mid] < nums[mid - 1]) return mid;\n    \n    if (nums[left] <= nums[mid]) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "id": 70,
    "question": "How do you implement String to Integer (atoi)?",
    "answer": "**atoi** converts a string to a 32-bit signed integer.\n\n**Steps:**\n1. Skip leading whitespace\n2. Check optional sign (+/-)\n3. Read digits until non-digit\n4. Handle overflow (clamp to INT_MIN/INT_MAX)\n\n**Edge cases:**\n- Empty string\n- Only whitespace\n- No digits after sign\n- Overflow/underflow\n- Leading zeros\n\n**Time:** O(n)\n**Space:** O(1)\n\n**Related:** Integer to String (itoa)",
    "example": "// String to Integer (atoi)\nfunction myAtoi(s) {\n  const INT_MAX = 2147483647;   // 2^31 - 1\n  const INT_MIN = -2147483648;  // -2^31\n  \n  let i = 0;\n  const n = s.length;\n  \n  // 1. Skip whitespace\n  while (i < n && s[i] === ' ') i++;\n  if (i >= n) return 0;\n  \n  // 2. Check sign\n  let sign = 1;\n  if (s[i] === '+' || s[i] === '-') {\n    sign = s[i] === '-' ? -1 : 1;\n    i++;\n  }\n  \n  // 3. Read digits\n  let result = 0;\n  while (i < n && s[i] >= '0' && s[i] <= '9') {\n    const digit = s[i].charCodeAt(0) - 48;\n    \n    // 4. Check overflow before adding\n    if (result > Math.floor((INT_MAX - digit) / 10)) {\n      return sign === 1 ? INT_MAX : INT_MIN;\n    }\n    \n    result = result * 10 + digit;\n    i++;\n  }\n  \n  return sign * result;\n}\n\n// Integer to String\nfunction intToString(num) {\n  if (num === 0) return '0';\n  \n  let negative = false;\n  if (num < 0) {\n    negative = true;\n    num = -num;\n  }\n  \n  let result = '';\n  while (num > 0) {\n    result = (num % 10) + result;\n    num = Math.floor(num / 10);\n  }\n  \n  return negative ? '-' + result : result;\n}\n\n// Reverse Integer with overflow check\nfunction reverse(x) {\n  const INT_MAX = 2147483647;\n  const INT_MIN = -2147483648;\n  \n  let result = 0;\n  \n  while (x !== 0) {\n    const digit = x % 10;\n    x = Math.trunc(x / 10);\n    \n    // Check overflow before adding\n    if (result > Math.floor(INT_MAX / 10) || \n        (result === Math.floor(INT_MAX / 10) && digit > 7)) {\n      return 0;\n    }\n    if (result < Math.ceil(INT_MIN / 10) || \n        (result === Math.ceil(INT_MIN / 10) && digit < -8)) {\n      return 0;\n    }\n    \n    result = result * 10 + digit;\n  }\n  \n  return result;\n}\n\n// Palindrome Number - Without converting to string\nfunction isPalindromeNumber(x) {\n  if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n  \n  let reversed = 0;\n  while (x > reversed) {\n    reversed = reversed * 10 + x % 10;\n    x = Math.floor(x / 10);\n  }\n  \n  return x === reversed || x === Math.floor(reversed / 10);\n}"
  },
  {
    "id": 71,
    "question": "How do you Group Anagrams?",
    "answer": "**Group Anagrams** groups strings that are anagrams of each other.\n\n**Key insight:**\n- Anagrams have same characters in different order\n- Sorting gives same result for anagrams\n- Or use character count as key\n\n**Approaches:**\n\n**1. Sort as key**\n- Sort each string, use as hash key\n- O(n × k log k) time\n\n**2. Character count as key**\n- Count frequency, convert to string key\n- O(n × k) time\n\n**Space:** O(n × k) for result",
    "example": "// Group Anagrams - Sort as key\nfunction groupAnagrams(strs) {\n  const map = new Map();\n  \n  for (const str of strs) {\n    const sorted = str.split('').sort().join('');\n    \n    if (!map.has(sorted)) {\n      map.set(sorted, []);\n    }\n    map.get(sorted).push(str);\n  }\n  \n  return [...map.values()];\n}\n\n// Character count as key - O(n * k)\nfunction groupAnagramsCount(strs) {\n  const map = new Map();\n  \n  for (const str of strs) {\n    // Create count array [0,0,0,...] for 26 letters\n    const count = new Array(26).fill(0);\n    for (const char of str) {\n      count[char.charCodeAt(0) - 97]++;\n    }\n    \n    // Use count as key (convert to string)\n    const key = count.join('#');\n    \n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(str);\n  }\n  \n  return [...map.values()];\n}\n\n// Check if two strings are anagrams\nfunction isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  \n  const count = new Array(26).fill(0);\n  \n  for (let i = 0; i < s.length; i++) {\n    count[s.charCodeAt(i) - 97]++;\n    count[t.charCodeAt(i) - 97]--;\n  }\n  \n  return count.every(c => c === 0);\n}\n\n// Find Duplicate File in System\n// Input: [\"root/a 1.txt(abcd) 2.txt(efgh)\", ...]\nfunction findDuplicate(paths) {\n  const contentMap = new Map();\n  \n  for (const path of paths) {\n    const parts = path.split(' ');\n    const dir = parts[0];\n    \n    for (let i = 1; i < parts.length; i++) {\n      const match = parts[i].match(/(.+)\\((.+)\\)/);\n      const filename = match[1];\n      const content = match[2];\n      const fullPath = `${dir}/${filename}`;\n      \n      if (!contentMap.has(content)) {\n        contentMap.set(content, []);\n      }\n      contentMap.get(content).push(fullPath);\n    }\n  }\n  \n  return [...contentMap.values()].filter(arr => arr.length > 1);\n}"
  },
  {
    "id": 72,
    "question": "How do you find the First Missing Positive?",
    "answer": "**First Missing Positive** finds the smallest missing positive integer.\n\n**Key insight:**\n- Answer is in range [1, n+1]\n- Use array indices as hash (cyclic sort)\n- Place each number at index (number - 1)\n\n**Approach:**\n1. Place number x at index x-1 (if valid)\n2. Scan to find first missing\n\n**Time:** O(n)\n**Space:** O(1)\n\n**Related:**\n- Missing Number (0 to n)\n- Find All Numbers Disappeared",
    "example": "// First Missing Positive - O(n) time, O(1) space\nfunction firstMissingPositive(nums) {\n  const n = nums.length;\n  \n  // Place each number at correct index\n  // nums[i] should be at index nums[i] - 1\n  for (let i = 0; i < n; i++) {\n    while (nums[i] > 0 && nums[i] <= n && \n           nums[nums[i] - 1] !== nums[i]) {\n      // Swap nums[i] to its correct position\n      const correctIdx = nums[i] - 1;\n      [nums[i], nums[correctIdx]] = [nums[correctIdx], nums[i]];\n    }\n  }\n  \n  // Find first missing\n  for (let i = 0; i < n; i++) {\n    if (nums[i] !== i + 1) return i + 1;\n  }\n  \n  return n + 1;\n}\n\n// Alternative: Mark negatives approach\nfunction firstMissingPositiveAlt(nums) {\n  const n = nums.length;\n  \n  // Replace non-positives and > n with n+1\n  for (let i = 0; i < n; i++) {\n    if (nums[i] <= 0 || nums[i] > n) nums[i] = n + 1;\n  }\n  \n  // Mark presence by making index negative\n  for (let i = 0; i < n; i++) {\n    const num = Math.abs(nums[i]);\n    if (num <= n) {\n      nums[num - 1] = -Math.abs(nums[num - 1]);\n    }\n  }\n  \n  // First positive index + 1 is the answer\n  for (let i = 0; i < n; i++) {\n    if (nums[i] > 0) return i + 1;\n  }\n  \n  return n + 1;\n}\n\n// Find All Numbers Disappeared in Array\nfunction findDisappearedNumbers(nums) {\n  const result = [];\n  \n  // Mark presence by making index negative\n  for (const num of nums) {\n    const idx = Math.abs(num) - 1;\n    nums[idx] = -Math.abs(nums[idx]);\n  }\n  \n  // Positive values indicate missing numbers\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) result.push(i + 1);\n  }\n  \n  return result;\n}\n\n// Find All Duplicates in Array\nfunction findDuplicates(nums) {\n  const result = [];\n  \n  for (const num of nums) {\n    const idx = Math.abs(num) - 1;\n    if (nums[idx] < 0) {\n      result.push(Math.abs(num));  // Already marked = duplicate\n    } else {\n      nums[idx] = -nums[idx];\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 73,
    "question": "How do you find the Longest Consecutive Sequence?",
    "answer": "**Longest Consecutive Sequence** finds the longest sequence of consecutive integers.\n\n**Key insight:**\n- Use HashSet for O(1) lookup\n- Only start counting from sequence start (no num-1 in set)\n- Avoid counting from middle\n\n**Time:** O(n) - each number visited at most twice\n**Space:** O(n)\n\n**Why O(n)?**\n- Only start sequence at actual starts\n- Total inner loop iterations = total numbers",
    "example": "// Longest Consecutive Sequence - O(n)\nfunction longestConsecutive(nums) {\n  const numSet = new Set(nums);\n  let longest = 0;\n  \n  for (const num of numSet) {\n    // Only start from sequence beginning\n    if (!numSet.has(num - 1)) {\n      let currentNum = num;\n      let currentStreak = 1;\n      \n      while (numSet.has(currentNum + 1)) {\n        currentNum++;\n        currentStreak++;\n      }\n      \n      longest = Math.max(longest, currentStreak);\n    }\n  }\n  \n  return longest;\n}\n\n// Union-Find approach\nfunction longestConsecutiveUF(nums) {\n  if (nums.length === 0) return 0;\n  \n  const parent = new Map();\n  const size = new Map();\n  \n  function find(x) {\n    if (parent.get(x) !== x) {\n      parent.set(x, find(parent.get(x)));\n    }\n    return parent.get(x);\n  }\n  \n  function union(x, y) {\n    const px = find(x), py = find(y);\n    if (px === py) return;\n    \n    const sx = size.get(px), sy = size.get(py);\n    if (sx < sy) {\n      parent.set(px, py);\n      size.set(py, sx + sy);\n    } else {\n      parent.set(py, px);\n      size.set(px, sx + sy);\n    }\n  }\n  \n  const numSet = new Set(nums);\n  \n  for (const num of numSet) {\n    parent.set(num, num);\n    size.set(num, 1);\n  }\n  \n  for (const num of numSet) {\n    if (numSet.has(num + 1)) union(num, num + 1);\n    if (numSet.has(num - 1)) union(num, num - 1);\n  }\n  \n  return Math.max(...size.values());\n}\n\n// Binary Array Consecutive 1s\nfunction findMaxConsecutiveOnes(nums) {\n  let maxCount = 0;\n  let count = 0;\n  \n  for (const num of nums) {\n    if (num === 1) {\n      count++;\n      maxCount = Math.max(maxCount, count);\n    } else {\n      count = 0;\n    }\n  }\n  \n  return maxCount;\n}\n\n// Max Consecutive Ones III - Can flip at most k zeros\nfunction longestOnes(nums, k) {\n  let left = 0, zeros = 0, maxLen = 0;\n  \n  for (let right = 0; right < nums.length; right++) {\n    if (nums[right] === 0) zeros++;\n    \n    while (zeros > k) {\n      if (nums[left] === 0) zeros--;\n      left++;\n    }\n    \n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  \n  return maxLen;\n}"
  },
  {
    "id": 74,
    "question": "How do you generate Letter Combinations of a Phone Number?",
    "answer": "**Letter Combinations** generates all possible letter combinations from phone digits.\n\n**Phone mapping:**\n- 2: abc, 3: def, 4: ghi, 5: jkl\n- 6: mno, 7: pqrs, 8: tuv, 9: wxyz\n\n**Approach: Backtracking**\n- For each digit, try each letter\n- Build combinations recursively\n\n**Time:** O(4^n × n) - up to 4 letters per digit\n**Space:** O(n) for recursion depth\n\n**Also solvable with:**\n- BFS (iterative)\n- Cartesian product",
    "example": "// Letter Combinations - Backtracking\nfunction letterCombinations(digits) {\n  if (!digits.length) return [];\n  \n  const phone = {\n    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n  };\n  \n  const result = [];\n  \n  function backtrack(index, current) {\n    if (index === digits.length) {\n      result.push(current);\n      return;\n    }\n    \n    const letters = phone[digits[index]];\n    for (const letter of letters) {\n      backtrack(index + 1, current + letter);\n    }\n  }\n  \n  backtrack(0, '');\n  return result;\n}\n\n// Iterative BFS approach\nfunction letterCombinationsIterative(digits) {\n  if (!digits.length) return [];\n  \n  const phone = {\n    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n  };\n  \n  let result = [''];\n  \n  for (const digit of digits) {\n    const newResult = [];\n    const letters = phone[digit];\n    \n    for (const combination of result) {\n      for (const letter of letters) {\n        newResult.push(combination + letter);\n      }\n    }\n    \n    result = newResult;\n  }\n  \n  return result;\n}\n\n// All possible combinations of k numbers from 1 to n\nfunction combine(n, k) {\n  const result = [];\n  \n  function backtrack(start, current) {\n    if (current.length === k) {\n      result.push([...current]);\n      return;\n    }\n    \n    // Pruning: need k - current.length more elements\n    for (let i = start; i <= n - (k - current.length) + 1; i++) {\n      current.push(i);\n      backtrack(i + 1, current);\n      current.pop();\n    }\n  }\n  \n  backtrack(1, []);\n  return result;\n}\n\n// Generate IP Addresses from string\nfunction restoreIpAddresses(s) {\n  const result = [];\n  \n  function backtrack(index, parts) {\n    if (parts.length === 4) {\n      if (index === s.length) {\n        result.push(parts.join('.'));\n      }\n      return;\n    }\n    \n    for (let len = 1; len <= 3; len++) {\n      if (index + len > s.length) break;\n      \n      const part = s.substring(index, index + len);\n      \n      // Skip invalid: leading zero or > 255\n      if ((part.length > 1 && part[0] === '0') || parseInt(part) > 255) {\n        continue;\n      }\n      \n      parts.push(part);\n      backtrack(index + len, parts);\n      parts.pop();\n    }\n  }\n  \n  backtrack(0, []);\n  return result;\n}"
  },
  {
    "id": 75,
    "question": "How do you implement Pow(x, n) efficiently?",
    "answer": "**Pow(x, n)** computes x raised to the power n.\n\n**Naive approach:** O(n) - multiply n times\n\n**Binary Exponentiation:** O(log n)\n- x^n = (x^(n/2))^2 if n is even\n- x^n = x × (x^(n/2))^2 if n is odd\n\n**Handle edge cases:**\n- n = 0: return 1\n- n < 0: compute 1/x^(-n)\n- n = INT_MIN: special handling\n\n**Time:** O(log n)\n**Space:** O(log n) recursive, O(1) iterative",
    "example": "// Pow(x, n) - Recursive binary exponentiation\nfunction myPow(x, n) {\n  if (n === 0) return 1;\n  if (n < 0) {\n    x = 1 / x;\n    n = -n;\n  }\n  \n  function power(x, n) {\n    if (n === 0) return 1;\n    \n    const half = power(x, Math.floor(n / 2));\n    \n    if (n % 2 === 0) {\n      return half * half;\n    } else {\n      return half * half * x;\n    }\n  }\n  \n  return power(x, n);\n}\n\n// Iterative approach - O(log n) time, O(1) space\nfunction myPowIterative(x, n) {\n  if (n === 0) return 1;\n  \n  let N = Math.abs(n);\n  let result = 1;\n  let current = x;\n  \n  while (N > 0) {\n    if (N % 2 === 1) {\n      result *= current;\n    }\n    current *= current;\n    N = Math.floor(N / 2);\n  }\n  \n  return n < 0 ? 1 / result : result;\n}\n\n// Square root using binary search\nfunction mySqrt(x) {\n  if (x < 2) return x;\n  \n  let left = 2, right = Math.floor(x / 2);\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const square = mid * mid;\n    \n    if (square === x) return mid;\n    if (square < x) left = mid + 1;\n    else right = mid - 1;\n  }\n  \n  return right;\n}\n\n// Newton's method for sqrt\nfunction sqrtNewton(x) {\n  if (x < 2) return x;\n  \n  let guess = x / 2;\n  while (Math.abs(guess * guess - x) > 0.00001) {\n    guess = (guess + x / guess) / 2;\n  }\n  \n  return Math.floor(guess);\n}\n\n// Modular exponentiation (for large numbers)\nfunction modPow(base, exp, mod) {\n  let result = 1n;\n  base = BigInt(base) % BigInt(mod);\n  exp = BigInt(exp);\n  \n  while (exp > 0n) {\n    if (exp % 2n === 1n) {\n      result = (result * base) % BigInt(mod);\n    }\n    exp = exp / 2n;\n    base = (base * base) % BigInt(mod);\n  }\n  \n  return Number(result);\n}"
  },
  {
    "id": 76,
    "question": "How do you flatten a Nested List?",
    "answer": "**Flatten Nested List** converts a nested structure into a flat array or iterator.\n\n**Approaches:**\n\n**1. Recursive DFS**\n- If integer, add to result\n- If list, recurse into it\n\n**2. Stack-based Iterator**\n- Push elements in reverse order\n- Flatten lazily when needed\n\n**3. Generator function**\n- Yield integers, yield* nested lists\n\n**Applications:**\n- Flatten arrays of any depth\n- JSON traversal\n- Tree linearization",
    "example": "// Flatten array - Recursive\nfunction flatten(arr) {\n  const result = [];\n  \n  function helper(item) {\n    if (Array.isArray(item)) {\n      for (const elem of item) {\n        helper(elem);\n      }\n    } else {\n      result.push(item);\n    }\n  }\n  \n  helper(arr);\n  return result;\n}\n\n// Flatten with depth limit\nfunction flattenDepth(arr, depth = 1) {\n  if (depth === 0) return arr.slice();\n  \n  const result = [];\n  for (const item of arr) {\n    if (Array.isArray(item)) {\n      result.push(...flattenDepth(item, depth - 1));\n    } else {\n      result.push(item);\n    }\n  }\n  \n  return result;\n}\n\n// Flatten using reduce\nfunction flattenReduce(arr) {\n  return arr.reduce((flat, item) => \n    flat.concat(Array.isArray(item) ? flattenReduce(item) : item), []);\n}\n\n// Nested List Iterator - Stack based\nclass NestedIterator {\n  constructor(nestedList) {\n    this.stack = [...nestedList].reverse();\n  }\n\n  hasNext() {\n    while (this.stack.length) {\n      const top = this.stack[this.stack.length - 1];\n      \n      if (typeof top === 'number') {\n        return true;\n      }\n      \n      // It's a list - flatten it\n      this.stack.pop();\n      for (let i = top.length - 1; i >= 0; i--) {\n        this.stack.push(top[i]);\n      }\n    }\n    return false;\n  }\n\n  next() {\n    return this.stack.pop();\n  }\n}\n\n// Generator-based flattening\nfunction* flattenGenerator(arr) {\n  for (const item of arr) {\n    if (Array.isArray(item)) {\n      yield* flattenGenerator(item);\n    } else {\n      yield item;\n    }\n  }\n}\n\n// Usage\nconst nested = [1, [2, [3, 4]], [5, 6]];\nconsole.log(flatten(nested));  // [1, 2, 3, 4, 5, 6]\nconsole.log([...flattenGenerator(nested)]);  // [1, 2, 3, 4, 5, 6]\n\n// Flatten Object keys (nested to dot notation)\nfunction flattenObject(obj, prefix = '') {\n  const result = {};\n  \n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n    \n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      Object.assign(result, flattenObject(value, newKey));\n    } else {\n      result[newKey] = value;\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 77,
    "question": "How do you find a Peak Element?",
    "answer": "**Peak Element** is an element greater than its neighbors.\n\n**Key insight:**\n- nums[-1] and nums[n] are considered -∞\n- At least one peak always exists\n- Can use binary search!\n\n**Binary Search approach:**\n- If mid < mid+1, peak is on right\n- If mid > mid+1, peak is on left (or at mid)\n- Similar to \"finding in bitonic array\"\n\n**Time:** O(log n)\n**Space:** O(1)\n\n**Related:**\n- Find minimum in rotated array\n- Search in bitonic array",
    "example": "// Find Peak Element - Binary Search O(log n)\nfunction findPeakElement(nums) {\n  let left = 0, right = nums.length - 1;\n  \n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (nums[mid] > nums[mid + 1]) {\n      // Peak is on left side (including mid)\n      right = mid;\n    } else {\n      // Peak is on right side\n      left = mid + 1;\n    }\n  }\n  \n  return left;\n}\n\n// Find all peaks\nfunction findAllPeaks(nums) {\n  const peaks = [];\n  \n  for (let i = 0; i < nums.length; i++) {\n    const left = i === 0 ? -Infinity : nums[i - 1];\n    const right = i === nums.length - 1 ? -Infinity : nums[i + 1];\n    \n    if (nums[i] > left && nums[i] > right) {\n      peaks.push(i);\n    }\n  }\n  \n  return peaks;\n}\n\n// Find Peak in 2D Grid\nfunction findPeakGrid(mat) {\n  let left = 0, right = mat[0].length - 1;\n  \n  while (left <= right) {\n    const midCol = Math.floor((left + right) / 2);\n    \n    // Find row with max value in this column\n    let maxRow = 0;\n    for (let r = 0; r < mat.length; r++) {\n      if (mat[r][midCol] > mat[maxRow][midCol]) {\n        maxRow = r;\n      }\n    }\n    \n    // Check if it's a peak\n    const leftVal = midCol > 0 ? mat[maxRow][midCol - 1] : -1;\n    const rightVal = midCol < mat[0].length - 1 ? mat[maxRow][midCol + 1] : -1;\n    \n    if (mat[maxRow][midCol] > leftVal && mat[maxRow][midCol] > rightVal) {\n      return [maxRow, midCol];\n    }\n    \n    if (leftVal > mat[maxRow][midCol]) {\n      right = midCol - 1;\n    } else {\n      left = midCol + 1;\n    }\n  }\n  \n  return [-1, -1];\n}\n\n// Search in Bitonic Array (increases then decreases)\nfunction searchBitonic(arr, target) {\n  // Find peak\n  let left = 0, right = arr.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] < arr[mid + 1]) left = mid + 1;\n    else right = mid;\n  }\n  const peak = left;\n  \n  // Binary search in increasing part\n  let result = binarySearch(arr, target, 0, peak, true);\n  if (result !== -1) return result;\n  \n  // Binary search in decreasing part\n  return binarySearch(arr, target, peak + 1, arr.length - 1, false);\n}\n\nfunction binarySearch(arr, target, left, right, ascending) {\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    \n    if (ascending) {\n      if (arr[mid] < target) left = mid + 1;\n      else right = mid - 1;\n    } else {\n      if (arr[mid] < target) right = mid - 1;\n      else left = mid + 1;\n    }\n  }\n  return -1;\n}"
  },
  {
    "id": 78,
    "question": "How do you find Kth Smallest in a Sorted Matrix?",
    "answer": "**Kth Smallest** finds the kth smallest element in a row-wise and column-wise sorted matrix.\n\n**Approaches:**\n\n**1. Min-Heap**\n- Add first row to heap\n- Extract min k times, adding next element from same column\n- O(k log n) time\n\n**2. Binary Search on value**\n- Search for value where exactly k elements are <= it\n- Count elements <= mid in O(n)\n- O(n log(max-min)) time\n\n**Related:**\n- Merge K Sorted Lists\n- Find Kth Pair Sum",
    "example": "// Kth Smallest - Min Heap approach\nfunction kthSmallest(matrix, k) {\n  const n = matrix.length;\n  // Min heap: [value, row, col]\n  const heap = [];\n  \n  // Add first row\n  for (let j = 0; j < n; j++) {\n    heap.push([matrix[0][j], 0, j]);\n  }\n  heap.sort((a, b) => a[0] - b[0]);\n  \n  let result = 0;\n  for (let i = 0; i < k; i++) {\n    const [val, row, col] = heap.shift();\n    result = val;\n    \n    // Add next element from same column\n    if (row + 1 < n) {\n      heap.push([matrix[row + 1][col], row + 1, col]);\n      heap.sort((a, b) => a[0] - b[0]);\n    }\n  }\n  \n  return result;\n}\n\n// Binary Search on value - O(n log(max-min))\nfunction kthSmallestBS(matrix, k) {\n  const n = matrix.length;\n  let lo = matrix[0][0];\n  let hi = matrix[n - 1][n - 1];\n  \n  while (lo < hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    const count = countLessOrEqual(matrix, mid);\n    \n    if (count < k) {\n      lo = mid + 1;\n    } else {\n      hi = mid;\n    }\n  }\n  \n  return lo;\n}\n\n// Count elements <= target - O(n)\nfunction countLessOrEqual(matrix, target) {\n  const n = matrix.length;\n  let count = 0;\n  let row = n - 1, col = 0;\n  \n  // Start from bottom-left\n  while (row >= 0 && col < n) {\n    if (matrix[row][col] <= target) {\n      count += row + 1;  // All elements above are also <= target\n      col++;\n    } else {\n      row--;\n    }\n  }\n  \n  return count;\n}\n\n// Find Kth Smallest Pair Sum\nfunction kSmallestPairs(nums1, nums2, k) {\n  const result = [];\n  if (!nums1.length || !nums2.length) return result;\n  \n  // Min heap: [sum, i, j]\n  const heap = [];\n  for (let i = 0; i < Math.min(nums1.length, k); i++) {\n    heap.push([nums1[i] + nums2[0], i, 0]);\n  }\n  heap.sort((a, b) => a[0] - b[0]);\n  \n  while (heap.length && result.length < k) {\n    const [sum, i, j] = heap.shift();\n    result.push([nums1[i], nums2[j]]);\n    \n    if (j + 1 < nums2.length) {\n      heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n      heap.sort((a, b) => a[0] - b[0]);\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 79,
    "question": "How do you find Shortest Path in a Binary Matrix?",
    "answer": "**Shortest Path in Binary Matrix** finds the shortest path from top-left to bottom-right, moving in 8 directions.\n\n**Approach: BFS**\n- BFS guarantees shortest path in unweighted graph\n- Explore all 8 directions\n- Track visited cells\n\n**Time:** O(n²)\n**Space:** O(n²)\n\n**Variations:**\n- 4-directional movement\n- With obstacles\n- Multiple sources/destinations",
    "example": "// Shortest Path in Binary Matrix - BFS\nfunction shortestPathBinaryMatrix(grid) {\n  const n = grid.length;\n  if (grid[0][0] === 1 || grid[n - 1][n - 1] === 1) return -1;\n  \n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1],\n    [0, -1],           [0, 1],\n    [1, -1],  [1, 0],  [1, 1]\n  ];\n  \n  const queue = [[0, 0, 1]];  // [row, col, distance]\n  grid[0][0] = 1;  // Mark visited\n  \n  while (queue.length) {\n    const [row, col, dist] = queue.shift();\n    \n    if (row === n - 1 && col === n - 1) return dist;\n    \n    for (const [dr, dc] of directions) {\n      const nr = row + dr, nc = col + dc;\n      \n      if (nr >= 0 && nr < n && nc >= 0 && nc < n && grid[nr][nc] === 0) {\n        grid[nr][nc] = 1;  // Mark visited\n        queue.push([nr, nc, dist + 1]);\n      }\n    }\n  }\n  \n  return -1;\n}\n\n// Shortest Path with Obstacles Elimination\nfunction shortestPath(grid, k) {\n  const m = grid.length, n = grid[0].length;\n  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  \n  // [row, col, obstacles_removed, distance]\n  const queue = [[0, 0, 0, 0]];\n  // visited[r][c][obstacles] = true\n  const visited = new Set(['0,0,0']);\n  \n  while (queue.length) {\n    const [row, col, obs, dist] = queue.shift();\n    \n    if (row === m - 1 && col === n - 1) return dist;\n    \n    for (const [dr, dc] of directions) {\n      const nr = row + dr, nc = col + dc;\n      \n      if (nr >= 0 && nr < m && nc >= 0 && nc < n) {\n        const newObs = obs + grid[nr][nc];\n        const key = `${nr},${nc},${newObs}`;\n        \n        if (newObs <= k && !visited.has(key)) {\n          visited.add(key);\n          queue.push([nr, nc, newObs, dist + 1]);\n        }\n      }\n    }\n  }\n  \n  return -1;\n}\n\n// Walls and Gates - Fill rooms with distance to nearest gate\nfunction wallsAndGates(rooms) {\n  const m = rooms.length, n = rooms[0].length;\n  const INF = 2147483647;\n  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  \n  const queue = [];\n  \n  // Start BFS from all gates\n  for (let r = 0; r < m; r++) {\n    for (let c = 0; c < n; c++) {\n      if (rooms[r][c] === 0) queue.push([r, c]);\n    }\n  }\n  \n  while (queue.length) {\n    const [row, col] = queue.shift();\n    \n    for (const [dr, dc] of directions) {\n      const nr = row + dr, nc = col + dc;\n      \n      if (nr >= 0 && nr < m && nc >= 0 && nc < n && rooms[nr][nc] === INF) {\n        rooms[nr][nc] = rooms[row][col] + 1;\n        queue.push([nr, nc]);\n      }\n    }\n  }\n}\n\n// Rotting Oranges - Multi-source BFS\nfunction orangesRotting(grid) {\n  const m = grid.length, n = grid[0].length;\n  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n  const queue = [];\n  let fresh = 0;\n  \n  for (let r = 0; r < m; r++) {\n    for (let c = 0; c < n; c++) {\n      if (grid[r][c] === 2) queue.push([r, c]);\n      if (grid[r][c] === 1) fresh++;\n    }\n  }\n  \n  let minutes = 0;\n  while (queue.length && fresh > 0) {\n    minutes++;\n    const size = queue.length;\n    \n    for (let i = 0; i < size; i++) {\n      const [row, col] = queue.shift();\n      \n      for (const [dr, dc] of directions) {\n        const nr = row + dr, nc = col + dc;\n        if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] === 1) {\n          grid[nr][nc] = 2;\n          fresh--;\n          queue.push([nr, nc]);\n        }\n      }\n    }\n  }\n  \n  return fresh === 0 ? minutes : -1;\n}"
  },
  {
    "id": 80,
    "question": "How do you design a Hit Counter?",
    "answer": "**Hit Counter** counts hits in the last 5 minutes (300 seconds).\n\n**Approaches:**\n\n**1. Queue-based**\n- Store all timestamps\n- Remove old ones on query\n- Simple but uses more memory\n\n**2. Circular array**\n- Fixed size array of 300\n- Track timestamps and counts\n- O(1) space\n\n**Considerations:**\n- Thread safety for concurrent hits\n- Memory vs time trade-off\n- Handling burst traffic",
    "example": "// Hit Counter - Queue based\nclass HitCounter {\n  constructor() {\n    this.hits = [];\n  }\n\n  hit(timestamp) {\n    this.hits.push(timestamp);\n  }\n\n  getHits(timestamp) {\n    // Remove hits older than 300 seconds\n    while (this.hits.length && this.hits[0] <= timestamp - 300) {\n      this.hits.shift();\n    }\n    return this.hits.length;\n  }\n}\n\n// Hit Counter - Circular array (O(300) = O(1) space)\nclass HitCounterOptimized {\n  constructor() {\n    this.times = new Array(300).fill(0);\n    this.hits = new Array(300).fill(0);\n  }\n\n  hit(timestamp) {\n    const idx = timestamp % 300;\n    if (this.times[idx] !== timestamp) {\n      this.times[idx] = timestamp;\n      this.hits[idx] = 1;\n    } else {\n      this.hits[idx]++;\n    }\n  }\n\n  getHits(timestamp) {\n    let total = 0;\n    for (let i = 0; i < 300; i++) {\n      if (timestamp - this.times[i] < 300) {\n        total += this.hits[i];\n      }\n    }\n    return total;\n  }\n}\n\n// Logger Rate Limiter\nclass Logger {\n  constructor() {\n    this.messages = new Map();  // message -> timestamp\n  }\n\n  shouldPrintMessage(timestamp, message) {\n    if (!this.messages.has(message) || \n        timestamp - this.messages.get(message) >= 10) {\n      this.messages.set(message, timestamp);\n      return true;\n    }\n    return false;\n  }\n}\n\n// Moving Average from Data Stream\nclass MovingAverage {\n  constructor(size) {\n    this.size = size;\n    this.queue = [];\n    this.sum = 0;\n  }\n\n  next(val) {\n    this.queue.push(val);\n    this.sum += val;\n    \n    if (this.queue.length > this.size) {\n      this.sum -= this.queue.shift();\n    }\n    \n    return this.sum / this.queue.length;\n  }\n}\n\n// Rate Limiter - Token Bucket\nclass RateLimiter {\n  constructor(maxTokens, refillRate) {\n    this.maxTokens = maxTokens;\n    this.tokens = maxTokens;\n    this.refillRate = refillRate;  // tokens per second\n    this.lastRefill = Date.now();\n  }\n\n  allowRequest() {\n    this.refill();\n    \n    if (this.tokens >= 1) {\n      this.tokens--;\n      return true;\n    }\n    return false;\n  }\n\n  refill() {\n    const now = Date.now();\n    const elapsed = (now - this.lastRefill) / 1000;\n    const newTokens = elapsed * this.refillRate;\n    \n    this.tokens = Math.min(this.maxTokens, this.tokens + newTokens);\n    this.lastRefill = now;\n  }\n}"
  },
  {
    "id": 81,
    "question": "How do you merge Accounts by common emails?",
    "answer": "**Accounts Merge** groups accounts that share emails (same person).\n\n**Approach: Union-Find**\n- Each email points to a parent email\n- Union emails within same account\n- Group by root email\n\n**Alternative: DFS/BFS**\n- Build graph: email -> emails in same account\n- Find connected components\n\n**Time:** O(n × α(n)) with Union-Find\n**Space:** O(n)",
    "example": "// Accounts Merge - Union Find\nfunction accountsMerge(accounts) {\n  const parent = new Map();\n  const emailToName = new Map();\n  \n  function find(x) {\n    if (!parent.has(x)) parent.set(x, x);\n    if (parent.get(x) !== x) {\n      parent.set(x, find(parent.get(x)));\n    }\n    return parent.get(x);\n  }\n  \n  function union(x, y) {\n    parent.set(find(x), find(y));\n  }\n  \n  // Union all emails in each account\n  for (const account of accounts) {\n    const name = account[0];\n    const firstEmail = account[1];\n    \n    for (let i = 1; i < account.length; i++) {\n      emailToName.set(account[i], name);\n      union(account[i], firstEmail);\n    }\n  }\n  \n  // Group emails by root\n  const groups = new Map();\n  for (const email of emailToName.keys()) {\n    const root = find(email);\n    if (!groups.has(root)) groups.set(root, []);\n    groups.get(root).push(email);\n  }\n  \n  // Build result\n  const result = [];\n  for (const [root, emails] of groups) {\n    emails.sort();\n    result.push([emailToName.get(root), ...emails]);\n  }\n  \n  return result;\n}\n\n// DFS Approach\nfunction accountsMergeDFS(accounts) {\n  // Build graph: email -> set of connected emails\n  const graph = new Map();\n  const emailToName = new Map();\n  \n  for (const account of accounts) {\n    const name = account[0];\n    const firstEmail = account[1];\n    \n    for (let i = 1; i < account.length; i++) {\n      emailToName.set(account[i], name);\n      \n      if (!graph.has(account[i])) graph.set(account[i], new Set());\n      if (!graph.has(firstEmail)) graph.set(firstEmail, new Set());\n      \n      graph.get(account[i]).add(firstEmail);\n      graph.get(firstEmail).add(account[i]);\n    }\n  }\n  \n  // DFS to find connected components\n  const visited = new Set();\n  const result = [];\n  \n  for (const email of graph.keys()) {\n    if (visited.has(email)) continue;\n    \n    const component = [];\n    const stack = [email];\n    \n    while (stack.length) {\n      const curr = stack.pop();\n      if (visited.has(curr)) continue;\n      \n      visited.add(curr);\n      component.push(curr);\n      \n      for (const neighbor of graph.get(curr)) {\n        if (!visited.has(neighbor)) stack.push(neighbor);\n      }\n    }\n    \n    component.sort();\n    result.push([emailToName.get(email), ...component]);\n  }\n  \n  return result;\n}"
  },
  {
    "id": 82,
    "question": "How do you implement Random Pick with Weight?",
    "answer": "**Random Pick with Weight** selects index i with probability w[i] / sum(w).\n\n**Approach: Prefix Sum + Binary Search**\n1. Build prefix sum array\n2. Generate random number in [0, totalSum)\n3. Binary search to find which range it falls into\n\n**Time:**\n- Constructor: O(n)\n- pickIndex: O(log n)\n\n**Space:** O(n)\n\n**Related:**\n- Random Pick Index (reservoir sampling)\n- Shuffle an Array",
    "example": "// Random Pick with Weight\nclass Solution {\n  constructor(w) {\n    this.prefixSum = [];\n    let sum = 0;\n    \n    for (const weight of w) {\n      sum += weight;\n      this.prefixSum.push(sum);\n    }\n    \n    this.totalSum = sum;\n  }\n\n  pickIndex() {\n    // Random number in [0, totalSum)\n    const target = Math.random() * this.totalSum;\n    \n    // Binary search for first prefix sum > target\n    let left = 0, right = this.prefixSum.length - 1;\n    \n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.prefixSum[mid] <= target) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    \n    return left;\n  }\n}\n\n// Random Pick Index (with duplicates)\n// Return random index of target in nums\nclass RandomPickIndex {\n  constructor(nums) {\n    this.nums = nums;\n  }\n\n  pick(target) {\n    let count = 0;\n    let result = -1;\n    \n    // Reservoir sampling\n    for (let i = 0; i < this.nums.length; i++) {\n      if (this.nums[i] === target) {\n        count++;\n        // Probability 1/count to replace\n        if (Math.random() < 1 / count) {\n          result = i;\n        }\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Shuffle an Array (Fisher-Yates)\nclass ShuffleArray {\n  constructor(nums) {\n    this.original = [...nums];\n    this.array = nums;\n  }\n\n  reset() {\n    this.array = [...this.original];\n    return this.array;\n  }\n\n  shuffle() {\n    for (let i = this.array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [this.array[i], this.array[j]] = [this.array[j], this.array[i]];\n    }\n    return this.array;\n  }\n}\n\n// Random Point in Non-overlapping Rectangles\nclass RandomPointInRects {\n  constructor(rects) {\n    this.rects = rects;\n    this.prefixSum = [];\n    let sum = 0;\n    \n    for (const [x1, y1, x2, y2] of rects) {\n      // Number of points in rectangle\n      sum += (x2 - x1 + 1) * (y2 - y1 + 1);\n      this.prefixSum.push(sum);\n    }\n    \n    this.totalPoints = sum;\n  }\n\n  pick() {\n    const target = Math.floor(Math.random() * this.totalPoints);\n    \n    // Binary search for rectangle\n    let left = 0, right = this.rects.length - 1;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.prefixSum[mid] <= target) left = mid + 1;\n      else right = mid;\n    }\n    \n    // Random point within rectangle\n    const [x1, y1, x2, y2] = this.rects[left];\n    const x = x1 + Math.floor(Math.random() * (x2 - x1 + 1));\n    const y = y1 + Math.floor(Math.random() * (y2 - y1 + 1));\n    \n    return [x, y];\n  }\n}"
  },
  {
    "id": 83,
    "question": "How do you design Twitter?",
    "answer": "**Design Twitter** implements posting tweets, following users, and getting news feed.\n\n**Data structures:**\n- tweets: Map<userId, [{tweetId, timestamp}]>\n- following: Map<userId, Set<followeeIds>>\n- Global timestamp for ordering\n\n**getNewsFeed:**\n- Merge K sorted lists (user's + followees' tweets)\n- Use min-heap to get top 10\n\n**Time:**\n- postTweet, follow, unfollow: O(1)\n- getNewsFeed: O(k log n) where k = followees",
    "example": "// Design Twitter\nclass Twitter {\n  constructor() {\n    this.tweets = new Map();      // userId -> [{id, time}]\n    this.following = new Map();   // userId -> Set<followeeId>\n    this.timestamp = 0;\n  }\n\n  postTweet(userId, tweetId) {\n    if (!this.tweets.has(userId)) {\n      this.tweets.set(userId, []);\n    }\n    this.tweets.get(userId).unshift({\n      id: tweetId,\n      time: this.timestamp++\n    });\n  }\n\n  getNewsFeed(userId) {\n    // Get all users to fetch tweets from\n    const users = [userId];\n    if (this.following.has(userId)) {\n      users.push(...this.following.get(userId));\n    }\n\n    // Collect all tweets\n    const allTweets = [];\n    for (const user of users) {\n      if (this.tweets.has(user)) {\n        allTweets.push(...this.tweets.get(user));\n      }\n    }\n\n    // Sort by time descending, take top 10\n    allTweets.sort((a, b) => b.time - a.time);\n    return allTweets.slice(0, 10).map(t => t.id);\n  }\n\n  follow(followerId, followeeId) {\n    if (followerId === followeeId) return;\n    if (!this.following.has(followerId)) {\n      this.following.set(followerId, new Set());\n    }\n    this.following.get(followerId).add(followeeId);\n  }\n\n  unfollow(followerId, followeeId) {\n    if (this.following.has(followerId)) {\n      this.following.get(followerId).delete(followeeId);\n    }\n  }\n}\n\n// Design Twitter with Heap for efficient feed\nclass TwitterOptimized {\n  constructor() {\n    this.tweets = new Map();\n    this.following = new Map();\n    this.timestamp = 0;\n  }\n\n  postTweet(userId, tweetId) {\n    if (!this.tweets.has(userId)) this.tweets.set(userId, []);\n    this.tweets.get(userId).push({ id: tweetId, time: this.timestamp++ });\n  }\n\n  getNewsFeed(userId) {\n    // Max-heap approach using merge k sorted lists pattern\n    const heap = [];\n    \n    const addUserTweets = (uid) => {\n      const userTweets = this.tweets.get(uid);\n      if (userTweets && userTweets.length > 0) {\n        const idx = userTweets.length - 1;\n        heap.push([userTweets[idx].time, userTweets[idx].id, uid, idx]);\n      }\n    };\n    \n    addUserTweets(userId);\n    if (this.following.has(userId)) {\n      for (const followee of this.following.get(userId)) {\n        addUserTweets(followee);\n      }\n    }\n    \n    // Max-heap by time\n    heap.sort((a, b) => b[0] - a[0]);\n    \n    const result = [];\n    while (heap.length && result.length < 10) {\n      const [time, tweetId, uid, idx] = heap.shift();\n      result.push(tweetId);\n      \n      if (idx > 0) {\n        const tweets = this.tweets.get(uid);\n        heap.push([tweets[idx - 1].time, tweets[idx - 1].id, uid, idx - 1]);\n        heap.sort((a, b) => b[0] - a[0]);\n      }\n    }\n    \n    return result;\n  }\n\n  follow(followerId, followeeId) {\n    if (followerId === followeeId) return;\n    if (!this.following.has(followerId)) this.following.set(followerId, new Set());\n    this.following.get(followerId).add(followeeId);\n  }\n\n  unfollow(followerId, followeeId) {\n    this.following.get(followerId)?.delete(followeeId);\n  }\n}"
  },
  {
    "id": 84,
    "question": "How do you form the Largest Number from an Array?",
    "answer": "**Largest Number** arranges numbers to form the largest possible number.\n\n**Key insight:**\n- Custom comparator: compare (a+b) vs (b+a)\n- If \"ab\" > \"ba\", a should come before b\n\n**Edge case:**\n- All zeros: return \"0\" not \"000...\"\n\n**Time:** O(n log n) for sorting\n**Space:** O(n) for string conversion\n\n**Related:**\n- Smallest number from array\n- Lexicographically smallest string",
    "example": "// Largest Number\nfunction largestNumber(nums) {\n  // Convert to strings\n  const strs = nums.map(String);\n  \n  // Custom sort: compare a+b vs b+a\n  strs.sort((a, b) => (b + a).localeCompare(a + b));\n  \n  // Edge case: all zeros\n  if (strs[0] === '0') return '0';\n  \n  return strs.join('');\n}\n\n// Alternative using numeric comparison\nfunction largestNumberAlt(nums) {\n  const strs = nums.map(String);\n  \n  strs.sort((a, b) => {\n    const ab = a + b;\n    const ba = b + a;\n    // Compare as numbers (works for same length)\n    return ba > ab ? 1 : ba < ab ? -1 : 0;\n  });\n  \n  if (strs[0] === '0') return '0';\n  return strs.join('');\n}\n\n// Smallest Number (lexicographically)\nfunction smallestNumber(nums) {\n  const strs = nums.map(String);\n  strs.sort((a, b) => (a + b).localeCompare(b + a));\n  return strs.join('');\n}\n\n// Remove K Digits to make smallest number\nfunction removeKdigits(num, k) {\n  const stack = [];\n  \n  for (const digit of num) {\n    // Remove larger digits from stack\n    while (k > 0 && stack.length && stack[stack.length - 1] > digit) {\n      stack.pop();\n      k--;\n    }\n    stack.push(digit);\n  }\n  \n  // Remove remaining k digits from end\n  while (k > 0) {\n    stack.pop();\n    k--;\n  }\n  \n  // Remove leading zeros\n  const result = stack.join('').replace(/^0+/, '');\n  \n  return result || '0';\n}\n\n// Next Greater Element III (next permutation style)\nfunction nextGreaterElement(n) {\n  const digits = String(n).split('');\n  const len = digits.length;\n  \n  // Find first decreasing digit from right\n  let i = len - 2;\n  while (i >= 0 && digits[i] >= digits[i + 1]) i--;\n  \n  if (i < 0) return -1;  // Already largest permutation\n  \n  // Find smallest digit greater than digits[i] on right\n  let j = len - 1;\n  while (digits[j] <= digits[i]) j--;\n  \n  // Swap\n  [digits[i], digits[j]] = [digits[j], digits[i]];\n  \n  // Reverse suffix\n  let left = i + 1, right = len - 1;\n  while (left < right) {\n    [digits[left], digits[right]] = [digits[right], digits[left]];\n    left++;\n    right--;\n  }\n  \n  const result = parseInt(digits.join(''));\n  return result > 2147483647 ? -1 : result;\n}"
  },
  {
    "id": 85,
    "question": "How do you evaluate Reverse Polish Notation?",
    "answer": "**Reverse Polish Notation (RPN)** is postfix notation where operators come after operands.\n\n**Approach: Stack**\n- Push numbers onto stack\n- When operator: pop two operands, compute, push result\n- Final value is on stack\n\n**Example:**\n- [\"2\", \"1\", \"+\", \"3\", \"*\"] = (2+1)*3 = 9\n\n**Time:** O(n)\n**Space:** O(n)\n\n**Note:** Division truncates toward zero",
    "example": "// Evaluate Reverse Polish Notation\nfunction evalRPN(tokens) {\n  const stack = [];\n  const operators = new Set(['+', '-', '*', '/']);\n  \n  for (const token of tokens) {\n    if (operators.has(token)) {\n      const b = stack.pop();\n      const a = stack.pop();\n      let result;\n      \n      switch (token) {\n        case '+': result = a + b; break;\n        case '-': result = a - b; break;\n        case '*': result = a * b; break;\n        case '/': result = Math.trunc(a / b); break;  // Truncate toward zero\n      }\n      \n      stack.push(result);\n    } else {\n      stack.push(parseInt(token));\n    }\n  }\n  \n  return stack[0];\n}\n\n// Convert Infix to Postfix (Shunting-yard algorithm)\nfunction infixToPostfix(expression) {\n  const precedence = { '+': 1, '-': 1, '*': 2, '/': 2 };\n  const output = [];\n  const operators = [];\n  \n  const tokens = expression.match(/\\d+|[+\\-*/()]/g);\n  \n  for (const token of tokens) {\n    if (/\\d+/.test(token)) {\n      output.push(token);\n    } else if (token === '(') {\n      operators.push(token);\n    } else if (token === ')') {\n      while (operators.length && operators[operators.length - 1] !== '(') {\n        output.push(operators.pop());\n      }\n      operators.pop();  // Remove '('\n    } else {\n      while (operators.length && \n             operators[operators.length - 1] !== '(' &&\n             precedence[operators[operators.length - 1]] >= precedence[token]) {\n        output.push(operators.pop());\n      }\n      operators.push(token);\n    }\n  }\n  \n  while (operators.length) {\n    output.push(operators.pop());\n  }\n  \n  return output;\n}\n\n// Evaluate expression from string\nfunction evaluate(expression) {\n  const postfix = infixToPostfix(expression);\n  return evalRPN(postfix);\n}\n\n// Min Stack - Get minimum in O(1)\nclass MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n\n  push(val) {\n    this.stack.push(val);\n    const min = this.minStack.length === 0 ? val : \n                Math.min(val, this.minStack[this.minStack.length - 1]);\n    this.minStack.push(min);\n  }\n\n  pop() {\n    this.stack.pop();\n    this.minStack.pop();\n  }\n\n  top() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  getMin() {\n    return this.minStack[this.minStack.length - 1];\n  }\n}"
  },
  {
    "id": 86,
    "question": "How do you solve the 3Sum problem?",
    "answer": "**3Sum** finds all unique triplets that sum to zero.\n\n**Approach:**\n1. Sort the array\n2. Fix first element, use two pointers for rest\n3. Skip duplicates at all levels\n\n**Time:** O(n²)\n**Space:** O(1) excluding output\n\n**Variations:**\n- 3Sum Closest\n- 4Sum\n- kSum (generalized)",
    "example": "// 3Sum - Find triplets summing to 0\nfunction threeSum(nums) {\n  const result = [];\n  nums.sort((a, b) => a - b);\n  \n  for (let i = 0; i < nums.length - 2; i++) {\n    // Skip duplicates for first element\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    \n    // Early termination\n    if (nums[i] > 0) break;\n    \n    let left = i + 1, right = nums.length - 1;\n    \n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      \n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        \n        // Skip duplicates\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        \n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  \n  return result;\n}\n\n// 3Sum Closest\nfunction threeSumClosest(nums, target) {\n  nums.sort((a, b) => a - b);\n  let closest = nums[0] + nums[1] + nums[2];\n  \n  for (let i = 0; i < nums.length - 2; i++) {\n    let left = i + 1, right = nums.length - 1;\n    \n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      \n      if (Math.abs(sum - target) < Math.abs(closest - target)) {\n        closest = sum;\n      }\n      \n      if (sum < target) left++;\n      else if (sum > target) right--;\n      else return target;  // Exact match\n    }\n  }\n  \n  return closest;\n}\n\n// 4Sum\nfunction fourSum(nums, target) {\n  nums.sort((a, b) => a - b);\n  return kSum(nums, target, 4, 0);\n}\n\nfunction kSum(nums, target, k, start) {\n  const result = [];\n  \n  if (k === 2) {\n    let left = start, right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[left] + nums[right];\n      if (sum === target) {\n        result.push([nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < target) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  } else {\n    for (let i = start; i < nums.length - k + 1; i++) {\n      if (i > start && nums[i] === nums[i - 1]) continue;\n      \n      const subResults = kSum(nums, target - nums[i], k - 1, i + 1);\n      for (const sub of subResults) {\n        result.push([nums[i], ...sub]);\n      }\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 87,
    "question": "How do you traverse a matrix in Spiral order?",
    "answer": "**Spiral Matrix** traverses elements in spiral order (clockwise from outside in).\n\n**Approach: Layer by Layer**\n- Track four boundaries: top, bottom, left, right\n- Traverse: right → down → left → up\n- Shrink boundaries after each direction\n\n**Time:** O(m × n)\n**Space:** O(1) excluding output\n\n**Variations:**\n- Generate spiral matrix\n- Spiral Matrix II (fill numbers 1 to n²)",
    "example": "// Spiral Order - Traverse matrix in spiral\nfunction spiralOrder(matrix) {\n  const result = [];\n  if (!matrix.length) return result;\n  \n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    // Right\n    for (let col = left; col <= right; col++) {\n      result.push(matrix[top][col]);\n    }\n    top++;\n    \n    // Down\n    for (let row = top; row <= bottom; row++) {\n      result.push(matrix[row][right]);\n    }\n    right--;\n    \n    // Left (if still valid)\n    if (top <= bottom) {\n      for (let col = right; col >= left; col--) {\n        result.push(matrix[bottom][col]);\n      }\n      bottom--;\n    }\n    \n    // Up (if still valid)\n    if (left <= right) {\n      for (let row = bottom; row >= top; row--) {\n        result.push(matrix[row][left]);\n      }\n      left++;\n    }\n  }\n  \n  return result;\n}\n\n// Generate Spiral Matrix (fill 1 to n²)\nfunction generateMatrix(n) {\n  const matrix = Array(n).fill(null).map(() => Array(n).fill(0));\n  \n  let top = 0, bottom = n - 1;\n  let left = 0, right = n - 1;\n  let num = 1;\n  \n  while (top <= bottom && left <= right) {\n    for (let col = left; col <= right; col++) {\n      matrix[top][col] = num++;\n    }\n    top++;\n    \n    for (let row = top; row <= bottom; row++) {\n      matrix[row][right] = num++;\n    }\n    right--;\n    \n    if (top <= bottom) {\n      for (let col = right; col >= left; col--) {\n        matrix[bottom][col] = num++;\n      }\n      bottom--;\n    }\n    \n    if (left <= right) {\n      for (let row = bottom; row >= top; row--) {\n        matrix[row][left] = num++;\n      }\n      left++;\n    }\n  }\n  \n  return matrix;\n}\n\n// Diagonal Traverse\nfunction findDiagonalOrder(mat) {\n  const m = mat.length, n = mat[0].length;\n  const result = [];\n  let row = 0, col = 0;\n  let goingUp = true;\n  \n  while (result.length < m * n) {\n    result.push(mat[row][col]);\n    \n    if (goingUp) {\n      if (col === n - 1) {\n        row++;\n        goingUp = false;\n      } else if (row === 0) {\n        col++;\n        goingUp = false;\n      } else {\n        row--;\n        col++;\n      }\n    } else {\n      if (row === m - 1) {\n        col++;\n        goingUp = true;\n      } else if (col === 0) {\n        row++;\n        goingUp = true;\n      } else {\n        row++;\n        col--;\n      }\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": 88,
    "question": "How do you implement Insert Delete GetRandom in O(1)?",
    "answer": "**RandomizedSet** supports insert, delete, and getRandom all in O(1).\n\n**Key insight:**\n- Array for O(1) random access by index\n- HashMap for O(1) lookup (val -> index)\n- On delete: swap with last element to avoid shifting\n\n**Data structures:**\n- Array: stores values\n- Map: value -> array index\n\n**Time:** All operations O(1)\n**Space:** O(n)",
    "example": "// Insert Delete GetRandom O(1)\nclass RandomizedSet {\n  constructor() {\n    this.values = [];         // Array of values\n    this.indexMap = new Map(); // value -> index\n  }\n\n  insert(val) {\n    if (this.indexMap.has(val)) return false;\n    \n    this.indexMap.set(val, this.values.length);\n    this.values.push(val);\n    return true;\n  }\n\n  remove(val) {\n    if (!this.indexMap.has(val)) return false;\n    \n    const idx = this.indexMap.get(val);\n    const lastVal = this.values[this.values.length - 1];\n    \n    // Swap with last element\n    this.values[idx] = lastVal;\n    this.indexMap.set(lastVal, idx);\n    \n    // Remove last element\n    this.values.pop();\n    this.indexMap.delete(val);\n    \n    return true;\n  }\n\n  getRandom() {\n    const randomIdx = Math.floor(Math.random() * this.values.length);\n    return this.values[randomIdx];\n  }\n}\n\n// With duplicates allowed\nclass RandomizedCollection {\n  constructor() {\n    this.values = [];\n    this.indexMap = new Map();  // value -> Set of indices\n  }\n\n  insert(val) {\n    if (!this.indexMap.has(val)) {\n      this.indexMap.set(val, new Set());\n    }\n    \n    this.indexMap.get(val).add(this.values.length);\n    this.values.push(val);\n    \n    return this.indexMap.get(val).size === 1;\n  }\n\n  remove(val) {\n    if (!this.indexMap.has(val) || this.indexMap.get(val).size === 0) {\n      return false;\n    }\n    \n    // Get one index to remove\n    const idx = this.indexMap.get(val).values().next().value;\n    const lastIdx = this.values.length - 1;\n    const lastVal = this.values[lastIdx];\n    \n    // Swap with last\n    this.values[idx] = lastVal;\n    \n    // Update indices\n    this.indexMap.get(val).delete(idx);\n    this.indexMap.get(lastVal).delete(lastIdx);\n    if (idx < lastIdx) {\n      this.indexMap.get(lastVal).add(idx);\n    }\n    \n    this.values.pop();\n    \n    return true;\n  }\n\n  getRandom() {\n    return this.values[Math.floor(Math.random() * this.values.length)];\n  }\n}\n\n// Design HashMap\nclass MyHashMap {\n  constructor() {\n    this.size = 1000;\n    this.buckets = Array(this.size).fill(null).map(() => []);\n  }\n\n  _hash(key) {\n    return key % this.size;\n  }\n\n  put(key, value) {\n    const bucket = this.buckets[this._hash(key)];\n    for (const pair of bucket) {\n      if (pair[0] === key) {\n        pair[1] = value;\n        return;\n      }\n    }\n    bucket.push([key, value]);\n  }\n\n  get(key) {\n    const bucket = this.buckets[this._hash(key)];\n    for (const pair of bucket) {\n      if (pair[0] === key) return pair[1];\n    }\n    return -1;\n  }\n\n  remove(key) {\n    const bucket = this.buckets[this._hash(key)];\n    const idx = bucket.findIndex(p => p[0] === key);\n    if (idx !== -1) bucket.splice(idx, 1);\n  }\n}"
  }
]
