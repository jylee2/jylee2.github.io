[
  {
    "id": 1,
    "question": "What is an embedded system and how does it differ from a general-purpose computer?",
    "answer": "An **embedded system** is a computer system designed to perform specific, dedicated functions within a larger system.\n\n**Key differences from general-purpose computers:**\n\n- **Dedicated function**: Performs specific tasks vs. general computing\n- **Resource constrained**: Limited memory, processing power, storage\n- **Real-time requirements**: Often must respond within strict time limits\n- **Low power**: Designed for power efficiency, often battery-operated\n- **No user interface**: May have minimal or no direct user interaction\n- **Reliability**: Must operate continuously without crashes\n\n**Examples**: Microwave controllers, car ECUs, medical devices, IoT sensors",
    "example": "// Embedded system characteristics\n\n// 1. Resource constraints (typical microcontroller)\n// - Flash: 32KB - 512KB (program storage)\n// - RAM: 4KB - 64KB (runtime memory)\n// - Clock: 8MHz - 200MHz\n\n// 2. Dedicated function example (thermostat)\nvoid main(void) {\n    init_hardware();\n    \n    while(1) {  // Runs forever\n        float temp = read_temperature();\n        \n        if (temp < setpoint - HYSTERESIS) {\n            turn_on_heater();\n        } else if (temp > setpoint + HYSTERESIS) {\n            turn_off_heater();\n        }\n        \n        delay_ms(1000);  // Check every second\n    }\n}\n\n// 3. Real-time constraint example\n// Anti-lock braking system must respond within 10ms\n// Missed deadline = safety hazard"
  },
  {
    "id": 2,
    "question": "What is the difference between a microcontroller (MCU) and a microprocessor (MPU)?",
    "answer": "**Microcontroller (MCU)**:\n- Complete system on a single chip\n- Includes CPU, RAM, Flash, peripherals (GPIO, ADC, timers, UART)\n- Lower performance, lower cost\n- Used for dedicated control tasks\n- Examples: STM32, AVR, PIC, ESP32\n\n**Microprocessor (MPU)**:\n- CPU only, requires external components\n- Higher performance, more memory support\n- Needs external RAM, storage, peripherals\n- Used for complex computing tasks\n- Examples: ARM Cortex-A, Intel x86\n\n**SoC (System on Chip)**: Combines MPU power with integrated peripherals (Raspberry Pi's BCM chip)",
    "example": "// Microcontroller (STM32F103) - All-in-one\n// CPU: ARM Cortex-M3 @ 72MHz\n// Flash: 128KB (program storage)\n// RAM: 20KB\n// Built-in: GPIO, ADC, UART, SPI, I2C, Timers, DMA\n\n// Simple MCU program (no external components needed)\n#include \"stm32f1xx.h\"\n\nint main(void) {\n    // Enable GPIO clock\n    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;\n    \n    // Configure PC13 as output (onboard LED)\n    GPIOC->CRH &= ~GPIO_CRH_CNF13;\n    GPIOC->CRH |= GPIO_CRH_MODE13_0;\n    \n    while(1) {\n        GPIOC->ODR ^= GPIO_ODR_ODR13;  // Toggle LED\n        for(int i = 0; i < 1000000; i++);  // Delay\n    }\n}\n\n// Microprocessor (ARM Cortex-A) - Needs external:\n// - DDR RAM chips\n// - Flash/eMMC storage\n// - Power management IC\n// - Ethernet PHY, etc."
  },
  {
    "id": 3,
    "question": "What are GPIO pins and how do you configure them?",
    "answer": "**GPIO (General Purpose Input/Output)** pins are configurable digital pins that can be set as inputs or outputs.\n\n**Configurations:**\n- **Input**: Read external signals (buttons, sensors)\n- **Output**: Drive external devices (LEDs, relays)\n- **Alternate function**: Use for peripherals (UART, SPI, I2C)\n\n**Input modes:**\n- Floating (high impedance)\n- Pull-up (default high)\n- Pull-down (default low)\n\n**Output modes:**\n- Push-pull (drives high and low)\n- Open-drain (drives low only, needs external pull-up)\n\n**Speed/drive strength**: Affects slew rate and EMI",
    "example": "// STM32 HAL GPIO configuration\n#include \"stm32f4xx_hal.h\"\n\nvoid configure_gpio(void) {\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    \n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    \n    // Configure PA0 as input with pull-up (button)\n    GPIO_InitStruct.Pin = GPIO_PIN_0;\n    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;\n    GPIO_InitStruct.Pull = GPIO_PULLUP;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    \n    // Configure PA5 as output push-pull (LED)\n    GPIO_InitStruct.Pin = GPIO_PIN_5;\n    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n}\n\nvoid main_loop(void) {\n    // Read button (active low with pull-up)\n    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) {\n        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);  // LED on\n    } else {\n        HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); // LED off\n    }\n}"
  },
  {
    "id": 4,
    "question": "What are interrupts and why are they important in embedded systems?",
    "answer": "**Interrupts** are hardware signals that temporarily halt normal program execution to handle urgent events.\n\n**Why important:**\n- **Real-time response**: React immediately to events without polling\n- **Power efficiency**: CPU can sleep, wake on interrupt\n- **Deterministic timing**: Guaranteed response time\n- **Multitasking**: Handle multiple events efficiently\n\n**Types:**\n- **External**: GPIO pins, buttons, sensors\n- **Internal**: Timers, ADC completion, DMA, UART receive\n- **Exceptions**: Faults, system errors\n\n**Key concepts:**\n- **ISR (Interrupt Service Routine)**: Handler function\n- **Priority**: Higher priority interrupts preempt lower\n- **Latency**: Time from event to ISR execution\n- **Critical sections**: Code that disables interrupts",
    "example": "// STM32 External Interrupt Example\n#include \"stm32f4xx_hal.h\"\n\nvolatile uint32_t button_count = 0;  // volatile for ISR variables\n\nvoid EXTI0_IRQHandler(void) {\n    // Check if interrupt was from our pin\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_0) != RESET) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0);  // Clear flag\n        \n        button_count++;  // Handle event\n        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);  // Toggle LED\n    }\n}\n\nvoid configure_interrupt(void) {\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    \n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    \n    GPIO_InitStruct.Pin = GPIO_PIN_0;\n    GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  // Interrupt on falling edge\n    GPIO_InitStruct.Pull = GPIO_PULLUP;\n    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    \n    HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);  // Highest priority\n    HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n}\n\n// ISR best practices:\n// - Keep ISRs short\n// - Use volatile for shared variables\n// - Don't call blocking functions\n// - Clear interrupt flags"
  },
  {
    "id": 5,
    "question": "What is the difference between polling and interrupt-driven I/O?",
    "answer": "**Polling**:\n- CPU continuously checks device status in a loop\n- Simple to implement\n- Wastes CPU cycles waiting\n- Predictable timing but inefficient\n- Risk of missing events between checks\n\n**Interrupt-driven**:\n- CPU notified by hardware when event occurs\n- More complex (ISR, priority management)\n- CPU free for other tasks or sleep\n- Lower latency response\n- Better power efficiency\n\n**When to use each:**\n- **Polling**: Simple systems, tight timing loops, high-frequency events\n- **Interrupts**: Real-time response, low-power, multiple event sources",
    "example": "// POLLING approach - Checking UART for data\nvoid polling_uart(void) {\n    while(1) {\n        // Continuously check if data available\n        if (USART1->SR & USART_SR_RXNE) {  // Data received?\n            char c = USART1->DR;  // Read data\n            process_char(c);\n        }\n        // CPU busy-waiting, can't do other tasks\n    }\n}\n\n// INTERRUPT approach - React when data arrives\nvolatile char rx_buffer[64];\nvolatile uint8_t rx_index = 0;\n\nvoid USART1_IRQHandler(void) {\n    if (USART1->SR & USART_SR_RXNE) {\n        rx_buffer[rx_index++] = USART1->DR;\n        if (rx_index >= 64) rx_index = 0;\n    }\n}\n\nvoid main(void) {\n    // Enable UART interrupt\n    USART1->CR1 |= USART_CR1_RXNEIE;\n    NVIC_EnableIRQ(USART1_IRQn);\n    \n    while(1) {\n        // CPU free to do other work or sleep\n        do_other_tasks();\n        \n        // Process received data when available\n        if (rx_index > 0) {\n            process_buffer();\n        }\n        \n        __WFI();  // Wait for interrupt (low power)\n    }\n}"
  },
  {
    "id": 6,
    "question": "What is I2C and how does it work?",
    "answer": "**I2C (Inter-Integrated Circuit)** is a two-wire serial communication protocol for connecting multiple devices.\n\n**Characteristics:**\n- **Two wires**: SDA (data) and SCL (clock)\n- **Multi-master, multi-slave**: Multiple devices on same bus\n- **Addressing**: 7-bit or 10-bit device addresses\n- **Speed**: Standard (100kHz), Fast (400kHz), Fast+ (1MHz), High (3.4MHz)\n- **Half-duplex**: Bidirectional on single data line\n\n**Communication:**\n1. Master sends START condition\n2. Master sends slave address + R/W bit\n3. Slave ACKs if address matches\n4. Data transfer (ACK after each byte)\n5. Master sends STOP condition\n\n**Common uses**: Sensors, EEPROMs, RTCs, displays",
    "example": "// I2C communication with temperature sensor (LM75)\n#include \"stm32f4xx_hal.h\"\n\nI2C_HandleTypeDef hi2c1;\n#define LM75_ADDRESS  0x48 << 1  // 7-bit address shifted\n\nfloat read_temperature(void) {\n    uint8_t data[2];\n    uint8_t reg = 0x00;  // Temperature register\n    \n    // Write register address\n    HAL_I2C_Master_Transmit(&hi2c1, LM75_ADDRESS, &reg, 1, HAL_MAX_DELAY);\n    \n    // Read 2 bytes of temperature data\n    HAL_I2C_Master_Receive(&hi2c1, LM75_ADDRESS, data, 2, HAL_MAX_DELAY);\n    \n    // Convert to temperature (11-bit, 0.125°C resolution)\n    int16_t raw = (data[0] << 8) | data[1];\n    raw >>= 5;  // Right-align 11-bit value\n    \n    return raw * 0.125f;\n}\n\n// I2C bus scanning - find all devices\nvoid i2c_scan(void) {\n    printf(\"Scanning I2C bus...\\n\");\n    for (uint8_t addr = 1; addr < 128; addr++) {\n        if (HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 1, 10) == HAL_OK) {\n            printf(\"Device found at 0x%02X\\n\", addr);\n        }\n    }\n}"
  },
  {
    "id": 7,
    "question": "What is SPI and how does it differ from I2C?",
    "answer": "**SPI (Serial Peripheral Interface)** is a four-wire synchronous serial protocol.\n\n**SPI characteristics:**\n- **Four wires**: MOSI, MISO, SCK, CS (chip select)\n- **Full-duplex**: Simultaneous transmit and receive\n- **Single master, multiple slaves**: Separate CS for each slave\n- **High speed**: Up to 50+ MHz typical\n- **No addressing**: CS pin selects device\n\n**SPI vs I2C:**\n| Feature | SPI | I2C |\n|---------|-----|-----|\n| Wires | 4+ (more with slaves) | 2 |\n| Speed | Faster (MHz) | Slower (kHz) |\n| Duplex | Full | Half |\n| Addressing | CS pins | 7/10-bit address |\n| Distance | Short | Longer |\n| Complexity | Simple | More complex |",
    "example": "// SPI communication with SD card / Flash memory\n#include \"stm32f4xx_hal.h\"\n\nSPI_HandleTypeDef hspi1;\n\n#define CS_LOW()   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET)\n#define CS_HIGH()  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET)\n\nuint8_t spi_transfer(uint8_t data) {\n    uint8_t rx_data;\n    HAL_SPI_TransmitReceive(&hspi1, &data, &rx_data, 1, HAL_MAX_DELAY);\n    return rx_data;\n}\n\nuint8_t flash_read_status(void) {\n    uint8_t status;\n    \n    CS_LOW();\n    spi_transfer(0x05);  // Read Status Register command\n    status = spi_transfer(0xFF);  // Dummy byte to clock out data\n    CS_HIGH();\n    \n    return status;\n}\n\nvoid flash_read_data(uint32_t address, uint8_t *buffer, uint16_t length) {\n    CS_LOW();\n    spi_transfer(0x03);  // Read Data command\n    spi_transfer((address >> 16) & 0xFF);  // Address byte 2\n    spi_transfer((address >> 8) & 0xFF);   // Address byte 1\n    spi_transfer(address & 0xFF);          // Address byte 0\n    \n    for (uint16_t i = 0; i < length; i++) {\n        buffer[i] = spi_transfer(0xFF);  // Clock out data\n    }\n    CS_HIGH();\n}"
  },
  {
    "id": 8,
    "question": "What is UART and how is serial communication configured?",
    "answer": "**UART (Universal Asynchronous Receiver/Transmitter)** is an asynchronous serial communication protocol.\n\n**Key parameters:**\n- **Baud rate**: Bits per second (9600, 115200, etc.)\n- **Data bits**: 7, 8, or 9 bits\n- **Parity**: None, Even, Odd (error detection)\n- **Stop bits**: 1, 1.5, or 2 bits\n- **Flow control**: None, Hardware (RTS/CTS), Software (XON/XOFF)\n\n**Frame format:**\n`[Start bit][Data bits][Parity bit][Stop bit(s)]`\n\n**Common notation**: 115200 8N1 = 115200 baud, 8 data bits, No parity, 1 stop bit\n\n**Uses**: Debug console, GPS, Bluetooth modules, PC communication",
    "example": "// UART configuration and usage\n#include \"stm32f4xx_hal.h\"\n#include <stdio.h>\n#include <string.h>\n\nUART_HandleTypeDef huart2;\n\nvoid uart_init(void) {\n    huart2.Instance = USART2;\n    huart2.Init.BaudRate = 115200;\n    huart2.Init.WordLength = UART_WORDLENGTH_8B;\n    huart2.Init.StopBits = UART_STOPBITS_1;\n    huart2.Init.Parity = UART_PARITY_NONE;\n    huart2.Init.Mode = UART_MODE_TX_RX;\n    huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n    HAL_UART_Init(&huart2);\n}\n\nvoid uart_send_string(const char *str) {\n    HAL_UART_Transmit(&huart2, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);\n}\n\n// Redirect printf to UART (for debugging)\nint _write(int file, char *ptr, int len) {\n    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);\n    return len;\n}\n\n// Interrupt-based receive\nvolatile char rx_char;\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {\n    if (huart == &huart2) {\n        process_char(rx_char);\n        HAL_UART_Receive_IT(&huart2, (uint8_t*)&rx_char, 1);  // Re-enable\n    }\n}"
  },
  {
    "id": 9,
    "question": "What is PWM and what are its applications?",
    "answer": "**PWM (Pulse Width Modulation)** is a technique to control power/analog-like output using digital signals by varying the duty cycle.\n\n**Key parameters:**\n- **Frequency**: How often the signal cycles (Hz)\n- **Duty cycle**: Percentage of time signal is high (0-100%)\n- **Resolution**: Number of discrete duty cycle steps\n\n**Applications:**\n- **Motor control**: Speed control for DC motors, servos\n- **LED dimming**: Brightness control\n- **Power regulation**: DC-DC converters\n- **Audio generation**: Simple tones/beeps\n- **DAC alternative**: Analog output with filtering\n\n**Formula**: Average voltage = Duty cycle × Supply voltage",
    "example": "// PWM for LED dimming and servo control\n#include \"stm32f4xx_hal.h\"\n\nTIM_HandleTypeDef htim3;\n\nvoid pwm_init(void) {\n    // Timer configuration for 1kHz PWM\n    htim3.Instance = TIM3;\n    htim3.Init.Prescaler = 84 - 1;  // 84MHz / 84 = 1MHz\n    htim3.Init.Period = 1000 - 1;    // 1MHz / 1000 = 1kHz\n    htim3.Init.CounterMode = TIM_COUNTERMODE_UP;\n    HAL_TIM_PWM_Init(&htim3);\n    \n    TIM_OC_InitTypeDef sConfigOC = {0};\n    sConfigOC.OCMode = TIM_OCMODE_PWM1;\n    sConfigOC.Pulse = 500;  // 50% duty cycle initially\n    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;\n    HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);\n    \n    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);\n}\n\nvoid set_led_brightness(uint8_t percent) {\n    uint32_t pulse = (htim3.Init.Period + 1) * percent / 100;\n    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);\n}\n\n// Servo control (50Hz, 1-2ms pulse)\nvoid set_servo_angle(uint8_t angle) {\n    // 0° = 1ms pulse, 180° = 2ms pulse at 50Hz (20ms period)\n    uint32_t pulse = 1000 + (angle * 1000 / 180);  // 1000-2000us\n    __HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_1, pulse);\n}"
  },
  {
    "id": 10,
    "question": "What is an ADC and how do you use it for sensor reading?",
    "answer": "**ADC (Analog-to-Digital Converter)** converts continuous analog voltage to discrete digital values.\n\n**Key specifications:**\n- **Resolution**: Bits of precision (8, 10, 12-bit common)\n- **Reference voltage**: Maximum input voltage (Vref)\n- **Sampling rate**: Conversions per second\n- **Input channels**: Number of analog inputs\n- **INL/DNL**: Linearity errors\n\n**Conversion formula:**\n`Digital value = (Vin / Vref) × (2^resolution - 1)`\n\n**Modes:**\n- Single conversion\n- Continuous conversion\n- Scan mode (multiple channels)\n- DMA mode (high speed, no CPU intervention)",
    "example": "// ADC for reading temperature sensor (thermistor)\n#include \"stm32f4xx_hal.h\"\n#include <math.h>\n\nADC_HandleTypeDef hadc1;\n\nvoid adc_init(void) {\n    hadc1.Instance = ADC1;\n    hadc1.Init.Resolution = ADC_RESOLUTION_12B;  // 12-bit (0-4095)\n    hadc1.Init.ScanConvMode = DISABLE;\n    hadc1.Init.ContinuousConvMode = DISABLE;\n    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n    HAL_ADC_Init(&hadc1);\n    \n    ADC_ChannelConfTypeDef sConfig = {0};\n    sConfig.Channel = ADC_CHANNEL_0;  // PA0\n    sConfig.Rank = 1;\n    sConfig.SamplingTime = ADC_SAMPLETIME_144CYCLES;\n    HAL_ADC_ConfigChannel(&hadc1, &sConfig);\n}\n\nuint16_t read_adc(void) {\n    HAL_ADC_Start(&hadc1);\n    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);\n    return HAL_ADC_GetValue(&hadc1);\n}\n\nfloat read_temperature(void) {\n    uint16_t adc_value = read_adc();\n    \n    // Convert ADC to voltage (3.3V reference)\n    float voltage = adc_value * 3.3f / 4095.0f;\n    \n    // Thermistor calculation (Steinhart-Hart or lookup table)\n    // For NTC 10k with 10k divider:\n    float resistance = 10000.0f * voltage / (3.3f - voltage);\n    \n    // Simplified temperature calculation\n    float tempK = 1.0f / (log(resistance/10000.0f)/3950.0f + 1.0f/298.15f);\n    return tempK - 273.15f;  // Convert to Celsius\n}"
  },
  {
    "id": 11,
    "question": "What is DMA and why is it important for embedded systems?",
    "answer": "**DMA (Direct Memory Access)** allows peripherals to transfer data directly to/from memory without CPU intervention.\n\n**Benefits:**\n- **CPU offloading**: CPU free for other tasks during transfer\n- **High throughput**: Faster than CPU-driven transfers\n- **Real-time**: Guaranteed transfer rates\n- **Power efficiency**: CPU can sleep during transfers\n\n**Common uses:**\n- ADC sampling to buffer\n- UART TX/RX buffers\n- SPI/I2C data transfers\n- Memory-to-memory copy\n- Audio/video streaming\n\n**DMA modes:**\n- Normal: Single transfer\n- Circular: Continuous ring buffer\n- Double-buffer: Ping-pong between two buffers",
    "example": "// DMA for continuous ADC sampling\n#include \"stm32f4xx_hal.h\"\n\n#define ADC_BUFFER_SIZE 1024\nuint16_t adc_buffer[ADC_BUFFER_SIZE];\nvolatile uint8_t buffer_ready = 0;\n\nADC_HandleTypeDef hadc1;\nDMA_HandleTypeDef hdma_adc1;\n\nvoid adc_dma_init(void) {\n    // Configure DMA\n    hdma_adc1.Instance = DMA2_Stream0;\n    hdma_adc1.Init.Channel = DMA_CHANNEL_0;\n    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;\n    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;\n    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;\n    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;\n    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;\n    hdma_adc1.Init.Mode = DMA_CIRCULAR;  // Continuous\n    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;\n    HAL_DMA_Init(&hdma_adc1);\n    \n    __HAL_LINKDMA(&hadc1, DMA_Handle, hdma_adc1);\n    \n    // Start ADC with DMA\n    HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buffer, ADC_BUFFER_SIZE);\n}\n\n// Half-complete callback (first half ready)\nvoid HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {\n    process_samples(&adc_buffer[0], ADC_BUFFER_SIZE/2);\n}\n\n// Complete callback (second half ready)\nvoid HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {\n    process_samples(&adc_buffer[ADC_BUFFER_SIZE/2], ADC_BUFFER_SIZE/2);\n}"
  },
  {
    "id": 12,
    "question": "What is a watchdog timer and why is it important?",
    "answer": "A **Watchdog Timer (WDT)** is a hardware timer that resets the system if not periodically refreshed, preventing system hangs.\n\n**Purpose:**\n- Recover from software crashes\n- Detect infinite loops or deadlocks\n- Ensure system reliability\n- Required for safety-critical systems\n\n**Types:**\n- **Independent WDT (IWDG)**: Separate clock, runs even if main clock fails\n- **Window WDT (WWDG)**: Must be refreshed within a time window\n\n**Best practices:**\n- Feed watchdog in main loop\n- Don't feed in ISRs (masks main loop hangs)\n- Set timeout based on worst-case execution time\n- Consider window watchdog for tighter monitoring",
    "example": "// Watchdog Timer usage\n#include \"stm32f4xx_hal.h\"\n\nIWDG_HandleTypeDef hiwdg;\n\nvoid watchdog_init(void) {\n    hiwdg.Instance = IWDG;\n    hiwdg.Init.Prescaler = IWDG_PRESCALER_256;  // LSI/256\n    hiwdg.Init.Reload = 4095;  // Max value for ~32 seconds timeout\n    HAL_IWDG_Init(&hiwdg);\n}\n\nvoid watchdog_feed(void) {\n    HAL_IWDG_Refresh(&hiwdg);  // Reset countdown\n}\n\n// Main loop with watchdog\nint main(void) {\n    HAL_Init();\n    SystemClock_Config();\n    watchdog_init();\n    \n    while(1) {\n        // Normal operations\n        read_sensors();\n        process_data();\n        update_outputs();\n        \n        // Feed watchdog at end of each iteration\n        // If any function hangs, watchdog triggers reset\n        watchdog_feed();\n    }\n}\n\n// Check reset cause on startup\nvoid check_reset_source(void) {\n    if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST)) {\n        printf(\"Reset caused by watchdog!\\n\");\n        // Log event, enter safe mode, etc.\n    }\n    __HAL_RCC_CLEAR_RESET_FLAGS();\n}"
  },
  {
    "id": 13,
    "question": "What is real-time operating system (RTOS) and when should you use one?",
    "answer": "An **RTOS** is an operating system designed for applications with strict timing requirements, providing deterministic task scheduling.\n\n**Key features:**\n- **Preemptive scheduling**: Higher priority tasks interrupt lower\n- **Deterministic timing**: Predictable response times\n- **Task management**: Multiple concurrent tasks\n- **Synchronization**: Semaphores, mutexes, queues\n- **Memory management**: Static or dynamic allocation\n\n**When to use RTOS:**\n- Multiple time-critical tasks\n- Complex state machines\n- Need for task isolation\n- Power management (tickless idle)\n- Communication stacks (TCP/IP, USB)\n\n**Popular embedded RTOS**: FreeRTOS, Zephyr, ThreadX, RTEMS",
    "example": "// FreeRTOS basic example\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n#include \"semphr.h\"\n\nSemaphoreHandle_t dataMutex;\nTaskHandle_t sensorTaskHandle;\nTaskHandle_t displayTaskHandle;\n\n// High priority sensor reading task\nvoid vSensorTask(void *pvParameters) {\n    while(1) {\n        read_sensors();\n        \n        xSemaphoreTake(dataMutex, portMAX_DELAY);\n        update_shared_data();\n        xSemaphoreGive(dataMutex);\n        \n        vTaskDelay(pdMS_TO_TICKS(100));  // 100ms period\n    }\n}\n\n// Lower priority display task\nvoid vDisplayTask(void *pvParameters) {\n    while(1) {\n        xSemaphoreTake(dataMutex, portMAX_DELAY);\n        display_data();\n        xSemaphoreGive(dataMutex);\n        \n        vTaskDelay(pdMS_TO_TICKS(500));  // 500ms period\n    }\n}\n\nint main(void) {\n    HAL_Init();\n    SystemClock_Config();\n    \n    dataMutex = xSemaphoreCreateMutex();\n    \n    xTaskCreate(vSensorTask, \"Sensor\", 256, NULL, 2, &sensorTaskHandle);\n    xTaskCreate(vDisplayTask, \"Display\", 256, NULL, 1, &displayTaskHandle);\n    \n    vTaskStartScheduler();  // Start RTOS\n    \n    while(1);  // Should never reach here\n}"
  },
  {
    "id": 14,
    "question": "What is memory-mapped I/O and how do you access hardware registers?",
    "answer": "**Memory-mapped I/O** maps hardware peripheral registers to memory addresses, allowing access using standard load/store instructions.\n\n**Key concepts:**\n- **Register address**: Fixed memory location for each peripheral register\n- **Volatile**: Prevents compiler optimization of hardware accesses\n- **Bit manipulation**: Set, clear, toggle individual bits\n- **Atomic operations**: Some operations need to be uninterruptible\n\n**Common operations:**\n- Read register: `value = *register_address`\n- Write register: `*register_address = value`\n- Set bits: `*register |= (1 << bit_position)`\n- Clear bits: `*register &= ~(1 << bit_position)`\n- Toggle bits: `*register ^= (1 << bit_position)`",
    "example": "// Direct register access (STM32)\n#include <stdint.h>\n\n// Base addresses from datasheet\n#define GPIOA_BASE    0x40020000\n#define RCC_BASE      0x40023800\n\n// Register offsets\n#define GPIO_MODER    0x00\n#define GPIO_ODR      0x14\n#define RCC_AHB1ENR   0x30\n\n// Volatile pointer to register\n#define REG32(addr) (*(volatile uint32_t*)(addr))\n\nvoid led_init_direct(void) {\n    // Enable GPIOA clock\n    REG32(RCC_BASE + RCC_AHB1ENR) |= (1 << 0);  // GPIOAEN bit\n    \n    // Configure PA5 as output\n    // MODER5[1:0] = 01 (general purpose output)\n    REG32(GPIOA_BASE + GPIO_MODER) &= ~(3 << 10);  // Clear bits\n    REG32(GPIOA_BASE + GPIO_MODER) |= (1 << 10);   // Set output mode\n}\n\nvoid led_on(void) {\n    REG32(GPIOA_BASE + GPIO_ODR) |= (1 << 5);  // Set PA5 high\n}\n\nvoid led_off(void) {\n    REG32(GPIOA_BASE + GPIO_ODR) &= ~(1 << 5);  // Set PA5 low\n}\n\n// Using CMSIS-defined structures (cleaner)\n#include \"stm32f4xx.h\"\n\nvoid led_toggle_cmsis(void) {\n    GPIOA->ODR ^= GPIO_ODR_OD5;  // Toggle using defined constant\n}"
  },
  {
    "id": 15,
    "question": "What is the difference between bare-metal and RTOS-based firmware?",
    "answer": "**Bare-metal (super loop):**\n- No OS, code runs directly on hardware\n- Simple main loop architecture\n- Lower overhead, smaller footprint\n- Deterministic but harder to manage complexity\n- Manual task scheduling\n\n**RTOS-based:**\n- Operating system manages tasks\n- Preemptive multitasking\n- Built-in synchronization primitives\n- Easier to manage complexity\n- Some overhead (context switching, memory)\n\n**When to choose:**\n- **Bare-metal**: Simple systems, tight resources, ultimate control\n- **RTOS**: Complex systems, multiple priorities, need synchronization",
    "example": "// BARE-METAL approach (super loop)\nvoid main(void) {\n    init_hardware();\n    \n    uint32_t last_sensor_time = 0;\n    uint32_t last_display_time = 0;\n    \n    while(1) {\n        uint32_t now = get_tick_ms();\n        \n        // Time-sliced tasks\n        if (now - last_sensor_time >= 100) {\n            read_sensors();\n            last_sensor_time = now;\n        }\n        \n        if (now - last_display_time >= 500) {\n            update_display();\n            last_display_time = now;\n        }\n        \n        // Handle events\n        if (button_pressed) {\n            handle_button();\n        }\n    }\n}\n\n// RTOS approach (FreeRTOS)\nvoid main(void) {\n    init_hardware();\n    \n    // Create independent tasks with priorities\n    xTaskCreate(sensor_task, \"Sensor\", 256, NULL, 3, NULL);  // High priority\n    xTaskCreate(display_task, \"Display\", 256, NULL, 2, NULL);\n    xTaskCreate(button_task, \"Button\", 128, NULL, 1, NULL);  // Low priority\n    \n    vTaskStartScheduler();\n}\n\nvoid sensor_task(void *param) {\n    while(1) {\n        read_sensors();\n        vTaskDelay(pdMS_TO_TICKS(100));  // OS handles timing\n    }\n}"
  },
  {
    "id": 16,
    "question": "What is a bootloader in embedded systems?",
    "answer": "A **bootloader** is firmware that runs first at power-up, initializing hardware and loading the main application.\n\n**Functions:**\n- Initialize essential hardware (clocks, memory)\n- Check for firmware update request\n- Validate application integrity (CRC, signature)\n- Jump to main application\n- Provide firmware update capability\n\n**Update methods:**\n- UART/Serial\n- USB (DFU mode)\n- CAN bus\n- Over-the-Air (OTA)\n- SD card\n\n**Memory layout:**\n- Bootloader at start of flash (protected)\n- Application in remaining flash\n- Optional: Dual-bank for safe updates",
    "example": "// Simple bootloader structure\n#include <stdint.h>\n\n#define APP_ADDRESS      0x08008000  // Application start\n#define BOOTLOADER_SIZE  0x8000      // 32KB for bootloader\n\ntypedef void (*app_entry_t)(void);\n\nvoid jump_to_application(void) {\n    // Verify application exists (check stack pointer)\n    uint32_t app_stack = *(uint32_t*)APP_ADDRESS;\n    if (app_stack < 0x20000000 || app_stack > 0x20020000) {\n        return;  // Invalid application\n    }\n    \n    // Disable interrupts\n    __disable_irq();\n    \n    // Set vector table to application\n    SCB->VTOR = APP_ADDRESS;\n    \n    // Set stack pointer\n    __set_MSP(app_stack);\n    \n    // Get reset handler address and jump\n    app_entry_t app_entry = (app_entry_t)*(uint32_t*)(APP_ADDRESS + 4);\n    app_entry();\n}\n\nint main(void) {\n    init_hardware();\n    \n    // Check for update request (button held, UART command, etc.)\n    if (check_update_request()) {\n        receive_firmware_update();\n    }\n    \n    // Verify application CRC\n    if (!verify_application_crc()) {\n        enter_recovery_mode();\n    }\n    \n    jump_to_application();\n    \n    while(1);  // Should never reach here\n}"
  },
  {
    "id": 17,
    "question": "What is power management in embedded systems?",
    "answer": "**Power management** techniques minimize energy consumption, critical for battery-powered devices.\n\n**Sleep modes (typical ARM Cortex-M):**\n- **Sleep**: CPU stopped, peripherals running, fast wake\n- **Stop**: Most clocks stopped, RAM retained, slower wake\n- **Standby**: Lowest power, RAM lost, RTC can wake\n\n**Techniques:**\n- Use appropriate sleep mode for idle periods\n- Disable unused peripherals and clocks\n- Reduce clock frequency when possible\n- Use DMA instead of CPU polling\n- Optimize wake-up frequency\n- Use low-power peripherals (LPUART, LPTIM)\n\n**Wake-up sources:**\n- External interrupt (GPIO)\n- RTC alarm\n- Timer\n- Communication peripheral (UART, etc.)",
    "example": "// STM32 Low Power Example\n#include \"stm32l4xx_hal.h\"\n\nvoid enter_stop_mode(void) {\n    // Disable unused peripherals\n    __HAL_RCC_GPIOB_CLK_DISABLE();\n    __HAL_RCC_GPIOC_CLK_DISABLE();\n    \n    // Configure wake-up source (EXTI on PA0)\n    HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);\n    \n    // Enter STOP mode\n    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);\n    \n    // Code continues here after wake-up\n    SystemClock_Config();  // Restore clocks\n}\n\nvoid optimize_power(void) {\n    // 1. Reduce clock speed for low-demand periods\n    RCC_ClkInitTypeDef clk = {0};\n    clk.ClockType = RCC_CLOCKTYPE_SYSCLK;\n    clk.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;  // Low power oscillator\n    HAL_RCC_ClockConfig(&clk, FLASH_LATENCY_0);\n    \n    // 2. Use low-power timer\n    __HAL_RCC_LPTIM1_CLK_ENABLE();\n    \n    // 3. Disable unused GPIO (set to analog)\n    GPIO_InitTypeDef GPIO_InitStruct = {0};\n    GPIO_InitStruct.Pin = GPIO_PIN_All;\n    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;\n    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);\n}\n\n// Typical duty-cycled sensor node\nvoid sensor_loop(void) {\n    while(1) {\n        wake_up();\n        read_sensor();\n        transmit_data();\n        enter_stop_mode();  // Sleep for 10 seconds (RTC alarm)\n    }\n}"
  },
  {
    "id": 18,
    "question": "What are common debugging techniques for embedded systems?",
    "answer": "**Hardware debugging:**\n- **JTAG/SWD**: Full debug access (breakpoints, step, memory view)\n- **Logic analyzer**: Capture digital signals\n- **Oscilloscope**: Analog waveforms, timing analysis\n- **Multimeter**: Voltage, current measurements\n- **Serial wire viewer (SWV)**: Real-time trace\n\n**Software debugging:**\n- **Printf debugging**: UART output (use carefully)\n- **LED indicators**: Quick status indication\n- **Assertions**: Runtime checks\n- **Logging**: Circular buffer for post-mortem\n- **Stack analysis**: Detect overflows\n- **Memory guards**: Detect corruption\n\n**Common issues:**\n- Stack overflow\n- Interrupt priority conflicts\n- Race conditions\n- Hardware timing violations\n- Uninitialized variables",
    "example": "// Debugging utilities\n#include <stdio.h>\n#include <stdint.h>\n\n// 1. LED debugging - quick visual feedback\n#define DEBUG_LED_ON()   GPIOA->BSRR = GPIO_PIN_5\n#define DEBUG_LED_OFF()  GPIOA->BSRR = GPIO_PIN_5 << 16\n#define DEBUG_LED_TOGGLE() GPIOA->ODR ^= GPIO_PIN_5\n\n// 2. Printf via UART (ITM for SWV is faster)\n#define DEBUG_PRINT(...) printf(__VA_ARGS__)\n\n// 3. Assertions with file/line info\n#define ASSERT(expr) do { \\\n    if (!(expr)) { \\\n        printf(\"ASSERT FAILED: %s:%d\\n\", __FILE__, __LINE__); \\\n        while(1); \\\n    } \\\n} while(0)\n\n// 4. Stack overflow detection\n#define STACK_CANARY 0xDEADBEEF\nextern uint32_t _estack;\nvoid check_stack(void) {\n    if (*(uint32_t*)(&_estack - 256) != STACK_CANARY) {\n        printf(\"Stack overflow detected!\\n\");\n    }\n}\n\n// 5. Circular debug buffer (for post-mortem)\n#define LOG_SIZE 256\nchar debug_log[LOG_SIZE];\nuint16_t log_index = 0;\n\nvoid log_event(const char *msg) {\n    // Store in circular buffer for later analysis\n    uint16_t len = strlen(msg);\n    for (int i = 0; i < len; i++) {\n        debug_log[log_index++] = msg[i];\n        if (log_index >= LOG_SIZE) log_index = 0;\n    }\n}\n\n// 6. Timing measurement\nvoid measure_execution_time(void) {\n    DWT->CYCCNT = 0;  // Reset cycle counter\n    \n    critical_function();  // Function to measure\n    \n    uint32_t cycles = DWT->CYCCNT;\n    printf(\"Execution: %lu cycles\\n\", cycles);\n}"
  },
  {
    "id": 19,
    "question": "What is CAN bus and where is it used?",
    "answer": "**CAN (Controller Area Network)** is a robust serial bus designed for noisy environments, primarily automotive and industrial.\n\n**Characteristics:**\n- **Differential signaling**: Noise resistant\n- **Multi-master**: Any node can transmit\n- **Priority-based arbitration**: Message ID determines priority\n- **Error detection**: CRC, bit stuffing, acknowledgment\n- **Speeds**: Up to 1 Mbps (Classic CAN), 5 Mbps (CAN FD)\n\n**Message structure:**\n- **Identifier**: 11-bit (standard) or 29-bit (extended)\n- **Data**: 0-8 bytes (64 bytes for CAN FD)\n- **CRC**: Error checking\n\n**Applications:**\n- Automotive (ECUs, sensors, actuators)\n- Industrial automation\n- Medical equipment\n- Aerospace",
    "example": "// CAN bus communication (STM32)\n#include \"stm32f4xx_hal.h\"\n\nCAN_HandleTypeDef hcan1;\nCAN_TxHeaderTypeDef txHeader;\nCAN_RxHeaderTypeDef rxHeader;\nuint8_t txData[8];\nuint8_t rxData[8];\n\nvoid can_init(void) {\n    hcan1.Instance = CAN1;\n    hcan1.Init.Prescaler = 4;\n    hcan1.Init.Mode = CAN_MODE_NORMAL;\n    hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;\n    hcan1.Init.TimeSeg1 = CAN_BS1_13TQ;\n    hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;\n    hcan1.Init.AutoBusOff = ENABLE;\n    HAL_CAN_Init(&hcan1);\n    \n    // Configure filter to accept all messages\n    CAN_FilterTypeDef filter;\n    filter.FilterBank = 0;\n    filter.FilterMode = CAN_FILTERMODE_IDMASK;\n    filter.FilterScale = CAN_FILTERSCALE_32BIT;\n    filter.FilterIdHigh = 0;\n    filter.FilterIdLow = 0;\n    filter.FilterMaskIdHigh = 0;\n    filter.FilterMaskIdLow = 0;\n    filter.FilterFIFOAssignment = CAN_RX_FIFO0;\n    filter.FilterActivation = ENABLE;\n    HAL_CAN_ConfigFilter(&hcan1, &filter);\n    \n    HAL_CAN_Start(&hcan1);\n    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);\n}\n\nvoid can_send(uint16_t id, uint8_t *data, uint8_t len) {\n    txHeader.StdId = id;\n    txHeader.ExtId = 0;\n    txHeader.IDE = CAN_ID_STD;\n    txHeader.RTR = CAN_RTR_DATA;\n    txHeader.DLC = len;\n    \n    uint32_t mailbox;\n    HAL_CAN_AddTxMessage(&hcan1, &txHeader, data, &mailbox);\n}"
  },
  {
    "id": 20,
    "question": "What are volatile and const qualifiers and when should you use them?",
    "answer": "**volatile:**\n- Tells compiler variable can change unexpectedly\n- Prevents optimization of reads/writes\n- Required for: hardware registers, ISR-shared variables, memory-mapped I/O\n\n**const:**\n- Declares value won't change\n- Enables compiler optimizations\n- Can be placed in read-only memory (Flash)\n- Use for: configuration tables, lookup tables, string literals\n\n**Combined `const volatile`:**\n- Read-only from software perspective\n- But can change due to hardware\n- Example: hardware status registers",
    "example": "// volatile usage examples\n\n// 1. Hardware register - must use volatile\n#define GPIOA_IDR (*(volatile uint32_t*)0x40020010)\n\nvoid bad_wait_for_pin(void) {\n    while (GPIOA_IDR & 0x01);  // Without volatile, might optimize to infinite loop\n}\n\n// 2. Variable shared with ISR\nvolatile uint32_t tick_count = 0;\n\nvoid SysTick_Handler(void) {\n    tick_count++;  // Modified in ISR\n}\n\nvoid delay_ms(uint32_t ms) {\n    uint32_t start = tick_count;\n    while (tick_count - start < ms);  // Reads tick_count each iteration\n}\n\n// 3. const for read-only data in Flash\nconst uint16_t sin_table[256] = { /* values */ };  // Stored in Flash\nconst char version[] = \"v1.2.3\";  // String in Flash\n\n// Configuration structure in Flash\ntypedef struct {\n    uint32_t baud_rate;\n    uint8_t device_id;\n} Config_t;\n\nconst Config_t config __attribute__((section(\".config\"))) = {\n    .baud_rate = 115200,\n    .device_id = 0x42\n};\n\n// 4. const volatile - hardware status register\nconst volatile uint32_t * const ADC_STATUS = (uint32_t*)0x40012400;\n// Can't write to it, but value changes based on hardware state\n\nvoid wait_for_conversion(void) {\n    while (!(*ADC_STATUS & ADC_COMPLETE_FLAG));\n}"
  }
]
