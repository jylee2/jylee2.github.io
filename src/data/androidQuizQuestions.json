[
  {
    "id": 1,
    "question": "In Jetpack Compose, what does `remember` do?",
    "answer": "Stores a value in composition memory that survives recomposition but not configuration changes",
    "example": "// remember caches a value during composition\nval count = remember { mutableStateOf(0) }\n\n// Value survives recomposition\n// but is LOST on configuration changes (rotation)\n// For persistence across config changes, use rememberSaveable"
  },
  {
    "id": 2,
    "question": "What is the difference between `remember` and `rememberSaveable` in Jetpack Compose?",
    "answer": "`rememberSaveable` survives configuration changes and process death by using the saved instance state mechanism, while `remember` only survives recomposition",
    "example": "// Lost on rotation:\nvar text by remember { mutableStateOf(\"\") }\n\n// Survives rotation and process death:\nvar text by rememberSaveable { mutableStateOf(\"\") }\n\n// Custom object with Saver:\nval user by rememberSaveable(stateSaver = UserSaver) {\n    mutableStateOf(User())\n}"
  },
  {
    "id": 3,
    "question": "What is state hoisting in Jetpack Compose?",
    "answer": "A pattern where state is moved to a composable's caller to make the composable stateless, enabling reusability and testability",
    "example": "// Before hoisting (stateful):\n@Composable\nfun Counter() {\n    var count by remember { mutableStateOf(0) }\n    Button(onClick = { count++ }) { Text(\"$count\") }\n}\n\n// After hoisting (stateless):\n@Composable\nfun Counter(count: Int, onCountChange: (Int) -> Unit) {\n    Button(onClick = { onCountChange(count + 1) }) {\n        Text(\"$count\")\n    }\n}"
  },
  {
    "id": 4,
    "question": "Why are keys important in `LazyColumn` and `LazyRow`?",
    "answer": "Keys help Compose identify which items have changed, been added, or removed, enabling efficient recomposition and preserving item state across reorderings",
    "example": "LazyColumn {\n    items(\n        items = users,\n        key = { user -> user.id }  // Unique identifier\n    ) { user ->\n        UserCard(user)\n    }\n}\n\n// Without keys: positional tracking (buggy reordering)\n// With keys: identity tracking (correct state preservation)"
  },
  {
    "id": 5,
    "question": "What happens if you don't provide stable keys to `LazyColumn` items?",
    "answer": "Compose uses positional indices by default, which can cause incorrect state preservation when items are reordered, added, or removed",
    "example": "// Problem: TextField at index 2 has focus\n// Insert item at index 0\n// Focus incorrectly moves to new item at index 2!\n\n// Without keys:\nitems(users) { UserCard(it) }  // Uses position\n\n// With keys:\nitems(users, key = { it.id }) { UserCard(it) }  // Uses identity"
  },
  {
    "id": 6,
    "question": "What is recomposition in Jetpack Compose?",
    "answer": "The process of re-executing composable functions when their inputs change to update the UI, while skipping composables whose inputs haven't changed",
    "example": "@Composable\nfun Greeting(name: String) {  // Skipped if name unchanged\n    Text(\"Hello, $name\")\n}\n\n@Composable\nfun Parent() {\n    var count by remember { mutableStateOf(0) }\n    Greeting(\"World\")  // Skipped on count change\n    Text(\"Count: $count\")  // Recomposed on count change\n}"
  },
  {
    "id": 7,
    "question": "What is the purpose of `derivedStateOf` in Jetpack Compose?",
    "answer": "Creates a State object whose value is computed from other state objects and only updates when the computed result actually changes, reducing unnecessary recompositions",
    "example": "val listState = rememberLazyListState()\n\n// Without derivedStateOf: recomposes on EVERY scroll\nval showButton = listState.firstVisibleItemIndex > 0\n\n// With derivedStateOf: recomposes only when boolean changes\nval showButton by remember {\n    derivedStateOf { listState.firstVisibleItemIndex > 0 }\n}"
  },
  {
    "id": 8,
    "question": "What is a side effect in Jetpack Compose?",
    "answer": "Any change to app state that happens outside the scope of a composable function, such as showing a snackbar, navigating, or writing to a database",
    "example": "// LaunchedEffect for coroutines:\nLaunchedEffect(key) {\n    snackbarHostState.showSnackbar(message)\n}\n\n// DisposableEffect for cleanup:\nDisposableEffect(lifecycleOwner) {\n    val observer = LifecycleEventObserver { ... }\n    onDispose { lifecycle.removeObserver(observer) }\n}\n\n// SideEffect for non-suspend code:\nSideEffect { analytics.log(screenName) }"
  },
  {
    "id": 9,
    "question": "When should you use `LaunchedEffect` in Jetpack Compose?",
    "answer": "When you need to run a suspend function safely within a composable, tied to the composable's lifecycle and restarted when key parameters change",
    "example": "// Restarts when userId changes:\nLaunchedEffect(userId) {\n    viewModel.loadUser(userId)\n}\n\n// Runs once, never restarts:\nLaunchedEffect(Unit) {\n    viewModel.trackScreenView()\n}\n\n// Cancelled when composable leaves composition"
  },
  {
    "id": 10,
    "question": "What is `DisposableEffect` used for in Jetpack Compose?",
    "answer": "For side effects that require cleanup when the composable leaves the composition or when keys change, providing an onDispose callback",
    "example": "DisposableEffect(lifecycleOwner) {\n    val observer = LifecycleEventObserver { _, event ->\n        if (event == Lifecycle.Event.ON_RESUME) {\n            // Handle resume\n        }\n    }\n    lifecycleOwner.lifecycle.addObserver(observer)\n    \n    onDispose {\n        lifecycleOwner.lifecycle.removeObserver(observer)\n    }\n}"
  },
  {
    "id": 11,
    "question": "What is the difference between `StateFlow` and `SharedFlow` in Kotlin?",
    "answer": "`StateFlow` always has a current value and emits only distinct values, while `SharedFlow` can emit duplicate values and doesn't require an initial value",
    "example": "// StateFlow: has .value, emits only distinct\nprivate val _state = MutableStateFlow(UiState())\nval state: StateFlow<UiState> = _state\nval current = _state.value  // Always available\n\n// SharedFlow: no .value, can emit duplicates\nprivate val _events = MutableSharedFlow<Event>()\nval events: SharedFlow<Event> = _events\n// _events.value  // ERROR: no value property"
  },
  {
    "id": 12,
    "question": "What is the difference between a cold Flow and a hot Flow?",
    "answer": "Cold flows execute their producer block on each collection and emit values independently per collector, while hot flows emit values regardless of collectors and share emissions among all collectors",
    "example": "// Cold Flow: each collector triggers new execution\nval cold = flow {\n    emit(fetchData())  // Called per collector\n}\n\n// Hot Flow: shared among collectors\nval hot: StateFlow<Data> = cold\n    .stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5000),\n        initialValue = Data()\n    )"
  },
  {
    "id": 13,
    "question": "What does `flowOn` do in Kotlin Flow?",
    "answer": "Changes the coroutine context for upstream flow operations (emissions), but does not affect downstream operators or collection",
    "example": "flow { emit(heavyComputation()) }  // Runs on Default\n    .flowOn(Dispatchers.Default)    // Affects above only\n    .map { transform(it) }          // Runs on collector's context\n    .collect { updateUi(it) }       // Runs on collector's context\n\n// Multiple flowOn: each affects operations above it"
  },
  {
    "id": 14,
    "question": "What is `collectAsState` used for in Jetpack Compose?",
    "answer": "Collects values from a Flow and represents its latest value as Compose State, automatically triggering recomposition when new values are emitted",
    "example": "// For StateFlow (has initial value):\nval uiState by viewModel.uiState.collectAsState()\n\n// For regular Flow (needs initial value):\nval data by viewModel.dataFlow.collectAsState(initial = emptyList())\n\n// Handles lifecycle automatically in Compose"
  },
  {
    "id": 15,
    "question": "What is structured concurrency in Kotlin coroutines?",
    "answer": "A paradigm where coroutines are organized in a hierarchy through scopes, ensuring child coroutines complete before their parent and propagating cancellation automatically",
    "example": "coroutineScope {\n    launch { task1() }  // Child 1\n    launch { task2() }  // Child 2\n}  // Waits for both children\n\n// If task1 fails, task2 is cancelled\n\n// supervisorScope: children fail independently\nsupervisorScope {\n    launch { task1() }  // Failure doesn't affect task2\n    launch { task2() }\n}"
  },
  {
    "id": 16,
    "question": "What is the difference between `launch` and `async` in Kotlin coroutines?",
    "answer": "`launch` returns a Job and is fire-and-forget for side effects, while `async` returns a Deferred that can be awaited to get a result value",
    "example": "// launch: fire-and-forget, returns Job\nlaunch {\n    saveToDb(data)\n}\n\n// async: returns Deferred with result\nval a = async { fetchA() }\nval b = async { fetchB() }\nval result = process(a.await(), b.await())  // Parallel fetch"
  },
  {
    "id": 17,
    "question": "What happens when you call `await()` on a Deferred that threw an exception?",
    "answer": "The exception is re-thrown at the await() call site, allowing it to be caught with try-catch",
    "example": "val deferred = async {\n    throw IOException(\"Network error\")\n}\n\ntry {\n    deferred.await()\n} catch (e: IOException) {\n    handleError(e)\n}\n\n// Note: exception also propagates to parent scope\n// unless using supervisorScope"
  },
  {
    "id": 18,
    "question": "What is `viewModelScope` in Android?",
    "answer": "A CoroutineScope tied to a ViewModel's lifecycle that automatically cancels all coroutines when the ViewModel is cleared",
    "example": "class MyViewModel : ViewModel() {\n    fun loadData() {\n        viewModelScope.launch {\n            val data = repository.fetch()\n            _state.value = data\n        }\n    }\n}\n\n// Uses Dispatchers.Main.immediate by default\n// Automatically cancelled when ViewModel is cleared"
  },
  {
    "id": 19,
    "question": "What is the difference between `Dispatchers.IO` and `Dispatchers.Default`?",
    "answer": "`Dispatchers.IO` is optimized for blocking I/O operations with a larger thread pool, while `Dispatchers.Default` is optimized for CPU-intensive work with threads limited to CPU cores",
    "example": "// Default: CPU-bound (threads = CPU cores)\nwithContext(Dispatchers.Default) {\n    sortLargeList()\n    parseJson()\n}\n\n// IO: blocking operations (up to 64 threads)\nwithContext(Dispatchers.IO) {\n    file.readText()\n    networkCall()\n}"
  },
  {
    "id": 20,
    "question": "What is `Dispatchers.Main.immediate` and when should you use it?",
    "answer": "Executes immediately on the main thread if already on it, avoiding unnecessary redispatching; useful for UI updates that may already be on the main thread",
    "example": "// Dispatchers.Main: always posts to queue\nwithContext(Dispatchers.Main) {\n    textView.text = result  // Queued\n}\n\n// Main.immediate: skips queue if already on main\nwithContext(Dispatchers.Main.immediate) {\n    textView.text = result  // Immediate if on main\n}\n\n// viewModelScope uses Main.immediate by default"
  },
  {
    "id": 21,
    "question": "What is `SupervisorJob` and when would you use it?",
    "answer": "A Job where failure of a child doesn't cancel other children or the parent; used when you want independent child coroutines that shouldn't affect each other",
    "example": "val scope = CoroutineScope(\n    SupervisorJob() + Dispatchers.Main\n)\n\nscope.launch { networkCall1() }  // Failure here\nscope.launch { networkCall2() }  // Continues running\n\n// Or use supervisorScope:\nsupervisorScope {\n    launch { task1() }  // Independent\n    launch { task2() }  // Independent\n}"
  },
  {
    "id": 22,
    "question": "What is the difference between a foreground service and a background service in Android?",
    "answer": "A foreground service must show a persistent notification and has higher priority to avoid being killed, while a background service can be killed by the system when resources are low",
    "example": "// Foreground service:\nclass MusicService : Service() {\n    override fun onStartCommand(...): Int {\n        val notification = buildNotification()\n        startForeground(NOTIFICATION_ID, notification)\n        return START_STICKY\n    }\n}\n\n// Must call startForeground() within 5 seconds\n// For background work, prefer WorkManager"
  },
  {
    "id": 23,
    "question": "What is a bound service in Android?",
    "answer": "A service that allows components to bind to it via `bindService()`, providing a client-server interface for interaction, and is destroyed when all clients unbind",
    "example": "class MusicService : Service() {\n    private val binder = LocalBinder()\n    \n    inner class LocalBinder : Binder() {\n        fun getService() = this@MusicService\n    }\n    \n    override fun onBind(intent: Intent) = binder\n}\n\n// Client:\nbindService(intent, connection, Context.BIND_AUTO_CREATE)"
  },
  {
    "id": 24,
    "question": "What restrictions did Android 8.0 (Oreo) introduce for background services?",
    "answer": "Apps cannot start background services when in the background; they must use foreground services or JobScheduler/WorkManager instead",
    "example": "// This throws IllegalStateException from background:\nstartService(intent)\n\n// Solutions:\n// 1. Foreground service:\nstartForegroundService(intent)\n\n// 2. WorkManager:\nWorkManager.getInstance(context).enqueue(workRequest)\n\n// 3. Wait until app is in foreground"
  },
  {
    "id": 25,
    "question": "When should you use WorkManager instead of a foreground service?",
    "answer": "For deferrable, guaranteed background work that should persist across app restarts and device reboots, such as syncing data or uploading logs",
    "example": "val constraints = Constraints.Builder()\n    .setRequiredNetworkType(NetworkType.CONNECTED)\n    .build()\n\nval uploadWork = OneTimeWorkRequestBuilder<UploadWorker>()\n    .setConstraints(constraints)\n    .build()\n\nWorkManager.getInstance(context).enqueue(uploadWork)\n\n// Handles retries, constraints, and chaining"
  },
  {
    "id": 26,
    "question": "What is the difference between `onStop()` and `onDestroy()` in an Activity?",
    "answer": "`onStop()` is called when the activity is no longer visible but may still exist, while `onDestroy()` is called when the activity is being destroyed permanently",
    "example": "override fun onStop() {\n    super.onStop()\n    saveData()  // Activity may return\n}\n\noverride fun onDestroy() {\n    super.onDestroy()\n    cleanup()  // NOT guaranteed to be called!\n}\n\n// Lifecycle: onStop() -> onRestart() -> onStart() (if returning)\n// Or: onStop() -> onDestroy() (if finishing)"
  },
  {
    "id": 27,
    "question": "Why might `onDestroy()` not be called when an Activity is killed?",
    "answer": "The system may kill the process directly without calling `onDestroy()` in low-memory situations; critical cleanup should happen in `onStop()` or `onPause()`",
    "example": "// DON'T rely on onDestroy for important saves:\noverride fun onDestroy() {\n    saveUserData()  // May never be called!\n}\n\n// DO save in onStop:\noverride fun onStop() {\n    super.onStop()\n    saveUserData()  // Guaranteed to be called\n}\n\n// Use ViewModel + SavedStateHandle for state preservation"
  },
  {
    "id": 28,
    "question": "What is a ViewModel and why is it useful?",
    "answer": "A lifecycle-aware component that survives configuration changes like screen rotation, designed to store and manage UI-related data",
    "example": "class UserViewModel : ViewModel() {\n    private val _user = MutableStateFlow<User?>(null)\n    val user: StateFlow<User?> = _user\n}\n\n// In Activity:\nval viewModel: UserViewModel by viewModels()\n\n// Same instance after rotation!\n// Cleared only when Activity finishes permanently"
  },
  {
    "id": 29,
    "question": "How does a ViewModel survive configuration changes?",
    "answer": "ViewModels are stored in a ViewModelStore associated with the Activity/Fragment scope and retained across configuration changes by the framework",
    "example": "// ViewModelStore is retained across config changes\nclass MyActivity : AppCompatActivity() {\n    val viewModel: MyViewModel by viewModels()\n}\n\n// Rotation happens:\n// 1. Activity destroyed, but ViewModelStore retained\n// 2. Activity recreated\n// 3. viewModels() returns SAME ViewModel instance\n// 4. ViewModel cleared only on finish()"
  },
  {
    "id": 30,
    "question": "What is `SavedStateHandle` in ViewModel?",
    "answer": "A key-value map that allows ViewModel to save and restore state across process death, backed by the saved instance state mechanism",
    "example": "@HiltViewModel\nclass MyViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle\n) : ViewModel() {\n    \n    val query = savedStateHandle.getStateFlow(\"query\", \"\")\n    \n    fun setQuery(q: String) {\n        savedStateHandle[\"query\"] = q  // Survives process death\n    }\n}"
  },
  {
    "id": 31,
    "question": "What is the difference between `LiveData` and `StateFlow`?",
    "answer": "`LiveData` is lifecycle-aware and stops observing in stopped states, while `StateFlow` requires manual lifecycle handling but integrates better with coroutines",
    "example": "// LiveData: automatic lifecycle handling\nliveData.observe(owner) { value ->\n    updateUi(value)  // Stops in onStop automatically\n}\n\n// StateFlow: manual lifecycle handling needed\nlifecycleScope.launch {\n    repeatOnLifecycle(Lifecycle.State.STARTED) {\n        stateFlow.collect { updateUi(it) }\n    }\n}"
  },
  {
    "id": 32,
    "question": "What is `repeatOnLifecycle` and why is it important for Flow collection?",
    "answer": "A lifecycle-aware collector that restarts collection when lifecycle reaches the target state and cancels it when below; prevents wasting resources collecting when the UI is not visible",
    "example": "lifecycleScope.launch {\n    repeatOnLifecycle(Lifecycle.State.STARTED) {\n        viewModel.uiState.collect { state ->\n            updateUi(state)\n        }\n    }\n}\n\n// Collection pauses in onStop, resumes in onStart\n// In Compose, collectAsState() handles this automatically"
  },
  {
    "id": 33,
    "question": "What is dependency injection and why is it useful in Android?",
    "answer": "A design pattern where dependencies are provided to a class rather than created internally, improving testability, maintainability, and enabling loose coupling",
    "example": "// Without DI (hard to test):\nclass UserRepo {\n    val api = RetrofitClient.create()\n}\n\n// With DI (testable):\nclass UserRepo @Inject constructor(\n    private val api: ApiService\n)\n\n// In tests, inject mock:\nval repo = UserRepo(mockApi)"
  },
  {
    "id": 34,
    "question": "What is the difference between `@Inject` and `@Provides` in Hilt/Dagger?",
    "answer": "`@Inject` is used on constructors for automatic injection of classes you own, while `@Provides` is used in modules to provide instances of classes you don't own or need custom creation logic",
    "example": "// @Inject: classes you own\nclass UserRepository @Inject constructor(\n    private val api: Api\n)\n\n// @Provides: classes you don't own\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    fun provideRetrofit(): Retrofit =\n        Retrofit.Builder().build()\n}"
  },
  {
    "id": 35,
    "question": "What is the difference between `@Singleton` and `@ViewModelScoped` in Hilt?",
    "answer": "`@Singleton` creates one instance for the entire application lifetime, while `@ViewModelScoped` creates one instance per ViewModel that's destroyed when the ViewModel is cleared",
    "example": "@Singleton  // One instance for entire app\nclass ApiService @Inject constructor(...)\n\n@ViewModelScoped  // One instance per ViewModel\nclass ScreenStateHolder @Inject constructor(...)\n\n// Other scopes:\n// @ActivityScoped - per Activity\n// @FragmentScoped - per Fragment\n// @ActivityRetainedScoped - survives config changes"
  },
  {
    "id": 36,
    "question": "What is a memory leak in Android and what commonly causes them?",
    "answer": "When objects are no longer needed but cannot be garbage collected due to lingering references; common causes include static references to Context, unremoved listeners, and inner classes holding Activity references",
    "example": "// Memory leak: static holds Activity\ncompanion object {\n    var activity: Activity? = null  // LEAK!\n}\n\n// Memory leak: inner class holds Activity\ninner class MyHandler : Handler()  // LEAK!\n\n// Fixes:\n// - Use WeakReference\n// - Use applicationContext for long-lived objects\n// - Unregister listeners in onStop/onDestroy"
  },
  {
    "id": 37,
    "question": "Why should you avoid passing Activity context to long-lived objects?",
    "answer": "It prevents the Activity from being garbage collected after destruction, causing memory leaks; use Application context for long-lived objects instead",
    "example": "// BAD: Singleton holds Activity reference\nSingleton.init(this)  // Activity context - LEAK!\n\n// GOOD: Use application context\nSingleton.init(applicationContext)\n\n// For UI operations requiring Activity context:\nclass MyClass(context: WeakReference<Activity>)"
  },
  {
    "id": 38,
    "question": "What is the difference between implicit and explicit intents?",
    "answer": "Explicit intents specify the exact component to start by class name, while implicit intents declare a general action and let the system find appropriate components via intent filters",
    "example": "// Explicit: specify exact component\nval explicit = Intent(this, DetailActivity::class.java)\nstartActivity(explicit)\n\n// Implicit: system finds component\nval implicit = Intent(Intent.ACTION_VIEW).apply {\n    data = Uri.parse(\"https://example.com\")\n}\nif (implicit.resolveActivity(packageManager) != null) {\n    startActivity(implicit)\n}"
  },
  {
    "id": 39,
    "question": "What is a PendingIntent and when would you use it?",
    "answer": "A token that wraps an Intent and grants another app permission to execute it as your app; used for notifications, alarms, and app widgets",
    "example": "val intent = Intent(context, MainActivity::class.java)\nval pendingIntent = PendingIntent.getActivity(\n    context,\n    requestCode,\n    intent,\n    PendingIntent.FLAG_IMMUTABLE\n)\n\n// Used in notifications:\nNotificationCompat.Builder(context, channelId)\n    .setContentIntent(pendingIntent)\n    .build()"
  },
  {
    "id": 40,
    "question": "What is the difference between `FLAG_IMMUTABLE` and `FLAG_MUTABLE` for PendingIntent?",
    "answer": "`FLAG_IMMUTABLE` prevents the Intent from being modified when sent, improving security; `FLAG_MUTABLE` allows modification, required for inline reply actions in notifications",
    "example": "// Prefer IMMUTABLE for security:\nPendingIntent.getActivity(\n    context, 0, intent,\n    PendingIntent.FLAG_IMMUTABLE\n)\n\n// Use MUTABLE only when needed:\n// - Direct reply notifications\n// - Bubble notifications\nPendingIntent.getActivity(\n    context, 0, intent,\n    PendingIntent.FLAG_MUTABLE\n)"
  },
  {
    "id": 41,
    "question": "What is a Content Provider and when should you use one?",
    "answer": "A component that manages shared app data and provides a standard interface for other apps to query or modify it; used for sharing data between apps or accessing system data like contacts",
    "example": "// Query contacts:\nval cursor = contentResolver.query(\n    ContactsContract.Contacts.CONTENT_URI,\n    projection,\n    selection,\n    selectionArgs,\n    sortOrder\n)\n\n// Custom ContentProvider:\nclass MyProvider : ContentProvider() {\n    override fun query(...): Cursor { ... }\n    override fun insert(...): Uri { ... }\n}"
  },
  {
    "id": 42,
    "question": "What is the difference between `commit()` and `apply()` in SharedPreferences?",
    "answer": "`commit()` writes synchronously and returns success/failure, while `apply()` writes asynchronously in the background and returns immediately without a result",
    "example": "val prefs = getSharedPreferences(\"app\", MODE_PRIVATE)\n\n// apply(): async, no result, safe on main thread\nprefs.edit()\n    .putString(\"key\", \"value\")\n    .apply()\n\n// commit(): sync, returns boolean, blocks thread\nval success = prefs.edit()\n    .putString(\"key\", \"value\")\n    .commit()  // Use off main thread"
  },
  {
    "id": 43,
    "question": "What is Room and what are its main components?",
    "answer": "A persistence library providing an abstraction layer over SQLite; main components are Database (holder class), Entity (table definition), and DAO (data access methods)",
    "example": "@Entity\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String\n)\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAll(): Flow<List<User>>\n}\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}"
  },
  {
    "id": 44,
    "question": "What is the purpose of `@Transaction` annotation in Room?",
    "answer": "Ensures that all database operations within the annotated method are executed atomically; if any operation fails, all changes are rolled back",
    "example": "@Dao\ninterface UserDao {\n    @Transaction\n    suspend fun replaceUserPosts(\n        user: User,\n        posts: List<Post>\n    ) {\n        deletePostsForUser(user.id)\n        insertPosts(posts)\n        updateUser(user)\n    }  // All succeed or all rollback\n}"
  },
  {
    "id": 45,
    "question": "What is ProGuard/R8 and why is it important?",
    "answer": "Code shrinker and obfuscator that removes unused code, renames classes/methods, and optimizes bytecode to reduce APK size and make reverse engineering harder",
    "example": "// build.gradle:\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile(\n                'proguard-android-optimize.txt'\n            ), 'proguard-rules.pro'\n        }\n    }\n}\n\n// Reduces APK size by 10-40%"
  },
  {
    "id": 46,
    "question": "What does the `@Keep` annotation do?",
    "answer": "Prevents ProGuard/R8 from removing or renaming the annotated class, method, or field; used for code accessed via reflection or JNI",
    "example": "// Prevents shrinking/obfuscation:\n@Keep\ndata class ApiResponse(\n    val data: String,\n    val status: Int\n)\n\n// Alternative in proguard-rules.pro:\n// -keep class com.example.ApiResponse { *; }"
  },
  {
    "id": 47,
    "question": "What is the difference between `add()` and `replace()` in Fragment transactions?",
    "answer": "`add()` keeps existing fragments and adds a new one on top, while `replace()` removes all existing fragments in the container before adding the new one",
    "example": "// add(): keeps previous fragment\nsupportFragmentManager.commit {\n    add(R.id.container, FragmentB())  // A stays\n}\n\n// replace(): removes previous fragment\nsupportFragmentManager.commit {\n    replace(R.id.container, FragmentB())  // A removed\n    addToBackStack(null)  // A's view destroyed, restored on back\n}"
  },
  {
    "id": 48,
    "question": "What is `setReorderingAllowed(true)` in Fragment transactions?",
    "answer": "Allows the framework to optimize fragment operations by reordering and batching them, required for proper animations and transitions with Navigation component",
    "example": "supportFragmentManager.commit {\n    setReorderingAllowed(true)  // Enable optimizations\n    replace(R.id.container, fragment)\n    addToBackStack(null)\n}\n\n// Enables:\n// - Postponed transitions\n// - Shared element animations\n// - Navigation component sets this automatically"
  },
  {
    "id": 49,
    "question": "What is the purpose of `Modifier.semantics` in Jetpack Compose?",
    "answer": "Provides accessibility information to screen readers and testing frameworks by describing the meaning and behavior of UI elements",
    "example": "Image(\n    painter = painterResource(R.drawable.profile),\n    contentDescription = null,\n    modifier = Modifier.semantics {\n        contentDescription = \"User profile picture\"\n        role = Role.Image\n    }\n)\n\n// In tests:\ncomposeTestRule\n    .onNodeWithContentDescription(\"User profile picture\")\n    .assertIsDisplayed()"
  },
  {
    "id": 50,
    "question": "What is `CompositionLocal` and when should you use it?",
    "answer": "A way to pass data implicitly through the composition tree without explicit parameters; useful for theming, navigation, or other widely-used data, but should be used sparingly",
    "example": "// Define:\nval LocalNavController = compositionLocalOf<NavController> {\n    error(\"No NavController provided\")\n}\n\n// Provide:\nCompositionLocalProvider(LocalNavController provides navController) {\n    AppContent()\n}\n\n// Consume:\n@Composable\nfun Screen() {\n    val nav = LocalNavController.current\n}"
  },
  {
    "id": 51,
    "question": "What is the difference between `snapshotFlow` and `derivedStateOf`?",
    "answer": "`snapshotFlow` converts Compose State to a Flow for use outside composition, while `derivedStateOf` creates derived State for use within composition to prevent unnecessary recompositions",
    "example": "// snapshotFlow: State -> Flow (for LaunchedEffect)\nLaunchedEffect(Unit) {\n    snapshotFlow { scrollState.value }\n        .collect { analytics.logScroll(it) }\n}\n\n// derivedStateOf: derived State (for composition)\nval showButton by remember {\n    derivedStateOf { scrollState.value > 100 }\n}"
  },
  {
    "id": 52,
    "question": "What is `SideEffect` in Jetpack Compose?",
    "answer": "A composable that executes a block of code on every successful recomposition; used to publish Compose state to non-Compose code without launching coroutines",
    "example": "@Composable\nfun Screen(screenName: String) {\n    // Runs on every successful recomposition\n    SideEffect {\n        analytics.setCurrentScreen(screenName)\n    }\n    \n    // For suspend functions, use LaunchedEffect instead\n}"
  },
  {
    "id": 53,
    "question": "What does `@Stable` annotation indicate in Jetpack Compose?",
    "answer": "Tells the Compose compiler that a type's public properties will always return the same result for the same instance, enabling recomposition skipping optimizations",
    "example": "// Compose can skip recomposition when UiState unchanged\n@Stable\nclass UiState(\n    val items: List<Item>,\n    val loading: Boolean\n)\n\n// Data classes with immutable primitives are auto-stable\ndata class User(val id: Int, val name: String)  // Stable"
  },
  {
    "id": 54,
    "question": "What is the difference between `withContext` and `launch` for changing dispatchers?",
    "answer": "`withContext` suspends and switches context for a block of code then returns to the original context, while `launch` creates a new coroutine that runs independently on the specified dispatcher",
    "example": "// withContext: sequential, returns result\nval data = withContext(Dispatchers.IO) {\n    fetchData()  // Returns to original context after\n}\nprocess(data)  // Continues sequentially\n\n// launch: parallel, fire-and-forget\nlaunch(Dispatchers.IO) {\n    saveToDb()  // Runs independently\n}\nprocess(data)  // Continues immediately"
  },
  {
    "id": 55,
    "question": "What is `produceState` in Jetpack Compose?",
    "answer": "A composable that launches a coroutine scoped to the composition and allows producing State values over time, useful for converting non-Compose async sources to State",
    "example": "@Composable\nfun UserScreen(userId: String) {\n    val user by produceState<User?>(null, userId) {\n        value = repository.getUser(userId)\n    }\n    \n    // Combines remember + LaunchedEffect\n    // Coroutine cancels when leaving composition\n    // or when userId changes\n}"
  },
  {
    "id": 56,
    "question": "What is the difference between `catch` and `onCompletion` in Kotlin Flow?",
    "answer": "`catch` handles upstream exceptions and can emit recovery values, while `onCompletion` runs after the flow completes (successfully or with exception) but cannot emit values",
    "example": "flow { emit(fetchData()) }\n    .catch { e ->\n        emit(cachedData)  // Can emit fallback\n        // Only catches UPSTREAM exceptions\n    }\n    .onCompletion { cause ->\n        // cause is non-null if flow failed\n        // Cannot emit values here\n        hideLoading()\n    }\n    .collect { ... }"
  },
  {
    "id": 57,
    "question": "What is `stateIn` in Kotlin Flow and what are its sharing strategies?",
    "answer": "Converts a cold Flow to a hot StateFlow with sharing strategies: `Eagerly` starts immediately, `Lazily` starts on first subscriber, and `WhileSubscribed` starts/stops based on active subscribers",
    "example": "val uiState: StateFlow<UiState> = repository.dataFlow\n    .map { UiState(it) }\n    .stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5000),\n        initialValue = UiState.Loading\n    )\n\n// WhileSubscribed(5000): stops 5s after last subscriber\n// Useful for surviving configuration changes"
  },
  {
    "id": 58,
    "question": "What is `flatMapLatest` in Kotlin Flow?",
    "answer": "Transforms each emitted value into a new Flow and cancels the previous inner Flow when a new value arrives, keeping only the latest transformation active",
    "example": "searchQuery\n    .debounce(300)\n    .flatMapLatest { query ->\n        repository.search(query)  // New search cancels previous\n    }\n    .collect { results ->\n        showResults(results)\n    }\n\n// User types: \"a\" -> \"ab\" -> \"abc\"\n// Only \"abc\" search completes, others cancelled"
  },
  {
    "id": 59,
    "question": "What is the purpose of `Modifier.weight()` in Jetpack Compose?",
    "answer": "Distributes available space proportionally among siblings in a Row or Column based on weight values, similar to LinearLayout weight in XML",
    "example": "Row(Modifier.fillMaxWidth()) {\n    Box(Modifier.weight(1f).background(Color.Red))\n    Box(Modifier.weight(2f).background(Color.Blue))\n}\n\n// Red gets 1/3, Blue gets 2/3 of width\n\n// fill parameter controls cross-axis:\nModifier.weight(1f, fill = false)  // Only takes needed height"
  },
  {
    "id": 60,
    "question": "What is `WindowInsets` in Jetpack Compose and why is it important?",
    "answer": "Represents system UI areas like status bar, navigation bar, and keyboard that overlap with app content; handling insets properly ensures content isn't obscured",
    "example": "Scaffold(\n    modifier = Modifier.fillMaxSize()\n) { innerPadding ->\n    LazyColumn(\n        contentPadding = innerPadding\n    ) { ... }\n}\n\n// Or handle manually:\nModifier.windowInsetsPadding(WindowInsets.systemBars)\nModifier.imePadding()  // Keyboard insets"
  },
  {
    "id": 61,
    "question": "What is the difference between `combine` and `zip` in Kotlin Flow?",
    "answer": "`combine` emits when any source flow emits using the latest values from all flows, while `zip` pairs emissions from flows and only emits when all flows have a new value",
    "example": "// combine: emits on any emission\ncombine(flow1, flow2) { a, b -> a + b }\n// flow1: 1--2--3\n// flow2: --A----B\n// out:   -1A-2A-3B\n\n// zip: pairs emissions\nflow1.zip(flow2) { a, b -> a + b }\n// flow1: 1--2--3\n// flow2: --A----B\n// out:   --1A---2B (3 waits for next)"
  },
  {
    "id": 62,
    "question": "What is `LazyVerticalGrid` in Jetpack Compose?",
    "answer": "A composable that displays items in a scrollable grid layout, supporting fixed column counts or adaptive columns that adjust based on available width",
    "example": "// Fixed columns:\nLazyVerticalGrid(\n    columns = GridCells.Fixed(2)\n) { items(photos) { PhotoCard(it) } }\n\n// Adaptive: as many columns as fit with min width\nLazyVerticalGrid(\n    columns = GridCells.Adaptive(minSize = 128.dp)\n) { items(photos) { PhotoCard(it) } }"
  },
  {
    "id": 63,
    "question": "What is a `CoroutineExceptionHandler` and when should you use it?",
    "answer": "A context element that handles uncaught exceptions in coroutines; used as a last resort for logging or crash reporting, but doesn't prevent coroutine cancellation",
    "example": "val handler = CoroutineExceptionHandler { _, exception ->\n    Log.e(\"App\", \"Uncaught exception\", exception)\n    crashReporter.report(exception)\n}\n\nval scope = CoroutineScope(\n    SupervisorJob() + Dispatchers.Main + handler\n)\n\n// Note: handler only works with launch, not async"
  },
  {
    "id": 64,
    "question": "What is `ensureActive()` in Kotlin coroutines?",
    "answer": "Checks if the current coroutine is still active and throws CancellationException if cancelled; used in long-running loops to make cancellation cooperative",
    "example": "suspend fun processLargeList(items: List<Item>) {\n    items.forEach { item ->\n        ensureActive()  // Throws if cancelled\n        processItem(item)\n    }\n}\n\n// Alternative: check isActive\nwhile (isActive) {\n    doWork()\n}"
  },
  {
    "id": 65,
    "question": "What is `NonCancellable` in Kotlin coroutines?",
    "answer": "A Job that cannot be cancelled; used with withContext to ensure cleanup code runs even when the coroutine is cancelled",
    "example": "suspend fun closeResources() {\n    try {\n        doWork()\n    } finally {\n        // This code MUST run even if cancelled\n        withContext(NonCancellable) {\n            saveState()  // Suspend function in finally\n            closeConnection()\n        }\n    }\n}"
  },
  {
    "id": 66,
    "question": "What is Android App Startup library and when should you use it?",
    "answer": "A library that initializes components at app startup in a defined order with lazy initialization support; use it to reduce startup time and manage initialization dependencies",
    "example": "class WorkManagerInitializer : Initializer<WorkManager> {\n    override fun create(context: Context): WorkManager {\n        val config = Configuration.Builder().build()\n        WorkManager.initialize(context, config)\n        return WorkManager.getInstance(context)\n    }\n    \n    override fun dependencies() = emptyList<Class<Initializer<*>>>()\n}"
  },
  {
    "id": 67,
    "question": "What is the difference between `Modifier.clickable` and `Modifier.pointerInput` in Jetpack Compose?",
    "answer": "`clickable` is a high-level modifier for tap handling with accessibility support, while `pointerInput` provides low-level gesture detection for custom interactions",
    "example": "// clickable: simple taps with accessibility\nBox(Modifier.clickable { onClick() })\n\n// pointerInput: custom gestures\nBox(Modifier.pointerInput(Unit) {\n    detectTapGestures(\n        onLongPress = { offset -> },\n        onDoubleTap = { offset -> },\n        onTap = { offset -> }\n    )\n})"
  },
  {
    "id": 68,
    "question": "What is `rememberCoroutineScope` in Jetpack Compose?",
    "answer": "Returns a CoroutineScope bound to the composition that's cancelled when the composable leaves composition; used to launch coroutines from callbacks",
    "example": "@Composable\nfun MyScreen() {\n    val scope = rememberCoroutineScope()\n    val snackbarHostState = remember { SnackbarHostState() }\n    \n    Button(onClick = {\n        scope.launch {\n            snackbarHostState.showSnackbar(\"Message\")\n        }\n    }) { Text(\"Show Snackbar\") }\n}"
  },
  {
    "id": 69,
    "question": "What is the purpose of `@Immutable` annotation in Jetpack Compose?",
    "answer": "Promises to the Compose compiler that all public properties will never change after construction, enabling aggressive recomposition skipping for performance",
    "example": "@Immutable\ndata class Theme(\n    val primary: Color,\n    val background: Color\n)\n\n// All properties must be val (not var)\n// Collections must be immutable (List, not MutableList)\n// Nested objects must also be @Immutable or @Stable"
  },
  {
    "id": 70,
    "question": "What is `Channel` in Kotlin coroutines and how does it differ from Flow?",
    "answer": "A hot stream for one-time events between coroutines with send/receive semantics; unlike Flow, channels are consumed exactly once and support buffering strategies",
    "example": "// Channel: one-time events (navigation, snackbar)\nval events = Channel<UiEvent>(Channel.BUFFERED)\n\n// Send:\nevents.send(UiEvent.NavigateBack)\n\n// Receive:\nfor (event in events) { handleEvent(event) }\n\n// Flow: state/data streams (can have multiple collectors)"
  },
  {
    "id": 71,
    "question": "What are the different Channel buffer overflow strategies?",
    "answer": "`SUSPEND` blocks sender when full, `DROP_OLDEST` discards oldest element, `DROP_LATEST` discards newest element, and `BUFFERED` uses default buffer size",
    "example": "// SUSPEND: sender waits (default for Channel())\nChannel<Int>(capacity = 10, onBufferOverflow = BufferOverflow.SUSPEND)\n\n// DROP_OLDEST: like conflated, keeps latest\nChannel<Int>(Channel.CONFLATED)  // or onBufferOverflow = DROP_OLDEST\n\n// DROP_LATEST: discards new values when full\nChannel<Int>(capacity = 1, onBufferOverflow = BufferOverflow.DROP_LATEST)"
  },
  {
    "id": 72,
    "question": "What is `Mutex` in Kotlin coroutines?",
    "answer": "A mutual exclusion primitive for coroutines that ensures only one coroutine can execute a critical section at a time; unlike synchronized blocks, it suspends instead of blocking",
    "example": "class Counter {\n    private val mutex = Mutex()\n    private var count = 0\n    \n    suspend fun increment() {\n        mutex.withLock {\n            count++  // Only one coroutine at a time\n        }\n    }\n}\n\n// Never use synchronized in coroutines - it blocks threads!"
  },
  {
    "id": 73,
    "question": "What is the purpose of `@TypeConverter` in Room?",
    "answer": "Converts complex types to/from types Room can persist; annotate methods that convert between the custom type and a primitive type like String or Long",
    "example": "class Converters {\n    @TypeConverter\n    fun fromTimestamp(value: Long?): Date? =\n        value?.let { Date(it) }\n    \n    @TypeConverter\n    fun dateToTimestamp(date: Date?): Long? =\n        date?.time\n}\n\n@Database(entities = [User::class], version = 1)\n@TypeConverters(Converters::class)\nabstract class AppDatabase : RoomDatabase()"
  },
  {
    "id": 74,
    "question": "What is `@Embedded` in Room?",
    "answer": "Allows nested objects to be flattened into the same table as the parent entity, with the nested object's fields becoming columns in the parent's table",
    "example": "data class Address(\n    val street: String,\n    val city: String\n)\n\n@Entity\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    @Embedded val address: Address  // Columns: street, city\n)\n\n// Use prefix to avoid column name conflicts:\n@Embedded(prefix = \"home_\") val homeAddress: Address"
  },
  {
    "id": 75,
    "question": "What is `@Relation` in Room?",
    "answer": "Defines a relationship between entities for queries that need to load related objects; Room automatically performs the join query",
    "example": "@Entity\ndata class User(@PrimaryKey val userId: Long)\n\n@Entity\ndata class Book(\n    @PrimaryKey val bookId: Long,\n    val userOwnerId: Long\n)\n\ndata class UserWithBooks(\n    @Embedded val user: User,\n    @Relation(\n        parentColumn = \"userId\",\n        entityColumn = \"userOwnerId\"\n    )\n    val books: List<Book>\n)"
  },
  {
    "id": 76,
    "question": "What is a BroadcastReceiver and when should you use it?",
    "answer": "A component that responds to system-wide broadcast announcements like battery low, screen off, or custom broadcasts; use for reacting to system events or inter-app communication",
    "example": "class NetworkReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == ConnectivityManager.CONNECTIVITY_ACTION) {\n            handleConnectivityChange()\n        }\n    }\n}\n\n// Register in manifest or dynamically:\nregisterReceiver(receiver, IntentFilter(...))"
  },
  {
    "id": 77,
    "question": "What is the difference between manifest-declared and context-registered BroadcastReceivers?",
    "answer": "Manifest-declared receivers are always active and can receive broadcasts even when app is stopped, while context-registered receivers are active only while the registering component is alive",
    "example": "// Manifest-declared (limited since Android 8.0):\n<receiver android:name=\".BootReceiver\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n    </intent-filter>\n</receiver>\n\n// Context-registered (recommended):\nregisterReceiver(receiver, filter)\nunregisterReceiver(receiver)  // Don't forget!"
  },
  {
    "id": 78,
    "question": "What is `AnimatedVisibility` in Jetpack Compose?",
    "answer": "A composable that animates the appearance and disappearance of its content using enter and exit transitions",
    "example": "AnimatedVisibility(\n    visible = isVisible,\n    enter = fadeIn() + expandVertically(),\n    exit = fadeOut() + shrinkVertically()\n) {\n    Card { Text(\"Content\") }\n}\n\n// Also: slideInVertically, scaleIn, etc.\n// Combine with + operator"
  },
  {
    "id": 79,
    "question": "What is the difference between `animate*AsState` and `Animatable` in Compose?",
    "answer": "`animate*AsState` is declarative and animates when target changes, while `Animatable` is imperative with more control over animation lifecycle and snap/stop capabilities",
    "example": "// animate*AsState: declarative\nval alpha by animateFloatAsState(if (visible) 1f else 0f)\n\n// Animatable: imperative control\nval alpha = remember { Animatable(0f) }\nLaunchedEffect(visible) {\n    alpha.animateTo(if (visible) 1f else 0f)\n    // Can also: alpha.snapTo(1f), alpha.stop()\n}"
  },
  {
    "id": 80,
    "question": "What is `updateTransition` in Jetpack Compose?",
    "answer": "Manages multiple animation values that change together based on a target state, keeping them synchronized during state transitions",
    "example": "val transition = updateTransition(targetState = selected)\n\nval backgroundColor by transition.animateColor { state ->\n    if (state) Color.Blue else Color.Gray\n}\nval borderWidth by transition.animateDp { state ->\n    if (state) 2.dp else 0.dp\n}\n\n// Both animations run in sync during transition"
  },
  {
    "id": 81,
    "question": "What is the purpose of `@AssistedInject` in Hilt?",
    "answer": "Allows injection of dependencies where some parameters come from Hilt and others are provided at runtime through a factory",
    "example": "class UserViewModel @AssistedInject constructor(\n    private val repo: UserRepository,  // From Hilt\n    @Assisted private val userId: String  // From runtime\n) : ViewModel()\n\n@AssistedFactory\ninterface UserViewModelFactory {\n    fun create(userId: String): UserViewModel\n}\n\n// Usage: factory.create(\"user123\")"
  },
  {
    "id": 82,
    "question": "What is `@EntryPoint` in Hilt?",
    "answer": "Provides access to Hilt dependencies from classes that Hilt doesn't directly inject, like ContentProviders or classes instantiated by libraries",
    "example": "@EntryPoint\n@InstallIn(SingletonComponent::class)\ninterface MyEntryPoint {\n    fun getAnalytics(): Analytics\n}\n\n// In ContentProvider:\nclass MyProvider : ContentProvider() {\n    override fun onCreate(): Boolean {\n        val entryPoint = EntryPointAccessors\n            .fromApplication(context, MyEntryPoint::class.java)\n        val analytics = entryPoint.getAnalytics()\n    }\n}"
  },
  {
    "id": 83,
    "question": "What is the Navigation component's Safe Args plugin?",
    "answer": "A Gradle plugin that generates type-safe classes for navigating between destinations and passing arguments, eliminating runtime errors from incorrect argument types or keys",
    "example": "// Generated from nav graph:\nval action = HomeFragmentDirections\n    .actionHomeToDetail(userId = \"123\")\nfindNavController().navigate(action)\n\n// Receive in destination:\nval args: DetailFragmentArgs by navArgs()\nval userId = args.userId"
  },
  {
    "id": 84,
    "question": "What is `popUpTo` in Navigation component?",
    "answer": "Specifies a destination to pop back to when navigating, optionally removing the destination itself with `inclusive = true`; used to clear back stack",
    "example": "// Pop everything up to home, keeping home:\nnavController.navigate(\"profile\") {\n    popUpTo(\"home\")\n}\n\n// Pop everything INCLUDING home (clear back stack):\nnavController.navigate(\"login\") {\n    popUpTo(\"home\") { inclusive = true }\n}\n\n// Pop all:\npopUpTo(0) { inclusive = true }"
  },
  {
    "id": 85,
    "question": "What is `launchSingleTop` in Navigation?",
    "answer": "Prevents creating multiple instances of a destination on the back stack when navigating to it multiple times; if already at top, just reuse it",
    "example": "navController.navigate(\"settings\") {\n    launchSingleTop = true\n}\n\n// Without: Home -> Settings -> Settings -> Settings\n// With:    Home -> Settings (only one instance)\n\n// Commonly combined with popUpTo for tabs:\npopUpTo(navController.graph.findStartDestination().id) {\n    saveState = true\n}\nlaunchSingleTop = true\nrestoreState = true"
  },
  {
    "id": 86,
    "question": "What is `ConstraintLayout` in Jetpack Compose and when should you use it?",
    "answer": "A layout composable for complex UIs with many interdependent constraints; use when Row/Column/Box nesting becomes too complex or for guideline-based layouts",
    "example": "ConstraintLayout {\n    val (button, text) = createRefs()\n    \n    Button(\n        modifier = Modifier.constrainAs(button) {\n            top.linkTo(parent.top, margin = 16.dp)\n        }\n    ) { Text(\"Button\") }\n    \n    Text(\n        modifier = Modifier.constrainAs(text) {\n            top.linkTo(button.bottom, margin = 8.dp)\n            start.linkTo(button.start)\n        }\n    )\n}"
  },
  {
    "id": 87,
    "question": "What is `runBlocking` and why should you avoid it in Android?",
    "answer": "A coroutine builder that blocks the current thread until completion; avoid on the main thread as it causes ANRs, use only in tests or main functions",
    "example": "// DON'T do this on main thread:\nrunBlocking {\n    delay(1000)  // Blocks main thread - ANR!\n}\n\n// DO use proper coroutine launching:\nlifecycleScope.launch {\n    delay(1000)  // Suspends, doesn't block\n}\n\n// OK in tests:\n@Test\nfun testSuspendFunction() = runBlocking {\n    val result = suspendingFunction()\n}"
  },
  {
    "id": 88,
    "question": "What is the difference between `GlobalScope` and `viewModelScope`?",
    "answer": "`GlobalScope` lives for the entire app lifetime and coroutines aren't cancelled automatically, while `viewModelScope` is tied to ViewModel lifecycle and cancels coroutines when cleared",
    "example": "// BAD: GlobalScope - no lifecycle management\nGlobalScope.launch {\n    // Continues even if Activity destroyed - memory leak!\n}\n\n// GOOD: viewModelScope - automatic cancellation\nviewModelScope.launch {\n    // Cancelled when ViewModel cleared\n}\n\n// In Activity/Fragment use lifecycleScope"
  },
  {
    "id": 89,
    "question": "What is `DataStore` and how does it differ from SharedPreferences?",
    "answer": "A modern data storage solution using coroutines and Flow for async operations; unlike SharedPreferences, it's type-safe with Protocol Buffers and handles errors without crashing",
    "example": "// Preferences DataStore:\nval dataStore = context.createDataStore(name = \"settings\")\n\n// Write:\ndataStore.edit { prefs ->\n    prefs[KEY_DARK_MODE] = true\n}\n\n// Read:\nval darkMode: Flow<Boolean> = dataStore.data\n    .map { it[KEY_DARK_MODE] ?: false }\n\n// No ANRs, no apply() vs commit() issues"
  },
  {
    "id": 90,
    "question": "What is `Paging 3` library and when should you use it?",
    "answer": "A library for loading large datasets incrementally with support for local and network sources, caching, error handling, and retry; use for infinite scrolling lists",
    "example": "// Define PagingSource:\nclass UserPagingSource : PagingSource<Int, User>() {\n    override suspend fun load(params: LoadParams<Int>): LoadResult<Int, User> {\n        val page = params.key ?: 0\n        return try {\n            val users = api.getUsers(page, params.loadSize)\n            LoadResult.Page(users, prevKey = null, nextKey = page + 1)\n        } catch (e: Exception) {\n            LoadResult.Error(e)\n        }\n    }\n}"
  },
  {
    "id": 91,
    "question": "What is `RemoteMediator` in Paging 3?",
    "answer": "Handles loading data from network into local database for offline-first paging; manages when to refresh and append data from remote source",
    "example": "@OptIn(ExperimentalPagingApi::class)\nclass UserRemoteMediator(\n    private val api: Api,\n    private val db: AppDatabase\n) : RemoteMediator<Int, User>() {\n    \n    override suspend fun load(\n        loadType: LoadType,\n        state: PagingState<Int, User>\n    ): MediatorResult {\n        // Fetch from network, save to database\n        return MediatorResult.Success(endOfPaginationReached = false)\n    }\n}"
  },
  {
    "id": 92,
    "question": "What is `sealed class` in Kotlin and why is it useful for UI state?",
    "answer": "A class with a fixed set of subclasses known at compile time; useful for UI state because `when` expressions can be exhaustive without an `else` branch",
    "example": "sealed class UiState {\n    object Loading : UiState()\n    data class Success(val data: List<Item>) : UiState()\n    data class Error(val message: String) : UiState()\n}\n\n// Exhaustive when - compiler ensures all cases handled:\nwhen (state) {\n    is UiState.Loading -> showLoading()\n    is UiState.Success -> showData(state.data)\n    is UiState.Error -> showError(state.message)\n}"
  },
  {
    "id": 93,
    "question": "What is `sealed interface` in Kotlin and when should you use it over sealed class?",
    "answer": "Like sealed class but allows subclasses to extend other classes; use when subclasses need to inherit from different parent classes while still being exhaustive",
    "example": "sealed interface Result<out T>\ndata class Success<T>(val data: T) : Result<T>\ndata class Error(val exception: Throwable) : Result<Nothing>\nobject Loading : Result<Nothing>\n\n// Subclass can extend another class:\nsealed interface Event\nclass ClickEvent : Event, View.OnClickListener { ... }"
  },
  {
    "id": 94,
    "question": "What is `inline` function in Kotlin and why use it?",
    "answer": "Inlines the function body at call sites, eliminating lambda object allocation and enabling non-local returns; use for higher-order functions to reduce overhead",
    "example": "inline fun measureTime(block: () -> Unit): Long {\n    val start = System.currentTimeMillis()\n    block()  // Inlined, no lambda object created\n    return System.currentTimeMillis() - start\n}\n\n// Non-local return works with inline:\ninline fun List<Int>.firstPositive(action: (Int) -> Unit) {\n    for (i in this) {\n        if (i > 0) { action(i); return }  // Returns from caller\n    }\n}"
  },
  {
    "id": 95,
    "question": "What does `crossinline` modifier do in Kotlin?",
    "answer": "Prevents non-local returns in lambdas passed to inline functions, used when the lambda is called from a different execution context like another lambda or object",
    "example": "inline fun runAsync(crossinline block: () -> Unit) {\n    thread {\n        block()  // Called in different context\n        // return here would be confusing - crossinline prevents it\n    }\n}\n\nrunAsync {\n    // return  // ERROR: not allowed with crossinline\n    doSomething()\n}"
  },
  {
    "id": 96,
    "question": "What is `reified` type parameter in Kotlin?",
    "answer": "Makes type parameter available at runtime in inline functions, allowing operations like `is` checks and `::class` that normally fail due to type erasure",
    "example": "inline fun <reified T> isType(value: Any): Boolean {\n    return value is T  // Works because T is reified\n}\n\nval isString = isType<String>(\"hello\")  // true\n\ninline fun <reified T> Intent.getExtra(key: String): T? {\n    return extras?.get(key) as? T\n}"
  },
  {
    "id": 97,
    "question": "What is the difference between `Modifier.clip` and `Modifier.graphicsLayer` for shapes?",
    "answer": "`clip` clips content to a shape affecting touch bounds and drawing, while `graphicsLayer` with clip applies hardware-accelerated clipping without affecting touch bounds",
    "example": "// clip: affects drawing AND touch bounds\nImage(\n    modifier = Modifier.clip(CircleShape)  // Touch area is circle\n)\n\n// graphicsLayer: drawing only, touch unaffected\nImage(\n    modifier = Modifier.graphicsLayer {\n        clip = true\n        shape = CircleShape  // Touch area still rectangle\n    }\n)"
  },
  {
    "id": 98,
    "question": "What is `remember(key) { ... }` in Jetpack Compose?",
    "answer": "Caches a value and recalculates it only when the key changes; without a key, the value persists across recompositions until leaving composition",
    "example": "// No key: calculated once, cached until leaving composition\nval expensive = remember { calculateExpensiveValue() }\n\n// With key: recalculated when userId changes\nval user = remember(userId) { fetchUser(userId) }\n\n// Multiple keys:\nval result = remember(a, b, c) { compute(a, b, c) }"
  },
  {
    "id": 99,
    "question": "What is `movableContentOf` in Jetpack Compose?",
    "answer": "Creates content that can be moved between compositions while preserving state; useful for animations where UI moves between different parents",
    "example": "val movableContent = remember {\n    movableContentOf {\n        var count by remember { mutableStateOf(0) }\n        Button(onClick = { count++ }) { Text(\"$count\") }\n    }\n}\n\nif (isExpanded) {\n    ExpandedLayout { movableContent() }  // State preserved\n} else {\n    CompactLayout { movableContent() }   // Same state!\n}"
  },
  {
    "id": 100,
    "question": "What is the purpose of `Modifier.drawBehind` and `Modifier.drawWithContent` in Compose?",
    "answer": "`drawBehind` draws behind the content using Canvas API, while `drawWithContent` gives control over when to draw content relative to custom drawing",
    "example": "// drawBehind: draw BEHIND content\nBox(\n    modifier = Modifier.drawBehind {\n        drawCircle(Color.Blue)  // Behind Box content\n    }\n)\n\n// drawWithContent: control draw order\nBox(\n    modifier = Modifier.drawWithContent {\n        drawRect(Color.Red)     // Draw first (background)\n        drawContent()           // Then draw content\n        drawCircle(Color.Blue)  // Finally overlay\n    }\n)"
  },
  {
    "id": 101,
    "question": "What are the key differences between MVVM and MVI architecture, and when would you choose one over the other?",
    "answer": "MVVM exposes multiple observable state streams and allows bidirectional communication, while MVI enforces a single immutable state object with unidirectional data flow via intents. Choose MVI when state consistency and reproducibility matter (complex screens, debugging), and MVVM for simpler screens where multiple independent state streams are manageable",
    "example": "// MVVM: multiple state streams, bidirectional\nclass ProfileViewModel : ViewModel() {\n    val user = MutableStateFlow<User?>(null)\n    val posts = MutableStateFlow<List<Post>>(emptyList())\n    val isLoading = MutableStateFlow(false)\n    // Problem: can have inconsistent states\n    // e.g., isLoading=false but user=null and posts=empty\n}\n\n// MVI: single state, unidirectional\ndata class ProfileState(\n    val user: User? = null,\n    val posts: List<Post> = emptyList(),\n    val isLoading: Boolean = false\n)\nsealed class ProfileIntent {\n    data class LoadProfile(val id: String) : ProfileIntent()\n    object Refresh : ProfileIntent()\n}\n// State is always consistent  one atomic update"
  },
  {
    "id": 102,
    "question": "What is Unidirectional Data Flow (UDF) and why is it important for scaling Android apps?",
    "answer": "UDF means state flows down from ViewModel to UI and events flow up from UI to ViewModel, forming a single loop. It eliminates state inconsistencies, makes state changes predictable and traceable, simplifies debugging, and enables time-travel debugging since every state is a pure function of the previous state plus an action",
    "example": "// UDF cycle: Intent -> Reducer -> State -> UI -> Intent\nclass MyViewModel : ViewModel() {\n    private val _state = MutableStateFlow(UiState())\n    val state: StateFlow<UiState> = _state\n\n    fun handleIntent(intent: UiIntent) {\n        when (intent) {\n            is UiIntent.LoadData -> {\n                _state.update { it.copy(loading = true) }\n                viewModelScope.launch {\n                    val data = repo.fetch()\n                    _state.update { it.copy(loading = false, data = data) }\n                }\n            }\n        }\n    }\n}\n\n// In Composable:\nval state by viewModel.state.collectAsState()\nButton(onClick = { viewModel.handleIntent(UiIntent.LoadData) })"
  },
  {
    "id": 103,
    "question": "How would you design an offline-first architecture for an Android app?",
    "answer": "Use a local database (Room) as the single source of truth, sync with the network in the background, and always read from the local database. The repository mediates between remote and local sources, network responses update the database, and the UI observes database changes via Flow. Handle conflicts with timestamps or version vectors",
    "example": "// Repository: local DB is single source of truth\nclass ArticleRepository(\n    private val api: ArticleApi,\n    private val dao: ArticleDao\n) {\n    // UI always reads from DB\n    fun getArticles(): Flow<List<Article>> = dao.getAll()\n\n    // Sync fetches from network and writes to DB\n    suspend fun sync() {\n        try {\n            val remote = api.fetchArticles()\n            dao.upsertAll(remote) // DB update triggers Flow emission\n        } catch (e: IOException) {\n            // Offline  stale data still available from DB\n        }\n    }\n}\n\n// WorkManager ensures sync happens even if app killed\nclass SyncWorker(ctx: Context, params: WorkerParameters)\n    : CoroutineWorker(ctx, params) {\n    override suspend fun doWork(): Result {\n        repository.sync()\n        return Result.success()\n    }\n}"
  },
  {
    "id": 104,
    "question": "How would you structure a multi-module Android app for a large team, and what are the trade-offs?",
    "answer": "Split by feature modules (each owned by a team) with shared core/common modules. Use an app module as the composition root, feature modules for screens/flows, domain modules for business logic, and data modules for repositories. Trade-offs: faster incremental builds and clear ownership vs increased Gradle complexity, navigation between modules, and potential code duplication",
    "example": "// Module structure:\n// :app               composition root, navigation graph\n// :core:ui           design system, shared composables\n// :core:network      Retrofit setup, interceptors\n// :core:database     Room DB, shared DAOs\n// :core:common       utilities, extensions\n// :feature:home      home screen feature\n// :feature:profile   profile feature\n// :feature:search    search feature\n\n// feature modules depend on :core, never on each other\n// build.gradle.kts in :feature:home\ndependencies {\n    implementation(project(\":core:ui\"))\n    implementation(project(\":core:network\"))\n    // NEVER: implementation(project(\":feature:profile\"))\n}\n\n// Navigation between features uses routes/deep links\n// not direct class references"
  },
  {
    "id": 105,
    "question": "What is the Repository pattern in Android and why is it critical for testable, scalable architecture?",
    "answer": "The Repository abstracts data sources behind a clean API, deciding whether to fetch from network, cache, or database. It decouples the domain/presentation layer from data implementation details, enables easy testing with fakes, allows swapping data sources without touching business logic, and centralizes caching and sync strategies",
    "example": "// Interface in domain layer (no Android dependencies)\ninterface UserRepository {\n    fun getUser(id: String): Flow<User>\n    suspend fun refreshUser(id: String)\n}\n\n// Implementation in data layer\nclass UserRepositoryImpl @Inject constructor(\n    private val api: UserApi,\n    private val dao: UserDao,\n    private val cache: UserMemoryCache\n) : UserRepository {\n    override fun getUser(id: String): Flow<User> =\n        dao.observeUser(id) // Single source of truth\n\n    override suspend fun refreshUser(id: String) {\n        val user = api.fetchUser(id)\n        dao.upsert(user)\n        cache.put(id, user)\n    }\n}\n\n// In tests:\nclass FakeUserRepository : UserRepository { ... }"
  },
  {
    "id": 106,
    "question": "How do you detect and fix memory leaks in an Android app?",
    "answer": "Use LeakCanary for automatic detection during development  it watches destroyed Activities, Fragments, Views, and ViewModels for GC retention. For manual profiling, use Android Studio Memory Profiler to capture heap dumps and trace allocation paths. Common fixes: avoid static Context references, unregister listeners, use WeakReferences for callbacks, cancel coroutines with proper scopes, and use applicationContext for singletons",
    "example": "// LeakCanary auto-detects in debug builds:\n// debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.x'\n\n// Common leak patterns and fixes:\n\n// 1. Inner class holding Activity reference\nclass MyActivity : Activity() {\n    // BAD: non-static inner class implicitly holds Activity\n    inner class MyTask : Runnable { ... }\n    // FIX: use static class + WeakReference\n    class MyTask(activity: WeakReference<Activity>) : Runnable { ... }\n}\n\n// 2. Unregistered listener\noverride fun onStart() {\n    sensorManager.registerListener(this, sensor, DELAY)\n}\noverride fun onStop() {\n    sensorManager.unregisterListener(this) // MUST unregister\n}\n\n// 3. Coroutine leak\nviewModelScope.launch { ... } // Auto-cancelled\nGlobalScope.launch { ... }    // LEAK  never cancelled"
  },
  {
    "id": 107,
    "question": "What causes jank (dropped frames) in an Android app and how do you diagnose and fix it?",
    "answer": "Jank occurs when a frame takes longer than 16ms (60fps) to render. Causes include heavy work on the main thread, deep view hierarchies, overdraw, large bitmap allocations, and excessive recompositions in Compose. Diagnose with Systrace/Perfetto, GPU profiler, Layout Inspector, and Compose compiler metrics. Fix by moving work off main thread, flattening layouts, reducing overdraw, and using stable types in Compose",
    "example": "// Diagnosing Compose recomposition:\n// 1. Enable composition tracing in build.gradle:\n//    kotlinCompilerExtensionVersion with compose compiler metrics\n// 2. Use Layout Inspector's recomposition counts\n\n// Common Compose jank fixes:\n\n// BAD: unstable lambda causes recomposition\n@Composable\nfun ItemList(items: List<Item>) {\n    LazyColumn {\n        items(items) { item ->\n            Row(onClick = { viewModel.select(item) }) // New lambda each recomp\n        }\n    }\n}\n\n// GOOD: stable lambda reference\n@Composable\nfun ItemList(items: List<Item>, onSelect: (Item) -> Unit) {\n    LazyColumn {\n        items(items, key = { it.id }) { item ->\n            Row(onClick = { onSelect(item) })\n        }\n    }\n}\n\n// BAD: reading scroll state directly causes per-frame recomp\nval offset = scrollState.value // Recomposes every frame\n// GOOD: defer read to drawing phase\nModifier.graphicsLayer { translationY = scrollState.value.toFloat() }"
  },
  {
    "id": 108,
    "question": "What causes ANR (Application Not Responding) and how do you prevent it in production?",
    "answer": "ANR triggers when the main thread is blocked for 5+ seconds on input dispatch or BroadcastReceiver takes 10+ seconds. Causes include synchronous network/disk I/O on main thread, long-running computations, lock contention, and deadlocks. Prevent with strict use of coroutines/Dispatchers.IO, StrictMode in debug, ANR traces analysis from Play Console, and never holding locks across thread boundaries",
    "example": "// Enable StrictMode in debug to catch violations early:\nif (BuildConfig.DEBUG) {\n    StrictMode.setThreadPolicy(\n        StrictMode.ThreadPolicy.Builder()\n            .detectDiskReads()\n            .detectDiskWrites()\n            .detectNetwork()\n            .penaltyLog()\n            .penaltyDeath() // Crash on violation\n            .build()\n    )\n}\n\n// BAD: blocking main thread\nfun onClick() {\n    val data = database.query() // ANR risk!\n    updateUi(data)\n}\n\n// GOOD: offload to coroutine\nfun onClick() {\n    viewModelScope.launch {\n        val data = withContext(Dispatchers.IO) {\n            database.query()\n        }\n        _state.value = data // Back on Main\n    }\n}\n\n// BroadcastReceiver: use goAsync() for longer work\noverride fun onReceive(context: Context, intent: Intent) {\n    val pending = goAsync()\n    scope.launch {\n        doWork()\n        pending.finish() // Must call within 10s\n    }\n}"
  },
  {
    "id": 109,
    "question": "How does Android's process priority system work and how does it affect your app?",
    "answer": "Android ranks processes by importance: foreground (visible Activity, foreground Service), visible (partially visible Activity), service (background Service), cached (empty/background). The system kills lower-priority processes first when memory is low. Your app should save state early (onStop), use foreground services for critical work, and design for process death at any time",
    "example": "// Process priority (highest to lowest):\n// 1. Foreground  user is interacting\n//    - Active Activity with focus\n//    - Service bound to foreground Activity\n//    - Foreground Service (with notification)\n//    - BroadcastReceiver executing onReceive()\n//\n// 2. Visible  user can see but not interact\n//    - Activity behind a dialog\n//\n// 3. Service  running background service\n//    - Started Service not in foreground\n//\n// 4. Cached  not currently needed\n//    - Activity in back stack\n//    - No active components\n\n// Implications for architecture:\n// - Always save state in onStop(), not onDestroy()\n// - Use SavedStateHandle to survive process death\n// - Test with \"Don't keep activities\" developer option\n// - Foreground services keep process alive but drain battery\n// - WorkManager survives process death for deferred work"
  },
  {
    "id": 110,
    "question": "What happens internally when you call startActivity()? Walk through the process from the framework to the new Activity rendering.",
    "answer": "1) The app calls startActivity() which sends an IPC via Binder to ActivityManagerService (system_server). 2) AMS checks permissions, resolves the Intent, and determines the target process. 3) If the target process doesn't exist, AMS asks Zygote to fork a new process. 4) AMS instructs the target process's ActivityThread to instantiate the Activity. 5) ActivityThread creates the Activity, calls attach(), then onCreate(). 6) The Activity sets content, the View hierarchy is measured/laid out/drawn, and the first frame is rendered on the surface via SurfaceFlinger",
    "example": "// Simplified internal flow:\n\n// 1. App process\nstartActivity(intent)\n   Instrumentation.execStartActivity()\n     ActivityTaskManager.getService()  // Binder proxy\n      .startActivity(...)               // IPC to system_server\n\n// 2. system_server (ActivityManagerService)\nAMS.startActivity()\n   resolveIntent()        // PackageManager lookup\n   checkPermissions()     // Security check\n   startActivityLocked()  // Task/back stack management\n   if (newProcess) Zygote.fork()\n   scheduleLaunchActivity() // IPC back to app\n\n// 3. App process (target)\nActivityThread.handleLaunchActivity()\n   activity = Instrumentation.newActivity()  // Reflection\n   activity.attach(context, window, ...)     // Window setup\n   activity.onCreate()                       // Your code\n   activity.onStart()\n   activity.onResume()\n   ViewRootImpl.performTraversals()          // Measure/layout/draw\n   SurfaceFlinger composites the frame"
  },
  {
    "id": 111,
    "question": "What is the Zygote process and why is it critical for Android app startup performance?",
    "answer": "Zygote is a special process started at boot that preloads common framework classes and resources, then forks to create new app processes. Forking is fast because it uses copy-on-write memory  the child shares the parent's preloaded classes until it writes to them. Without Zygote, every app launch would need to reload the entire framework from scratch, making cold starts significantly slower",
    "example": "// Boot sequence:\n// 1. init  starts Zygote process\n// 2. Zygote preloads:\n//    - ~10,000 framework classes (android.*, java.*)\n//    - Common resources, drawables\n//    - Shared libraries (ICU, OpenGL)\n//    - Initializes ART runtime\n\n// 3. App launch request:\n// AMS  Zygote socket  fork()\n//\n// fork() with copy-on-write:\n// - New process SHARES Zygote's memory pages\n// - Pages copied only when written to\n// - Saves ~30MB per app process\n// - App starts with framework already loaded\n\n// This is why:\n// - First app launch after boot is slowest (Zygote loading)\n// - Subsequent app launches are fast (just fork)\n// - All apps share the same base framework in memory\n// - App-specific code is loaded after fork in onCreate()"
  },
  {
    "id": 112,
    "question": "How does the Looper-Handler-MessageQueue pattern work internally, and why does it matter for Android development?",
    "answer": "Each thread with a Looper has a MessageQueue. The Looper continuously polls the queue for Messages, dispatching each to its target Handler. The main thread's Looper (MainLooper) is what makes the UI single-threaded  all UI operations are Messages processed sequentially. Understanding this explains why blocking the main thread causes ANRs, why post() and postDelayed() work, and how coroutines' Dispatchers.Main dispatches work to the main thread",
    "example": "// Main thread setup (done by ActivityThread):\nLooper.prepareMainLooper()\n// Creates: Looper  MessageQueue  native epoll\n\n// How Handler.post() works internally:\nhandler.post { updateUi() }\n// 1. Wraps Runnable in a Message\n// 2. Message.target = this handler\n// 3. Enqueues Message into MessageQueue (sorted by time)\n\n// Main loop (simplified):\nLooper.loop() {\n    while (true) {\n        val msg = queue.next() // Blocks via epoll until message ready\n        msg.target.dispatchMessage(msg) // Calls handleMessage()\n        msg.recycle() // Return to pool\n    }\n}\n\n// This is why:\n// - Dispatchers.Main posts to main handler\n// - View.post() ensures code runs after layout\n// - Long operations in any Message block ALL subsequent ones\n// - ANR = main looper stuck on one Message for 5+ seconds\n\n// Custom thread with Looper:\nval thread = HandlerThread(\"background\")\nthread.start()\nval bgHandler = Handler(thread.looper)"
  },
  {
    "id": 113,
    "question": "How do Doze mode, App Standby, and background execution limits affect your app, and how do you design around them?",
    "answer": "Doze mode defers network, Jobs, syncs, and alarms when the device is idle and unplugged. App Standby buckets (Active, Working Set, Frequent, Rare, Restricted) progressively limit how often your app can run jobs and access the network. Design around them by using WorkManager (respects system constraints), FCM high-priority messages for urgent work, and avoid exact alarms unless absolutely necessary",
    "example": "// Doze mode restrictions:\n// - Network access suspended\n// - JobScheduler/WorkManager deferred\n// - Alarms deferred (except setExactAndAllowWhileIdle)\n// - Syncs deferred\n// - Maintenance windows allow brief execution\n\n// App Standby Buckets (Android 9+):\n// Active    app in foreground: no restrictions\n// Working   recently used: jobs run every 2 hrs\n// Frequent  often used: jobs every 8 hrs\n// Rare      seldom used: jobs every 24 hrs, limited network\n// Restricted  never used: 1 job/day, no network in background\n\n// Design strategies:\n// 1. Use WorkManager  it respects all constraints\nval work = OneTimeWorkRequestBuilder<SyncWorker>()\n    .setConstraints(Constraints.Builder()\n        .setRequiredNetworkType(NetworkType.CONNECTED)\n        .build())\n    .build()\n\n// 2. Use FCM high-priority for time-sensitive events\n// { \"priority\": \"high\" }  wakes device from Doze\n\n// 3. Foreground service for user-initiated long tasks\n// 4. Never rely on exact timing for non-alarm use cases"
  },
  {
    "id": 114,
    "question": "How do you choose between WorkManager, foreground Service, AlarmManager, and coroutines for background work?",
    "answer": "Use coroutines for short-lived work tied to a screen. Use WorkManager for deferrable, guaranteed work that must survive process death (syncing, uploading). Use foreground Service for long-running, user-visible tasks (music, navigation). Use AlarmManager only for exact-time triggers like user-set alarms. The decision tree: immediate  coroutines; must complete  WorkManager; user-aware long task  foreground Service; exact time  AlarmManager",
    "example": "// Decision matrix:\n//\n// Need                          | Solution\n// ------------------------------|------------------\n// Fetch data for current screen | viewModelScope.launch\n// Upload photo in background    | WorkManager\n// Play music while minimized    | Foreground Service\n// Daily alarm at 8:00 AM        | AlarmManager\n// Periodic sync every 15 min    | WorkManager (periodic)\n// Download with progress bar    | Foreground Service + WorkManager\n\n// WorkManager: deferrable + guaranteed\nval uploadWork = OneTimeWorkRequestBuilder<UploadWorker>()\n    .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)\n    .build()\n\n// Foreground Service: user-visible long task\nclass NavigationService : Service() {\n    override fun onStartCommand(...) {\n        startForeground(ID, buildNotification())\n        // Long-running navigation work\n    }\n}\n\n// AlarmManager: exact time only\nalarmManager.setExactAndAllowWhileIdle(\n    AlarmManager.RTC_WAKEUP, triggerAtMillis, pendingIntent\n)"
  },
  {
    "id": 115,
    "question": "How would you implement an efficient image loading and caching strategy at scale?",
    "answer": "Use a three-tier cache: memory cache (LruCache for decoded bitmaps), disk cache (for raw files), and network. Implement bitmap sampling to load images at the required display size, not full resolution. Use libraries like Coil or Glide that handle lifecycle-aware loading, disk/memory caching, request deduplication, and bitmap pooling. For Compose, use AsyncImage with proper content scaling and placeholders",
    "example": "// Three-tier cache hierarchy:\n// 1. Memory (LruCache)  instant, ~1/8 of app memory\n// 2. Disk (DiskLruCache)  fast, 50-250MB\n// 3. Network  slow, only when cache miss\n\n// Manual bitmap sampling to avoid OOM:\nfun decodeSampledBitmap(res: Resources, resId: Int,\n    reqWidth: Int, reqHeight: Int): Bitmap {\n    val options = BitmapFactory.Options().apply {\n        inJustDecodeBounds = true // Get dimensions only\n    }\n    BitmapFactory.decodeResource(res, resId, options)\n    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight)\n    options.inJustDecodeBounds = false\n    return BitmapFactory.decodeResource(res, resId, options)\n}\n\n// In Compose with Coil:\nAsyncImage(\n    model = ImageRequest.Builder(context)\n        .data(url)\n        .size(Size.ORIGINAL)    // Or specify exact size\n        .crossfade(true)\n        .memoryCachePolicy(CachePolicy.ENABLED)\n        .diskCachePolicy(CachePolicy.ENABLED)\n        .build(),\n    contentDescription = null\n)"
  },
  {
    "id": 116,
    "question": "How would you design a networking layer that handles retries, exponential backoff, and circuit breaking at scale?",
    "answer": "Use OkHttp interceptors for retry logic with exponential backoff and jitter to avoid thundering herd. Implement a circuit breaker pattern that opens after consecutive failures, preventing wasted requests and battery. Add request deduplication so multiple callers for the same data share one in-flight request. Use timeouts aggressively and differentiate between retryable (5xx, timeout) and non-retryable (4xx) errors",
    "example": "// OkHttp retry interceptor with exponential backoff:\nclass RetryInterceptor(private val maxRetries: Int = 3) : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        var attempt = 0\n        var lastException: IOException? = null\n        while (attempt < maxRetries) {\n            try {\n                val response = chain.proceed(chain.request())\n                if (response.isSuccessful || response.code < 500) return response\n                response.close()\n            } catch (e: IOException) { lastException = e }\n            attempt++\n            val delay = (2.0.pow(attempt) * 1000 * (1 + Random.nextFloat())).toLong()\n            Thread.sleep(delay) // backoff + jitter\n        }\n        throw lastException ?: IOException(\"Max retries exceeded\")\n    }\n}\n\n// Circuit breaker pattern:\nclass CircuitBreaker(private val threshold: Int = 5) {\n    private var failures = 0\n    private var openUntil = 0L\n    val isOpen get() = System.currentTimeMillis() < openUntil\n\n    fun recordSuccess() { failures = 0 }\n    fun recordFailure() {\n        if (++failures >= threshold) {\n            openUntil = System.currentTimeMillis() + 30_000 // Open 30s\n        }\n    }\n}"
  },
  {
    "id": 117,
    "question": "How would you handle API pagination with offline support for a feed-style feature?",
    "answer": "Use Paging 3 with RemoteMediator: Room is the source of truth, RemoteMediator fetches pages from the API and inserts into Room, PagingSource reads from Room. Store remote keys (next page token) in a separate table. On refresh, clear old data in a transaction with new data. This gives offline browsing, smooth scrolling, and automatic cache invalidation",
    "example": "// Remote keys table stores pagination state\n@Entity\ndata class RemoteKey(\n    @PrimaryKey val label: String,\n    val nextPage: Int?\n)\n\n@OptIn(ExperimentalPagingApi::class)\nclass FeedRemoteMediator(\n    private val api: FeedApi,\n    private val db: AppDatabase\n) : RemoteMediator<Int, FeedItem>() {\n\n    override suspend fun load(\n        loadType: LoadType,\n        state: PagingState<Int, FeedItem>\n    ): MediatorResult {\n        val page = when (loadType) {\n            LoadType.REFRESH -> 0\n            LoadType.PREPEND -> return MediatorResult.Success(endReached = true)\n            LoadType.APPEND -> {\n                db.remoteKeyDao().get(\"feed\")?.nextPage\n                    ?: return MediatorResult.Success(endReached = true)\n            }\n        }\n        val response = api.getFeed(page = page, size = state.config.pageSize)\n        db.withTransaction {\n            if (loadType == LoadType.REFRESH) {\n                db.feedDao().clearAll()\n                db.remoteKeyDao().delete(\"feed\")\n            }\n            db.feedDao().insertAll(response.items)\n            db.remoteKeyDao().insert(RemoteKey(\"feed\", response.nextPage))\n        }\n        return MediatorResult.Success(endReached = response.nextPage == null)\n    }\n}"
  },
  {
    "id": 118,
    "question": "What strategies do you use for handling unreliable network conditions in a mobile app?",
    "answer": "Implement optimistic UI updates (show changes immediately, reconcile later), queue failed requests for retry, use exponential backoff with jitter, provide clear offline/sync status to users, debounce rapid requests, use ConnectivityManager to adapt behavior, and implement request prioritization (user-initiated > background sync)",
    "example": "// Optimistic update with rollback:\nclass PostRepository(\n    private val api: PostApi, private val dao: PostDao\n) {\n    suspend fun likePost(postId: String) {\n        // 1. Optimistic: update UI immediately\n        dao.setLiked(postId, true)\n\n        // 2. Try server sync\n        try {\n            api.likePost(postId)\n        } catch (e: IOException) {\n            // 3. Rollback on failure\n            dao.setLiked(postId, false)\n            // 4. Queue for retry\n            pendingActions.enqueue(LikeAction(postId))\n        }\n    }\n}\n\n// Network-aware request adaptation:\nval connectivityManager = getSystemService<ConnectivityManager>()\nval capabilities = connectivityManager\n    .getNetworkCapabilities(connectivityManager.activeNetwork)\n\nwhen {\n    capabilities == null -> useOfflineMode()\n    capabilities.hasTransport(TRANSPORT_WIFI) -> prefetchHeavyContent()\n    capabilities.hasTransport(TRANSPORT_CELLULAR) -> {\n        if (capabilities.linkDownstreamBandwidthKbps < 1000) {\n            loadLowResImages()\n        }\n    }\n}"
  },
  {
    "id": 119,
    "question": "How does the Android Binder IPC mechanism work and why should you care as an app developer?",
    "answer": "Binder is Android's inter-process communication mechanism. It enables communication between your app and system services (ActivityManager, PackageManager, etc.) via a kernel driver that maps memory between processes. Each Binder call is synchronous and blocks the calling thread. You should care because: every system API call (startActivity, getSystemService, etc.) crosses a Binder boundary, Binder has a thread pool limit (16 threads), and excessive IPC calls on the main thread cause jank",
    "example": "// Every system service call is a Binder IPC:\nval pm = context.packageManager           // Binder proxy\nval info = pm.getPackageInfo(pkg, 0)      // IPC call!\n\n// This means:\n// - System API calls are NOT free  they cross process boundary\n// - Each call serializes/deserializes data (Parcel)\n// - Blocking: calling thread waits for system_server response\n// - Binder thread pool is limited to 16 threads per process\n\n// Performance implications:\n// BAD: calling system APIs in a tight loop on main thread\nfor (app in installedApps) {\n    pm.getApplicationIcon(app) // IPC per iteration  jank!\n}\n\n// GOOD: batch or move off main thread\nwithContext(Dispatchers.IO) {\n    installedApps.map { pm.getApplicationIcon(it) }\n}\n\n// Content Providers also use Binder:\ncontentResolver.query(...) // IPC to provider's process\n\n// AIDL generates Binder stubs for custom IPC:\n// interface IMyService { void doWork(int param); }"
  },
  {
    "id": 120,
    "question": "How would you design a ViewModel to handle multiple concurrent data sources without race conditions?",
    "answer": "Use MutableStateFlow with the update{} method for atomic state updates. Combine multiple flows with combine() operator for derived state. Use Mutex for protecting critical sections in coroutines. Avoid multiple mutable state sources  prefer a single state object with copy(). For complex state machines, use a sealed intent/action pattern with a single reducer function",
    "example": "// Single state with atomic updates:\ndata class ProfileState(\n    val user: User? = null,\n    val posts: List<Post> = emptyList(),\n    val friends: List<User> = emptyList(),\n    val isLoading: Boolean = true,\n    val error: String? = null\n)\n\nclass ProfileViewModel @Inject constructor(\n    private val userRepo: UserRepository,\n    private val postRepo: PostRepository\n) : ViewModel() {\n    private val _state = MutableStateFlow(ProfileState())\n    val state = _state.asStateFlow()\n\n    fun load(userId: String) {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true) }\n\n            // Parallel loading  no race condition because\n            // each coroutine uses update{} for atomic modification\n            coroutineScope {\n                launch {\n                    val user = userRepo.getUser(userId)\n                    _state.update { it.copy(user = user) }\n                }\n                launch {\n                    val posts = postRepo.getPosts(userId)\n                    _state.update { it.copy(posts = posts) }\n                }\n            }\n            _state.update { it.copy(isLoading = false) }\n        }\n    }\n}"
  },
  {
    "id": 121,
    "question": "What is the difference between cold start, warm start, and hot start, and how do you optimize cold start time?",
    "answer": "Cold start creates the process from scratch (Zygote fork  Application.onCreate  Activity.onCreate  first frame). Warm start reuses the process but recreates the Activity. Hot start just brings the Activity to foreground. Cold start is slowest and most impactful. Optimize by deferring heavy initialization, using App Startup library, avoiding disk/network I/O in Application.onCreate, and providing a splash screen to mask loading time",
    "example": "// Cold start timeline:\n// 1. Process fork from Zygote (~200ms)\n// 2. Application.onCreate()  YOUR CODE\n// 3. Activity.onCreate()  YOUR CODE\n// 4. First frame rendered\n// Total target: < 500ms\n\n// BAD: heavy init in Application.onCreate()\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        initAnalytics()     // 100ms\n        initCrashReporting() // 50ms\n        initImageLoader()    // 80ms\n        initDatabase()       // 150ms  // Total: 380ms blocked!\n    }\n}\n\n// GOOD: lazy + deferred initialization\nclass MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Only critical-path init here\n        initCrashReporting() // 50ms  needed for error capture\n    }\n}\n\n// Use App Startup for dependency-ordered lazy init:\nclass AnalyticsInitializer : Initializer<Analytics> {\n    override fun create(context: Context): Analytics {\n        return Analytics.init(context) // Lazy, runs when first needed\n    }\n    override fun dependencies() = listOf(CrashInitializer::class.java)\n}\n\n// Splash Screen API (Android 12+):\ninstallSplashScreen() // Smooth transition, hides cold start"
  },
  {
    "id": 122,
    "question": "How do you prevent and detect bitmap-related OOM (OutOfMemoryError) in Android?",
    "answer": "Each app has a limited heap (typically 256-512MB). A single 4000x3000 ARGB_8888 bitmap uses ~48MB. Prevent OOM by: sampling bitmaps down to display size with inSampleSize, using RGB_565 when alpha isn't needed (halves memory), loading images via Coil/Glide which handle pooling and lifecycle, monitoring heap with Runtime.maxMemory(), and using hardware bitmaps on Android 8+ which store pixels in GPU memory outside the Java heap",
    "example": "// Bitmap memory calculation:\n// ARGB_8888: width * height * 4 bytes\n// 4000x3000 = 48,000,000 bytes = ~48MB!\n\n// Solution 1: Sample down to display size\nval options = BitmapFactory.Options().apply {\n    inJustDecodeBounds = true\n}\nBitmapFactory.decodeFile(path, options) // Get dimensions only\noptions.inSampleSize = calculateInSampleSize(\n    options, targetWidth, targetHeight // e.g., 400x300\n)\noptions.inJustDecodeBounds = false\noptions.inPreferredConfig = Bitmap.Config.RGB_565 // Half memory\nval bitmap = BitmapFactory.decodeFile(path, options) // ~0.24MB!\n\n// Solution 2: Hardware bitmaps (Android 8+)\n// Stored in GPU memory, not counted against Java heap\noptions.inPreferredConfig = Bitmap.Config.HARDWARE\n\n// Solution 3: Monitor heap usage\nval runtime = Runtime.getRuntime()\nval usedMB = (runtime.totalMemory() - runtime.freeMemory()) / 1048576\nval maxMB = runtime.maxMemory() / 1048576\nLog.d(\"Memory\", \"Used: $usedMB MB / Max: $maxMB MB\")\n\n// Solution 4: Use image loading library\n// Coil/Glide handle all of the above automatically"
  },
  {
    "id": 123,
    "question": "How does Gradle build caching and incremental compilation work in multi-module projects, and how do you optimize build times?",
    "answer": "Gradle caches task outputs by input hash  if inputs haven't changed, cached output is reused. Incremental compilation only recompiles changed files and their dependents. Multi-module projects benefit because changing one module only rebuilds that module and its dependents, not the whole project. Optimize by using api vs implementation dependencies correctly, enabling build cache, using configuration cache, and keeping module dependencies minimal",
    "example": "// api vs implementation affects build propagation:\n// :feature:home/build.gradle.kts\ndependencies {\n    // implementation: change in :core:network does NOT\n    // recompile modules that depend on :feature:home\n    implementation(project(\":core:network\"))\n\n    // api: change in :core:model DOES recompile\n    // all modules depending on :feature:home\n    api(project(\":core:model\")) // Use sparingly!\n}\n\n// gradle.properties optimizations:\norg.gradle.caching=true           // Local build cache\norg.gradle.parallel=true          // Parallel module builds\norg.gradle.configuration-cache=true // Cache config phase\norg.gradle.daemon=true\nkapt.incremental.apt=true         // Incremental annotation processing\n\n// Module structure impact:\n// BAD: monolith  any change rebuilds everything\n// GOOD: modular  change in :feature:search only rebuilds\n//   :feature:search  :app (not :feature:home, :feature:profile)\n\n// Measure with: ./gradlew --profile assembleDebug\n// Identify slow tasks and cacheable improvements"
  },
  {
    "id": 124,
    "question": "What is the difference between Parcelable and Serializable in Android, and why does performance matter at scale?",
    "answer": "Serializable uses Java reflection for serialization  it's slow and creates many temporary objects triggering GC. Parcelable uses explicit serialization code  it's 10x faster and creates no garbage. At scale (passing data between Activities, Services, IPC), the difference compounds. Use @Parcelize (Kotlin plugin) for easy Parcelable implementation. Note: Parcelable has a 1MB transaction limit via Binder",
    "example": "// Serializable: reflection-based, slow\ndata class User(\n    val id: String,\n    val name: String\n) : Serializable // Creates temp objects, uses reflection\n\n// Parcelable: explicit, fast (~10x faster)\n@Parcelize\ndata class User(\n    val id: String,\n    val name: String\n) : Parcelable // Generated code, no reflection\n\n// Performance at scale:\n// Passing 1000 items via Intent:\n// Serializable: ~50ms + GC pressure\n// Parcelable:   ~5ms, minimal GC\n\n// IMPORTANT: Binder transaction limit = 1MB\n// BAD: passing large data via Intent\nintent.putExtra(\"data\", hugeList) // TransactionTooLargeException!\n\n// GOOD: pass ID, fetch from repository/database\nintent.putExtra(\"userId\", userId)\n// In target Activity:\nval user = repository.getUser(userId)"
  },
  {
    "id": 125,
    "question": "How do you architect a feature toggle / feature flag system for a large Android app?",
    "answer": "Use a FeatureFlag interface backed by remote config (Firebase Remote Config or similar) with local defaults. Cache flags on disk for offline access. Inject flags via DI so they're testable. Use compile-time flags for dead code elimination via R8, and runtime flags for gradual rollouts. Implement a flag evaluation pipeline: hardcoded default  local cache  remote config. Clean up old flags regularly to avoid tech debt",
    "example": "// Feature flag interface\ninterface FeatureFlags {\n    fun isEnabled(flag: Feature): Boolean\n}\n\nenum class Feature(val key: String, val default: Boolean) {\n    NEW_CHECKOUT(\"new_checkout\", false),\n    DARK_MODE(\"dark_mode\", true)\n}\n\n// Implementation with remote config + local cache\nclass RemoteFeatureFlags @Inject constructor(\n    private val remoteConfig: FirebaseRemoteConfig,\n    private val localCache: FeatureFlagCache\n) : FeatureFlags {\n    override fun isEnabled(flag: Feature): Boolean {\n        return try {\n            remoteConfig.getBoolean(flag.key).also {\n                localCache.set(flag.key, it)\n            }\n        } catch (e: Exception) {\n            localCache.get(flag.key) ?: flag.default\n        }\n    }\n}\n\n// Usage in ViewModel:\nclass CheckoutViewModel @Inject constructor(\n    private val flags: FeatureFlags\n) : ViewModel() {\n    val useNewCheckout = flags.isEnabled(Feature.NEW_CHECKOUT)\n}\n\n// In tests:\nclass FakeFeatureFlags : FeatureFlags {\n    private val overrides = mutableMapOf<Feature, Boolean>()\n    override fun isEnabled(flag: Feature) = overrides[flag] ?: flag.default\n}"
  },
  {
    "id": 126,
    "question": "How does Jetpack Compose's slot table and gap buffer work internally, and why does it enable efficient recomposition?",
    "answer": "Compose stores the composition in a slot table  a flat array using a gap buffer data structure. Each composable call writes its state (parameters, remember values, child group info) into sequential slots. The gap buffer allows efficient insertions/deletions by moving the gap to the edit point. During recomposition, the compiler-generated code compares current parameters with stored slots and skips unchanged subtrees entirely, making recomposition O(changed nodes) not O(total nodes)",
    "example": "// Slot table conceptually:\n// [Group(Counter) | count=0 | Group(Button) | Group(Text) | ...]\n\n// Gap buffer for efficient edits:\n// Before insert: [A B C _ _ _ D E F]\n//                         ^^^ gap\n// Insert X at position 3: [A B C X _ _ D E F]\n\n// Recomposition process:\n@Composable\nfun Counter(count: Int) { // Compose checks: did count change?\n    // If count unchanged: SKIP entire subtree\n    // If count changed: re-execute body, update slots\n    Text(\"Count: $count\")\n}\n\n// Why this matters for performance:\n// 1. O(1) parameter comparison at each composable\n// 2. Entire subtrees skipped when inputs unchanged\n// 3. No virtual DOM diffing  direct slot comparison\n// 4. Gap buffer: O(1) amortized inserts/deletes\n\n// Compose compiler generates groups:\n// $composer.startRestartGroup(key)\n// if ($composer.changed(count)) {\n//     Text(\"Count: $count\")\n// } else {\n//     $composer.skipToGroupEnd()\n// }\n// $composer.endRestartGroup()"
  },
  {
    "id": 127,
    "question": "How would you design a robust error handling strategy across layers in a large Android app?",
    "answer": "Use typed Result wrappers (sealed class) at repository boundaries to convert exceptions into domain errors. Never let exceptions propagate silently across layers. Network errors become domain errors in the repository. ViewModels map domain errors to UI error states. Use a global CoroutineExceptionHandler for truly unexpected errors. Log all errors centrally for monitoring. Differentiate between recoverable (show message, retry) and unrecoverable (crash report) errors",
    "example": "// Domain error types\nsealed class AppError {\n    data class Network(val cause: Throwable) : AppError()\n    data class NotFound(val id: String) : AppError()\n    data class Unauthorized(val message: String) : AppError()\n    data class Unknown(val cause: Throwable) : AppError()\n}\n\n// Repository: convert exceptions to typed errors\nclass UserRepository @Inject constructor(private val api: UserApi) {\n    suspend fun getUser(id: String): Either<AppError, User> {\n        return try {\n            Either.Right(api.fetchUser(id))\n        } catch (e: HttpException) {\n            when (e.code()) {\n                404 -> Either.Left(AppError.NotFound(id))\n                401 -> Either.Left(AppError.Unauthorized(e.message()))\n                else -> Either.Left(AppError.Network(e))\n            }\n        } catch (e: IOException) {\n            Either.Left(AppError.Network(e))\n        }\n    }\n}\n\n// ViewModel: map to UI state\nclass UserViewModel : ViewModel() {\n    fun load(id: String) {\n        viewModelScope.launch {\n            when (val result = repo.getUser(id)) {\n                is Either.Right -> _state.update { UiState.Success(result.value) }\n                is Either.Left -> when (result.value) {\n                    is AppError.Network -> _state.update { UiState.Offline }\n                    is AppError.NotFound -> _state.update { UiState.NotFound }\n                    is AppError.Unauthorized -> _events.send(Event.NavigateToLogin)\n                    is AppError.Unknown -> _state.update { UiState.Error(\"Unexpected error\") }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "id": 128,
    "question": "How do you design for process death in Android, and what state needs to survive it?",
    "answer": "Process death can happen at any time when the app is in the background. UI state (scroll position, form input, selected tabs) must be saved via SavedStateHandle or onSaveInstanceState. Transient state (loading indicators) should be re-derived on restore. Persistent data belongs in Room/DataStore. Test by enabling 'Don't keep activities' or using adb kill. Never assume your process will live forever  design every screen to restore from savedState + database",
    "example": "// What survives what:\n//                    Config Change | Process Death | Fresh Launch\n// ViewModel                                        \n// SavedStateHandle                                 \n// Room/DataStore                                   \n// remember {}                                      \n// rememberSaveable                                 \n\nclass SearchViewModel @Inject constructor(\n    private val savedState: SavedStateHandle,\n    private val repo: SearchRepository\n) : ViewModel() {\n    // Survives process death\n    val query = savedState.getStateFlow(\"query\", \"\")\n    // Re-derived from query on restore\n    val results = query\n        .debounce(300)\n        .flatMapLatest { repo.search(it) }\n        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList())\n\n    fun setQuery(q: String) {\n        savedState[\"query\"] = q // Saved to bundle\n    }\n}\n\n// Test process death:\n// adb shell am kill com.example.myapp\n// Or: Developer Options  Don't keep activities"
  },
  {
    "id": 129,
    "question": "What are the performance implications of deep view hierarchies vs flat layouts, and how does this differ in Compose?",
    "answer": "In XML Views, each nested ViewGroup triggers measure/layout passes that compound exponentially (especially with RelativeLayout/ConstraintLayout nesting). Deep hierarchies cause O(2^n) measurement in worst case. In Compose, this is mostly solved: Compose measures each child exactly once due to intrinsic measurement constraints and the single-pass layout model. However, unnecessary nesting still adds overhead from composition and placement",
    "example": "// XML View system: multi-pass measurement problem\n// RelativeLayout measures children TWICE\n// Nesting RelativeLayouts: 2^depth measurements!\n\n// BAD: 3 levels of RelativeLayout = 2^3 = 8 measure passes\n<RelativeLayout>           <!-- measures children 2x -->\n    <RelativeLayout>       <!-- measures children 2x -->\n        <RelativeLayout>   <!-- measures children 2x -->\n            <TextView/>    <!-- measured 8 times! -->\n\n// GOOD in XML: flat ConstraintLayout\n<ConstraintLayout>  <!-- single flat level -->\n    <TextView app:layout_constraintTop_toTopOf=\"parent\"/>\n    <Button app:layout_constraintTop_toBottomOf=\"@id/text\"/>\n\n// Compose: single-pass layout by design\n// Each child measured EXACTLY ONCE\n@Composable\nfun MyLayout() {\n    Column {\n        Row {  // Nesting is fine  still single measure pass\n            Box {\n                Text(\"Measured once\") // Always O(n)\n            }\n        }\n    }\n}\n\n// Compose intrinsic measurements when needed:\nRow(Modifier.height(IntrinsicSize.Min)) {\n    // Children measured with intrinsic height constraint\n    // Still efficient: only 2 passes (intrinsic + actual)\n}"
  },
  {
    "id": 130,
    "question": "How would you implement a clean architecture layer separation that scales and remains testable?",
    "answer": "Use three layers: Presentation (UI + ViewModel), Domain (use cases + repository interfaces + models), and Data (repository implementations + data sources). The Domain layer has zero Android dependencies and defines interfaces that Data implements. Dependencies point inward: Presentation  Domain  Data. Use cases encapsulate business logic and are independently testable. Hilt binds Data implementations to Domain interfaces",
    "example": "// Domain layer (pure Kotlin, no Android imports)\ndata class User(val id: String, val name: String, val email: String)\n\ninterface UserRepository {\n    fun observeUser(id: String): Flow<User>\n    suspend fun updateEmail(id: String, email: String)\n}\n\nclass UpdateUserEmailUseCase @Inject constructor(\n    private val repo: UserRepository,\n    private val validator: EmailValidator\n) {\n    suspend operator fun invoke(userId: String, email: String): Result<Unit> {\n        if (!validator.isValid(email)) return Result.failure(InvalidEmailException())\n        return runCatching { repo.updateEmail(userId, email) }\n    }\n}\n\n// Data layer (Android + libraries)\nclass UserRepositoryImpl @Inject constructor(\n    private val api: UserApi,\n    private val dao: UserDao\n) : UserRepository { ... }\n\n// DI binding\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class DataModule {\n    @Binds\n    abstract fun bindUserRepo(impl: UserRepositoryImpl): UserRepository\n}\n\n// Presentation layer\nclass ProfileViewModel @Inject constructor(\n    private val updateEmail: UpdateUserEmailUseCase\n) : ViewModel() { ... }\n\n// Test: no mocking framework needed\nclass UpdateUserEmailUseCaseTest {\n    @Test\n    fun `rejects invalid email`() = runTest {\n        val useCase = UpdateUserEmailUseCase(FakeUserRepo(), FakeValidator(false))\n        val result = useCase(\"1\", \"bad\")\n        assertTrue(result.isFailure)\n    }\n}"
  },
  {
    "id": 131,
    "question": "How would you design a real-time messaging/chat feature for an Android app?",
    "answer": "Use WebSocket (OkHttp) for persistent bidirectional communication. Store messages in Room as the single source of truth. Queue outgoing messages locally first (optimistic UI), then send via WebSocket. Handle reconnection with exponential backoff. Use a foreground service to maintain the connection when the app is backgrounded. Implement pagination for message history (load from server on scroll up, cache in Room). Sync state on reconnect by requesting messages since last known ID",
    "example": "// Architecture:\n// UI  Flow  Room  WebSocket sync + REST API\n\nclass ChatRepository @Inject constructor(\n    private val webSocket: ChatWebSocket,\n    private val dao: MessageDao,\n    private val api: ChatApi\n) {\n    // UI observes local DB\n    fun getMessages(chatId: String): Flow<List<Message>> =\n        dao.observeMessages(chatId)\n\n    // Send: save locally first (optimistic), then send\n    suspend fun send(message: Message) {\n        dao.insert(message.copy(status = Status.SENDING))\n        try {\n            webSocket.send(message)\n            dao.updateStatus(message.id, Status.SENT)\n        } catch (e: Exception) {\n            dao.updateStatus(message.id, Status.FAILED)\n        }\n    }\n\n    // WebSocket listener saves incoming to DB\n    fun startListening() {\n        webSocket.onMessage { msg ->\n            dao.upsert(msg) // Triggers Flow emission to UI\n        }\n    }\n\n    // On reconnect: sync from last known message\n    suspend fun syncFromLastKnown(chatId: String) {\n        val lastId = dao.getLastMessageId(chatId)\n        val missed = api.getMessagesSince(chatId, lastId)\n        dao.insertAll(missed)\n    }\n}"
  },
  {
    "id": 132,
    "question": "What is R8 full mode and how does it affect your app's performance and correctness?",
    "answer": "R8 full mode (android.enableR8.fullMode=true) enables aggressive optimizations: it assumes classes not mentioned in keep rules can be removed or optimized, performs more aggressive inlining, removes unused class metadata, and can break reflection-based code that isn't properly kept. It produces smaller APKs but requires thorough ProGuard rule coverage. Test release builds extensively because issues only manifest in minified builds",
    "example": "// gradle.properties\nandroid.enableR8.fullMode=true\n\n// R8 full mode aggressively removes:\n// 1. Unused classes, methods, fields\n// 2. Default constructors if unused\n// 3. Class metadata not needed at runtime\n\n// Common issues and fixes:\n\n// 1. Gson/Moshi deserialization breaks (needs constructor)\n// proguard-rules.pro:\n-keep class com.example.model.** { *; }\n\n// 2. Enum.valueOf() breaks\n-keepclassmembers enum * { *; }\n\n// 3. Kotlin reflection breaks\n-keep class kotlin.Metadata { *; }\n\n// 4. Hilt generated code removed\n// Hilt provides its own rules, but custom factories may need:\n-keep class * extends dagger.internal.Factory\n\n// Testing strategy:\n// - ALWAYS test release build before shipping\n// - Use mapping.txt to decode crash stack traces\n// - Compare APK sizes: full mode saves 5-15% more\n// - Use -printusage to see what R8 removed"
  },
  {
    "id": 133,
    "question": "How do you handle configuration changes beyond screen rotation, and what are the trade-offs of android:configChanges?",
    "answer": "Configuration changes include rotation, locale, dark mode, font scale, screen size, and keyboard. Default behavior recreates the Activity, which is usually correct with ViewModel + SavedStateHandle. Declaring android:configChanges handles changes manually without recreation but you must handle every aspect yourself  risky and error-prone. Only use configChanges for specific cases like video players. Compose handles config changes declaratively via Configuration.current",
    "example": "// Default: Activity recreated (recommended)\n// ViewModel survives, SavedStateHandle survives,\n// Compose recomposes with new Configuration\n\n// Only declare configChanges when Activity recreation\n// is truly problematic:\n<activity\n    android:name=\".VideoPlayerActivity\"\n    android:configChanges=\"orientation|screenSize|screenLayout\">\n</activity>\n\n// Then handle manually:\noverride fun onConfigurationChanged(newConfig: Configuration) {\n    super.onConfigurationChanged(newConfig)\n    // YOU must handle everything:\n    // - Relayout UI\n    // - Reload resources (strings change with locale!)\n    // - Update dimensions\n    // Easy to miss things  bugs\n}\n\n// In Compose: config changes are reactive\n@Composable\nfun AdaptiveLayout() {\n    val config = LocalConfiguration.current\n    if (config.orientation == Configuration.ORIENTATION_LANDSCAPE) {\n        LandscapeLayout()\n    } else {\n        PortraitLayout()\n    }\n    // Automatically recomposes on config change\n}\n\n// Common config changes:\n// orientation, screenSize, uiMode (dark mode),\n// locale, fontScale, keyboard, screenLayout"
  },
  {
    "id": 134,
    "question": "How does Android's Garbage Collector work and how do you minimize GC pauses in performance-critical paths?",
    "answer": "ART uses a concurrent copying GC (CC GC) that runs mostly concurrently with app threads, reducing pause times to ~1ms. However, GC is still triggered by allocation pressure. In performance-critical paths (scrolling, animations, 60fps rendering), excessive allocations cause more frequent GC runs that can steal CPU time. Minimize allocations by reusing objects (object pools, RecyclerView ViewHolder pattern), avoiding autoboxing, using primitive arrays, and pre-allocating collections",
    "example": "// ART GC types:\n// - Concurrent Copying (CC): default, ~1ms pauses\n// - Young generation: collects short-lived objects (fast)\n// - Full GC: compacts entire heap (rare, longer pause)\n\n// BAD: allocations in draw/scroll path\nfun onDraw(canvas: Canvas) {\n    val paint = Paint()           // New object every frame!\n    val rect = Rect(0, 0, w, h)   // Another allocation\n    canvas.drawRect(rect, paint)\n}\n\n// GOOD: pre-allocate and reuse\nprivate val paint = Paint()\nprivate val rect = Rect()\nfun onDraw(canvas: Canvas) {\n    rect.set(0, 0, w, h)         // Reuse existing\n    canvas.drawRect(rect, paint)  // Zero allocations\n}\n\n// BAD: autoboxing in hot loop\nval map = HashMap<Int, Int>()    // Boxes every int\nfor (i in 0..1000) map[i] = i    // 2000 Integer objects!\n\n// GOOD: use SparseIntArray\nval map = SparseIntArray()       // No boxing\nfor (i in 0..1000) map.put(i, i) // Primitives only\n\n// Monitor GC in Logcat:\n// D/art: CC GC freed 4200(520KB) AllocSpace objects\n// Use Android Studio Profiler  Memory to track allocations"
  },
  {
    "id": 135,
    "question": "How do you test ViewModels, Repositories, and Use Cases effectively in a large Android codebase?",
    "answer": "Use fakes (not mocks) for repository interfaces  they're simpler, more readable, and test real behavior. Test ViewModels with Turbine for Flow assertions and kotlinx-coroutines-test for controlling dispatchers. Test Use Cases as pure unit tests with no Android dependencies. Use TestDispatcher to control time (advanceUntilIdle, advanceTimeBy). Structure tests as Given-When-Then. Keep tests fast by avoiding Robolectric for ViewModel tests",
    "example": "// Fake repository (preferred over mocking)\nclass FakeUserRepository : UserRepository {\n    private val users = MutableStateFlow<List<User>>(emptyList())\n    fun emit(list: List<User>) { users.value = list }\n    override fun observeUsers() = users\n    override suspend fun refresh() { /* no-op or configurable */ }\n}\n\n// ViewModel test with Turbine\n@OptIn(ExperimentalCoroutinesApi::class)\nclass UserViewModelTest {\n    private val repo = FakeUserRepository()\n    private val testDispatcher = UnconfinedTestDispatcher()\n\n    @Before\n    fun setup() { Dispatchers.setMain(testDispatcher) }\n    @After\n    fun tearDown() { Dispatchers.resetMain() }\n\n    @Test\n    fun `loading state then data`() = runTest {\n        val vm = UserViewModel(repo)\n        vm.state.test { // Turbine\n            assertEquals(UiState.Loading, awaitItem())\n            repo.emit(listOf(User(\"1\", \"Alice\")))\n            val success = awaitItem() as UiState.Success\n            assertEquals(1, success.users.size)\n        }\n    }\n}\n\n// Use case test (pure unit test)\n@Test\nfun `rejects empty name`() = runTest {\n    val useCase = CreateUserUseCase(FakeUserRepository())\n    val result = useCase(name = \"\")\n    assertTrue(result.isFailure)\n}"
  },
  {
    "id": 136,
    "question": "What is the Baseline Profile and how does it improve app startup and runtime performance?",
    "answer": "Baseline Profiles are a list of classes and methods that should be pre-compiled (AOT) at install time. Without them, ART interprets code first, then JIT-compiles hot paths  causing jank on first use. With Baseline Profiles, critical paths are compiled ahead of time, improving startup by 15-30% and reducing jank in critical user journeys. They're generated using Macrobenchmark library by recording actual user flows",
    "example": "// Generate with Macrobenchmark:\n@OptIn(ExperimentalBaselineProfilesApi::class)\nclass BaselineProfileGenerator {\n    @get:Rule\n    val rule = BaselineProfileRule()\n\n    @Test\n    fun generateProfile() {\n        rule.collect(packageName = \"com.example.app\") {\n            // Simulate critical user journey\n            pressHome()\n            startActivityAndWait()\n            device.findObject(By.text(\"Search\")).click()\n            device.waitForIdle()\n        }\n    }\n}\n\n// Output: baseline-prof.txt in src/main/\n// Contains: HSPLcom/example/MyClass;->myMethod()V\n// H=Hot, S=Startup, P=Post-startup, L=Location\n\n// build.gradle:\ndependencies {\n    implementation(\"androidx.profileinstaller:profileinstaller:1.3.x\")\n    baselineProfile(project(\":benchmark\"))\n}\n\n// Impact:\n// - Without: code interpreted  JIT  compiled (jank!)\n// - With: critical code AOT compiled at install\n// - Startup: 15-30% faster\n// - Scroll jank: significantly reduced on first use\n// - Google Play auto-distributes cloud profiles too"
  },
  {
    "id": 137,
    "question": "How do you handle database migrations safely at scale with Room?",
    "answer": "Define explicit Migration objects for each version bump with SQL statements. Use fallbackToDestructiveMigration only in development. Test migrations with MigrationTestHelper which creates the DB at the old version, runs migrations, and verifies the schema. For complex migrations, use AutoMigration (Room 2.4+) for simple schema changes and manual migrations for data transformations. Always test on real devices with production-like data volumes",
    "example": "// Manual migration\nval MIGRATION_1_2 = object : Migration(1, 2) {\n    override fun migrate(db: SupportSQLiteDatabase) {\n        db.execSQL(\"ALTER TABLE user ADD COLUMN email TEXT NOT NULL DEFAULT ''\")\n    }\n}\n\nval MIGRATION_2_3 = object : Migration(2, 3) {\n    override fun migrate(db: SupportSQLiteDatabase) {\n        // Complex: create new table, copy data, drop old\n        db.execSQL(\"CREATE TABLE user_new (id TEXT PRIMARY KEY NOT NULL, name TEXT NOT NULL, email TEXT NOT NULL)\")\n        db.execSQL(\"INSERT INTO user_new SELECT id, name, email FROM user\")\n        db.execSQL(\"DROP TABLE user\")\n        db.execSQL(\"ALTER TABLE user_new RENAME TO user\")\n    }\n}\n\n// Auto migration (Room 2.4+)\n@Database(\n    entities = [User::class],\n    version = 3,\n    autoMigrations = [\n        AutoMigration(from = 1, to = 2),\n        AutoMigration(from = 2, to = 3, spec = Migration2To3::class)\n    ]\n)\nabstract class AppDatabase : RoomDatabase()\n\n// Test migration\n@Test\nfun migrate1To2() {\n    helper.createDatabase(DB_NAME, 1).apply {\n        execSQL(\"INSERT INTO user VALUES ('1', 'Alice')\")\n        close()\n    }\n    helper.runMigrationsAndValidate(DB_NAME, 2, true, MIGRATION_1_2)\n}"
  },
  {
    "id": 138,
    "question": "What is the difference between Dispatchers.IO and a custom limitedParallelism dispatcher, and when would you use each?",
    "answer": "Dispatchers.IO has a shared pool of up to 64 threads. If you launch 100 database operations on Dispatchers.IO, they all compete for those 64 threads alongside network calls. limitedParallelism creates a view of a dispatcher capped at N threads, isolating workloads. Use it to prevent one type of work from starving another  e.g., limit DB operations to 4 threads so they don't block network calls",
    "example": "// Problem: everything shares Dispatchers.IO (64 threads)\nviewModelScope.launch(Dispatchers.IO) { api.fetch() }  // Network\nviewModelScope.launch(Dispatchers.IO) { db.query() }   // Database\nviewModelScope.launch(Dispatchers.IO) { file.read() }  // File I/O\n// All compete for same 64 threads!\n\n// Solution: isolated dispatchers with limitedParallelism\nobject AppDispatchers {\n    val network = Dispatchers.IO.limitedParallelism(10)\n    val database = Dispatchers.IO.limitedParallelism(4)\n    val fileIo = Dispatchers.IO.limitedParallelism(2)\n}\n\n// Now workloads are isolated:\nwithContext(AppDispatchers.network) { api.fetch() }\nwithContext(AppDispatchers.database) { db.query() }\n\n// Benefits:\n// - DB burst can't starve network calls\n// - Easier to reason about thread usage\n// - Prevents connection pool exhaustion\n//   (e.g., Room default pool = 4 connections)\n\n// Note: limitedParallelism doesn't create new threads\n// It limits concurrent coroutines on the parent dispatcher"
  },
  {
    "id": 139,
    "question": "How do you handle deep linking and navigation in a multi-module app without modules depending on each other?",
    "answer": "Use a shared navigation module that defines route constants or sealed route classes. Each feature module registers its composable destinations against these routes. Use implicit deep links (URI patterns) for inter-module navigation instead of explicit class references. The app module composes the navigation graph from all feature modules. For arguments, use type-safe route parameters. This preserves module independence while enabling cross-feature navigation",
    "example": "// :core:navigation module (shared)\nobject Routes {\n    const val HOME = \"home\"\n    const val PROFILE = \"profile/{userId}\"\n    const val SETTINGS = \"settings\"\n    fun profile(userId: String) = \"profile/$userId\"\n}\n\n// :feature:home module  registers its own destinations\nfun NavGraphBuilder.homeScreen(onNavigateToProfile: (String) -> Unit) {\n    composable(Routes.HOME) {\n        HomeScreen(onUserClick = onNavigateToProfile)\n    }\n}\n\n// :feature:profile module  independent of :feature:home\nfun NavGraphBuilder.profileScreen() {\n    composable(\n        Routes.PROFILE,\n        arguments = listOf(navArgument(\"userId\") { type = NavType.StringType })\n    ) { backStackEntry ->\n        val userId = backStackEntry.arguments?.getString(\"userId\")\n        ProfileScreen(userId = userId!!)\n    }\n}\n\n// :app module  composes the full graph\nNavHost(navController, startDestination = Routes.HOME) {\n    homeScreen(onNavigateToProfile = { navController.navigate(Routes.profile(it)) })\n    profileScreen()\n}"
  },
  {
    "id": 140,
    "question": "How does Android App Bundle (AAB) reduce APK size and how does Dynamic Feature Delivery work?",
    "answer": "AAB contains all compiled code and resources but Google Play generates optimized APKs per device configuration (ABI, screen density, language). This eliminates shipping unused resources  typically 15-25% smaller than universal APK. Dynamic Feature modules are downloaded on demand, keeping initial install small. Play Feature Delivery supports install-time, on-demand, and conditional delivery modes",
    "example": "// App Bundle structure:\n// base/            always installed\n//   dex/           code\n//   res/           resources\n//   lib/           native libs (arm64-v8a, x86, etc.)\n// feature_camera/  on-demand module\n// feature_ar/      on-demand module\n\n// Size savings:\n// Universal APK: 80MB (all ABIs + all densities)\n// App Bundle:    ~30MB per device (matching ABI + density)\n\n// Dynamic feature module:\n// feature_camera/build.gradle.kts\nplugins { id(\"com.android.dynamic-feature\") }\nandroid {\n    // ...delivery modes:\n}\n\n// On-demand download:\nval manager = SplitInstallManagerFactory.create(context)\nval request = SplitInstallRequest.newBuilder()\n    .addModule(\"feature_camera\")\n    .build()\n\nmanager.startInstall(request)\n    .addOnSuccessListener { sessionId ->\n        // Monitor download progress\n    }\n    .addOnFailureListener { exception ->\n        // Handle download failure\n    }\n\n// After install, access via reflection or Navigation:\nnavController.navigate(\"camera_feature_route\")"
  },
  {
    "id": 141,
    "question": "What is the difference between EncryptedSharedPreferences, DataStore, and the Keystore system for storing sensitive data?",
    "answer": "EncryptedSharedPreferences encrypts keys and values at rest using AES-256 (backed by Keystore)  use for sensitive preferences like tokens. DataStore is for general app preferences with type safety and coroutine support but doesn't encrypt by default. The Android Keystore stores cryptographic keys in hardware-backed storage that can't be extracted  use for encryption keys, signing keys, and biometric-protected secrets. Never store raw secrets in SharedPreferences or DataStore",
    "example": "// EncryptedSharedPreferences: encrypted key-value store\nval masterKey = MasterKey.Builder(context)\n    .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n    .build()\n\nval encryptedPrefs = EncryptedSharedPreferences.create(\n    context, \"secret_prefs\", masterKey,\n    PrefKeyEncryptionScheme.AES256_SIV,\n    PrefValueEncryptionScheme.AES256_GCM\n)\nencryptedPrefs.edit().putString(\"auth_token\", token).apply()\n\n// Android Keystore: hardware-backed key storage\nval keyGenerator = KeyGenerator.getInstance(\n    KeyProperties.KEY_ALGORITHM_AES, \"AndroidKeyStore\"\n)\nkeyGenerator.init(\n    KeyGenParameterSpec.Builder(\"my_key\",\n        KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT)\n        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)\n        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)\n        .setUserAuthenticationRequired(true) // Require biometric\n        .build()\n)\nval secretKey = keyGenerator.generateKey()\n// Key NEVER leaves secure hardware\n\n// Rule of thumb:\n// Tokens/passwords  EncryptedSharedPreferences\n// Crypto keys  Android Keystore\n// App preferences  DataStore (non-sensitive)"
  },
  {
    "id": 142,
    "question": "How do you profile and optimize app size for a large Android application?",
    "answer": "Use Android Studio APK Analyzer to identify size contributors. Enable R8 minification and resource shrinking. Use App Bundle for per-device optimization. Remove unused resources with lint. Replace PNGs with WebP or vector drawables. Use dynamic feature modules for optional features. Audit dependencies  exclude transitive dependencies you don't need. Monitor APK size in CI to prevent regressions. Target: keep initial download under 15MB for emerging markets",
    "example": "// build.gradle.kts: enable all size optimizations\nandroid {\n    buildTypes {\n        release {\n            isMinifyEnabled = true    // R8 code shrinking\n            isShrinkResources = true  // Remove unused resources\n            proguardFiles(getDefaultProguardFile(\n                \"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\n        }\n    }\n    // Remove unused language resources\n    defaultConfig {\n        resourceConfigurations += listOf(\"en\", \"es\", \"fr\")\n    }\n}\n\n// APK Analyzer breakdown (typical large app):\n// classes.dex     15MB  R8 reduces to 8MB\n// res/            20MB  shrink + WebP  8MB\n// lib/            30MB  App Bundle  10MB (per device)\n// assets/         5MB   compress, lazy download\n\n// CI size check:\n// ./gradlew assembleRelease\n// Check: app-release.apk < 25MB threshold\n\n// Dependency audit:\n// ./gradlew :app:dependencies\n// Exclude unused transitive deps:\nimplementation(\"com.example:library\") {\n    exclude(group = \"com.unused\", module = \"heavy-dep\")\n}"
  },
  {
    "id": 143,
    "question": "What is the MVI reduce pattern and how does it guarantee state consistency in complex screens?",
    "answer": "The reduce pattern processes intents (user actions) through a pure reducer function: (currentState, intent) -> newState. The reducer runs on a single thread/coroutine, ensuring state transitions are atomic and sequential. Side effects (API calls, navigation) are triggered after state updates, not inside the reducer. This eliminates race conditions between concurrent events, makes state transitions reproducible, and enables easy logging and time-travel debugging",
    "example": "// State, Intent, and Side Effect\ndata class SearchState(\n    val query: String = \"\",\n    val results: List<Item> = emptyList(),\n    val isLoading: Boolean = false,\n    val error: String? = null\n)\n\nsealed class SearchIntent {\n    data class QueryChanged(val query: String) : SearchIntent()\n    object Search : SearchIntent()\n    data class ResultsLoaded(val items: List<Item>) : SearchIntent()\n    data class ErrorOccurred(val msg: String) : SearchIntent()\n}\n\nsealed class SideEffect {\n    data class PerformSearch(val query: String) : SideEffect()\n}\n\nclass SearchViewModel : ViewModel() {\n    private val _state = MutableStateFlow(SearchState())\n    val state = _state.asStateFlow()\n\n    // Pure reducer  no side effects, just state transformation\n    private fun reduce(state: SearchState, intent: SearchIntent): Pair<SearchState, SideEffect?> =\n        when (intent) {\n            is SearchIntent.QueryChanged -> state.copy(query = intent.query) to null\n            is SearchIntent.Search -> state.copy(isLoading = true, error = null) to\n                SideEffect.PerformSearch(state.query)\n            is SearchIntent.ResultsLoaded -> state.copy(\n                isLoading = false, results = intent.items) to null\n            is SearchIntent.ErrorOccurred -> state.copy(\n                isLoading = false, error = intent.msg) to null\n        }\n\n    fun dispatch(intent: SearchIntent) {\n        val (newState, effect) = reduce(_state.value, intent)\n        _state.value = newState // Atomic update\n        effect?.let { handleSideEffect(it) }\n    }\n}"
  },
  {
    "id": 144,
    "question": "How do you implement efficient list diffing and updates in LazyColumn/RecyclerView at scale?",
    "answer": "Use DiffUtil (RecyclerView) or keys (LazyColumn) so the framework computes minimal operations (insert, delete, move) instead of rebinding everything. Provide stable unique keys  not list indices. For large datasets, run DiffUtil on a background thread via AsyncListDiffer or ListAdapter. In Compose, ensure list item data classes are stable/immutable so recomposition is skipped for unchanged items. Avoid creating new objects on every emission",
    "example": "// RecyclerView: ListAdapter handles diff on background thread\nclass UserAdapter : ListAdapter<User, UserViewHolder>(\n    object : DiffUtil.ItemCallback<User>() {\n        override fun areItemsTheSame(old: User, new: User) = old.id == new.id\n        override fun areContentsTheSame(old: User, new: User) = old == new\n    }\n)\n\n// Submit new list  diff computed on background thread:\nadapter.submitList(newList)\n\n// Compose LazyColumn: keys + stable data\n@Immutable\ndata class User(val id: String, val name: String, val avatar: String)\n\nLazyColumn {\n    items(\n        items = users,\n        key = { it.id } // Enables move animations, preserves state\n    ) { user ->\n        UserRow(user) // Skipped if user instance unchanged\n    }\n}\n\n// BAD: creating new objects defeats skip optimization\nval users = rawList.map { User(it.id, it.name, it.avatar) } // New instances!\n\n// GOOD: use distinctUntilChanged or ensure same instances\nval users = rawFlow\n    .distinctUntilChanged() // Only emit when actually changed\n    .stateIn(viewModelScope, SharingStarted.WhileSubscribed(), emptyList())"
  },
  {
    "id": 145,
    "question": "What is Strict Mode and what other debugging tools should a senior Android engineer use regularly?",
    "answer": "StrictMode detects disk/network I/O on the main thread and resource leaks during development. Beyond StrictMode, use: LeakCanary (memory leaks), Android Studio Profiler (CPU, memory, network, energy), Layout Inspector (Compose recomposition counts), Systrace/Perfetto (system-wide frame analysis), Flipper (network inspection, DB browsing), and Macrobenchmark (startup and scroll benchmarks). Set up CI to catch regressions with benchmark tests",
    "example": "// StrictMode: catch I/O on main thread\nif (BuildConfig.DEBUG) {\n    StrictMode.setThreadPolicy(ThreadPolicy.Builder()\n        .detectDiskReads()\n        .detectDiskWrites()\n        .detectNetwork()\n        .penaltyLog()   // Log violations\n        .penaltyDeath() // Or crash to force fix\n        .build())\n\n    StrictMode.setVmPolicy(VmPolicy.Builder()\n        .detectLeakedClosableObjects()\n        .detectLeakedSqlLiteObjects()\n        .detectActivityLeaks()\n        .penaltyLog()\n        .build())\n}\n\n// LeakCanary: auto-detects leaks\n// debugImplementation(\"com.squareup.leakcanary:leakcanary-android:2.x\")\n// Shows leak trace in notification\n\n// Macrobenchmark: CI-friendly perf testing\n@LargeTest\nclass StartupBenchmark {\n    @get:Rule\n    val benchmarkRule = MacrobenchmarkRule()\n\n    @Test\n    fun startupCompilation() = benchmarkRule.measureRepeated(\n        packageName = \"com.example.app\",\n        metrics = listOf(StartupTimingMetric()),\n        iterations = 10,\n        startupMode = StartupMode.COLD\n    ) {\n        pressHome()\n        startActivityAndWait()\n    }\n    // Results: timeToInitialDisplay: 350ms median\n}"
  },
  {
    "id": 146,
    "question": "Why is Kotlin preferred over Java for Android development?",
    "answer": "Kotlin offers null safety at the type system level (eliminating NullPointerException crashes), coroutines for structured concurrency (replacing verbose callback/RxJava chains), concise data classes (replacing Java boilerplate with equals/hashCode/toString/copy), extension functions for cleaner APIs, scope functions (let, apply, also, run, with) for fluent code, sealed classes for exhaustive when-expressions, and default/named arguments eliminating the need for builder patterns or method overloads. Google made Kotlin the recommended language for Android in 2019, and most Jetpack libraries are Kotlin-first",
    "example": "// 1. Null safety  compiler-enforced, no more NPE crashes\n// Java:\nString name = user.getName(); // Can be null  NPE at runtime!\nint length = name.length();    //  NullPointerException\n\n// Kotlin:\nval name: String? = user.name  // Nullable type explicit\nval length = name?.length ?: 0 // Safe call + default\n\n// 2. Coroutines vs callbacks\n// Java (callback hell):\napi.getUser(id, new Callback<User>() {\n    @Override\n    public void onSuccess(User user) {\n        api.getPosts(user.getId(), new Callback<List<Post>>() {\n            @Override\n            public void onSuccess(List<Post> posts) { /* ... */ }\n            @Override\n            public void onFailure(Exception e) { /* ... */ }\n        });\n    }\n    @Override\n    public void onFailure(Exception e) { /* ... */ }\n});\n\n// Kotlin (sequential, readable):\nviewModelScope.launch {\n    val user = api.getUser(id)       // Suspends, no callback\n    val posts = api.getPosts(user.id) // Sequential, readable\n    _state.value = UiState(user, posts)\n}\n\n// 3. Data classes vs Java POJOs\n// Java: ~60 lines for equals, hashCode, toString, getters\npublic class User {\n    private final String id;\n    private final String name;\n    public User(String id, String name) { ... }\n    public String getId() { return id; }\n    public String getName() { return name; }\n    @Override public boolean equals(Object o) { ... }\n    @Override public int hashCode() { ... }\n    @Override public String toString() { ... }\n}\n\n// Kotlin: 1 line\ndata class User(val id: String, val name: String)\n// Gets equals, hashCode, toString, copy, destructuring for free\n\n// 4. Sealed classes for exhaustive state handling\nsealed class Result<out T> {\n    data class Success<T>(val data: T) : Result<T>()\n    data class Error(val exception: Throwable) : Result<Nothing>()\n    object Loading : Result<Nothing>()\n}\n\nwhen (result) {\n    is Result.Success -> showData(result.data)\n    is Result.Error -> showError(result.exception)\n    Result.Loading -> showSpinner()\n    // No 'else' needed  compiler ensures all cases handled\n}\n\n// 5. Extension functions for cleaner APIs\nfun View.visible() { visibility = View.VISIBLE }\nfun View.gone() { visibility = View.GONE }\n// Usage: myButton.visible()  reads like English"
  },
  {
    "id": 147,
    "question": "Why is Jetpack Compose preferred over the XML View system for building Android UIs?",
    "answer": "Compose uses a declarative paradigm where UI is a function of state  you describe what the UI should look like, not how to mutate it step by step. This eliminates entire categories of bugs (stale views, forgotten visibility toggles, adapter sync issues). Compose offers a single-language experience (Kotlin only, no XML), built-in state management with automatic recomposition, a single-pass layout system (vs Views' multi-pass measurement), powerful theming via MaterialTheme and CompositionLocal, easy animations, better preview tooling, and first-class support for unidirectional data flow. It also removes the need for Fragments, View Binding, RecyclerView adapters, and XML resource inflation",
    "example": "// 1. Declarative vs imperative UI updates\n// XML Views (imperative  you manage every mutation):\nfun updateProfile(user: User) {\n    nameTextView.text = user.name\n    emailTextView.text = user.email\n    avatarImageView.load(user.avatarUrl)\n    if (user.isVerified) {\n        verifiedBadge.visibility = View.VISIBLE  // Easy to forget!\n    } else {\n        verifiedBadge.visibility = View.GONE\n    }\n    // Bug: what if a new field is added? Must update here too.\n}\n\n// Compose (declarative  UI is a function of state):\n@Composable\nfun ProfileScreen(user: User) {\n    Column {\n        Text(user.name)\n        Text(user.email)\n        AsyncImage(user.avatarUrl)\n        if (user.isVerified) VerifiedBadge() // Automatic!\n    }\n    // State changes  recomposition  UI always in sync\n}\n\n// 2. No more RecyclerView + Adapter + ViewHolder boilerplate\n// XML Views: ~100 lines (Adapter + ViewHolder + DiffUtil)\nclass UserAdapter : ListAdapter<User, UserViewHolder>(DiffCallback) {\n    override fun onCreateViewHolder(...): UserViewHolder { ... }\n    override fun onBindViewHolder(holder: UserViewHolder, pos: Int) {\n        holder.bind(getItem(pos))\n    }\n}\nclass UserViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n    fun bind(user: User) { ... }\n}\n\n// Compose: ~10 lines\n@Composable\nfun UserList(users: List<User>) {\n    LazyColumn {\n        items(users, key = { it.id }) { user ->\n            UserRow(user)\n        }\n    }\n}\n\n// 3. Theming  no more styles.xml, themes.xml, attrs.xml\n// XML: scattered across multiple XML files\n// styles.xml, themes.xml, attrs.xml, colors.xml...\n\n// Compose: all in Kotlin, type-safe, composable\nMaterialTheme(\n    colorScheme = if (isDark) darkColorScheme() else lightColorScheme(),\n    typography = Typography(bodyLarge = TextStyle(fontSize = 16.sp))\n) {\n    // Access anywhere:\n    Text(color = MaterialTheme.colorScheme.primary)\n}\n\n// 4. Animations  trivial in Compose, painful in Views\n// XML: ObjectAnimator, TransitionManager, MotionLayout (verbose)\n// Compose:\nAnimatedVisibility(visible = showPanel) {\n    Panel() // Fade + expand built-in, customizable\n}\nval size by animateDpAsState(if (expanded) 300.dp else 100.dp)\nBox(Modifier.size(size)) // Smoothly animates\n\n// 5. Live previews without running the app\n@Preview(showBackground = true)\n@Preview(uiMode = UI_MODE_NIGHT_YES) // Dark mode preview\n@Composable\nfun ProfilePreview() {\n    ProfileScreen(user = User.preview())\n}"
  },
  {
    "id": 148,
    "question": "What does `null.toString()` return in Kotlin, and why does it matter?",
    "answer": "It returns the 4-character string \"null\"  not an exception and not an empty string. Kotlin defines `toString()` as an extension on `Any?`, so null receivers are safe. This matters because it can introduce silent bugs: null values quietly become the string \"null\" in UI text, API requests, or database writes instead of crashing early or showing empty. In Java, `null.toString()` throws a NullPointerException, making the bug immediately visible",
    "example": "val name: String? = null\nname.toString()          // \"null\" (4 chars, no crash)\nname.toString().isEmpty() // false! It's not empty\n\n// Silent bug: user sees literal \"null\" in UI\nText(\"Hello ${name.toString()}\") // displays: Hello null\n\n// Fix: use elvis operator\nText(\"Hello ${name ?: \"\"}\"})    // displays: Hello\n\n// Java comparison:\n// null.toString()  NullPointerException (fails fast)\n// Kotlin hides the problem  always check with != null"
  }
]
